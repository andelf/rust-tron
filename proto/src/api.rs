// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `api/api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Return {
    // message fields
    pub result: bool,
    pub code: Return_response_code,
    pub message: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Return {
    fn default() -> &'a Return {
        <Return as ::protobuf::Message>::default_instance()
    }
}

impl Return {
    pub fn new() -> Return {
        ::std::default::Default::default()
    }

    // bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = false;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = v;
    }

    // .protocol.Return.response_code code = 2;


    pub fn get_code(&self) -> Return_response_code {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = Return_response_code::SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Return_response_code) {
        self.code = v;
    }

    // bytes message = 3;


    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Return {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != false {
            my_size += 2;
        }
        if self.code != Return_response_code::SUCCESS {
            my_size += ::protobuf::rt::enum_size(2, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != false {
            os.write_bool(1, self.result)?;
        }
        if self.code != Return_response_code::SUCCESS {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        if !self.message.is_empty() {
            os.write_bytes(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Return {
        Return::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &Return| { &m.result },
                |m: &mut Return| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Return_response_code>>(
                "code",
                |m: &Return| { &m.code },
                |m: &mut Return| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "message",
                |m: &Return| { &m.message },
                |m: &mut Return| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Return>(
                "Return",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Return {
        static instance: ::protobuf::rt::LazyV2<Return> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Return::new)
    }
}

impl ::protobuf::Clear for Return {
    fn clear(&mut self) {
        self.result = false;
        self.code = Return_response_code::SUCCESS;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Return {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Return {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Return_response_code {
    SUCCESS = 0,
    SIGERROR = 1,
    CONTRACT_VALIDATE_ERROR = 2,
    CONTRACT_EXE_ERROR = 3,
    BANDWITH_ERROR = 4,
    DUP_TRANSACTION_ERROR = 5,
    TAPOS_ERROR = 6,
    TOO_BIG_TRANSACTION_ERROR = 7,
    TRANSACTION_EXPIRATION_ERROR = 8,
    SERVER_BUSY = 9,
    NO_CONNECTION = 10,
    NOT_ENOUGH_EFFECTIVE_CONNECTION = 11,
    OTHER_ERROR = 20,
}

impl ::protobuf::ProtobufEnum for Return_response_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Return_response_code> {
        match value {
            0 => ::std::option::Option::Some(Return_response_code::SUCCESS),
            1 => ::std::option::Option::Some(Return_response_code::SIGERROR),
            2 => ::std::option::Option::Some(Return_response_code::CONTRACT_VALIDATE_ERROR),
            3 => ::std::option::Option::Some(Return_response_code::CONTRACT_EXE_ERROR),
            4 => ::std::option::Option::Some(Return_response_code::BANDWITH_ERROR),
            5 => ::std::option::Option::Some(Return_response_code::DUP_TRANSACTION_ERROR),
            6 => ::std::option::Option::Some(Return_response_code::TAPOS_ERROR),
            7 => ::std::option::Option::Some(Return_response_code::TOO_BIG_TRANSACTION_ERROR),
            8 => ::std::option::Option::Some(Return_response_code::TRANSACTION_EXPIRATION_ERROR),
            9 => ::std::option::Option::Some(Return_response_code::SERVER_BUSY),
            10 => ::std::option::Option::Some(Return_response_code::NO_CONNECTION),
            11 => ::std::option::Option::Some(Return_response_code::NOT_ENOUGH_EFFECTIVE_CONNECTION),
            20 => ::std::option::Option::Some(Return_response_code::OTHER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Return_response_code] = &[
            Return_response_code::SUCCESS,
            Return_response_code::SIGERROR,
            Return_response_code::CONTRACT_VALIDATE_ERROR,
            Return_response_code::CONTRACT_EXE_ERROR,
            Return_response_code::BANDWITH_ERROR,
            Return_response_code::DUP_TRANSACTION_ERROR,
            Return_response_code::TAPOS_ERROR,
            Return_response_code::TOO_BIG_TRANSACTION_ERROR,
            Return_response_code::TRANSACTION_EXPIRATION_ERROR,
            Return_response_code::SERVER_BUSY,
            Return_response_code::NO_CONNECTION,
            Return_response_code::NOT_ENOUGH_EFFECTIVE_CONNECTION,
            Return_response_code::OTHER_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Return_response_code>("Return.response_code", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Return_response_code {
}

impl ::std::default::Default for Return_response_code {
    fn default() -> Self {
        Return_response_code::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for Return_response_code {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockReference {
    // message fields
    pub block_num: i64,
    pub block_hash: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockReference {
    fn default() -> &'a BlockReference {
        <BlockReference as ::protobuf::Message>::default_instance()
    }
}

impl BlockReference {
    pub fn new() -> BlockReference {
        ::std::default::Default::default()
    }

    // int64 block_num = 1;


    pub fn get_block_num(&self) -> i64 {
        self.block_num
    }
    pub fn clear_block_num(&mut self) {
        self.block_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_num(&mut self, v: i64) {
        self.block_num = v;
    }

    // bytes block_hash = 2;


    pub fn get_block_hash(&self) -> &[u8] {
        &self.block_hash
    }
    pub fn clear_block_hash(&mut self) {
        self.block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.block_hash
    }

    // Take field
    pub fn take_block_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.block_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.block_num = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.block_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.block_num != 0 {
            my_size += ::protobuf::rt::value_size(1, self.block_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.block_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.block_num != 0 {
            os.write_int64(1, self.block_num)?;
        }
        if !self.block_hash.is_empty() {
            os.write_bytes(2, &self.block_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockReference {
        BlockReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "block_num",
                |m: &BlockReference| { &m.block_num },
                |m: &mut BlockReference| { &mut m.block_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "block_hash",
                |m: &BlockReference| { &m.block_hash },
                |m: &mut BlockReference| { &mut m.block_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockReference>(
                "BlockReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockReference {
        static instance: ::protobuf::rt::LazyV2<BlockReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockReference::new)
    }
}

impl ::protobuf::Clear for BlockReference {
    fn clear(&mut self) {
        self.block_num = 0;
        self.block_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WitnessList {
    // message fields
    pub witnesses: ::protobuf::RepeatedField<super::Tron::Witness>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WitnessList {
    fn default() -> &'a WitnessList {
        <WitnessList as ::protobuf::Message>::default_instance()
    }
}

impl WitnessList {
    pub fn new() -> WitnessList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Witness witnesses = 1;


    pub fn get_witnesses(&self) -> &[super::Tron::Witness] {
        &self.witnesses
    }
    pub fn clear_witnesses(&mut self) {
        self.witnesses.clear();
    }

    // Param is passed by value, moved
    pub fn set_witnesses(&mut self, v: ::protobuf::RepeatedField<super::Tron::Witness>) {
        self.witnesses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_witnesses(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Witness> {
        &mut self.witnesses
    }

    // Take field
    pub fn take_witnesses(&mut self) -> ::protobuf::RepeatedField<super::Tron::Witness> {
        ::std::mem::replace(&mut self.witnesses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WitnessList {
    fn is_initialized(&self) -> bool {
        for v in &self.witnesses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.witnesses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.witnesses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.witnesses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WitnessList {
        WitnessList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Witness>>(
                "witnesses",
                |m: &WitnessList| { &m.witnesses },
                |m: &mut WitnessList| { &mut m.witnesses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WitnessList>(
                "WitnessList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WitnessList {
        static instance: ::protobuf::rt::LazyV2<WitnessList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WitnessList::new)
    }
}

impl ::protobuf::Clear for WitnessList {
    fn clear(&mut self) {
        self.witnesses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WitnessList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WitnessList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ProposalList {
    // message fields
    pub proposals: ::protobuf::RepeatedField<super::Tron::Proposal>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalList {
    fn default() -> &'a ProposalList {
        <ProposalList as ::protobuf::Message>::default_instance()
    }
}

impl ProposalList {
    pub fn new() -> ProposalList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Proposal proposals = 1;


    pub fn get_proposals(&self) -> &[super::Tron::Proposal] {
        &self.proposals
    }
    pub fn clear_proposals(&mut self) {
        self.proposals.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposals(&mut self, v: ::protobuf::RepeatedField<super::Tron::Proposal>) {
        self.proposals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_proposals(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Proposal> {
        &mut self.proposals
    }

    // Take field
    pub fn take_proposals(&mut self) -> ::protobuf::RepeatedField<super::Tron::Proposal> {
        ::std::mem::replace(&mut self.proposals, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProposalList {
    fn is_initialized(&self) -> bool {
        for v in &self.proposals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.proposals)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.proposals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.proposals {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalList {
        ProposalList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Proposal>>(
                "proposals",
                |m: &ProposalList| { &m.proposals },
                |m: &mut ProposalList| { &mut m.proposals },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProposalList>(
                "ProposalList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProposalList {
        static instance: ::protobuf::rt::LazyV2<ProposalList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProposalList::new)
    }
}

impl ::protobuf::Clear for ProposalList {
    fn clear(&mut self) {
        self.proposals.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExchangeList {
    // message fields
    pub exchanges: ::protobuf::RepeatedField<super::Tron::Exchange>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeList {
    fn default() -> &'a ExchangeList {
        <ExchangeList as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeList {
    pub fn new() -> ExchangeList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Exchange exchanges = 1;


    pub fn get_exchanges(&self) -> &[super::Tron::Exchange] {
        &self.exchanges
    }
    pub fn clear_exchanges(&mut self) {
        self.exchanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_exchanges(&mut self, v: ::protobuf::RepeatedField<super::Tron::Exchange>) {
        self.exchanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exchanges(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Exchange> {
        &mut self.exchanges
    }

    // Take field
    pub fn take_exchanges(&mut self) -> ::protobuf::RepeatedField<super::Tron::Exchange> {
        ::std::mem::replace(&mut self.exchanges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExchangeList {
    fn is_initialized(&self) -> bool {
        for v in &self.exchanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exchanges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.exchanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.exchanges {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeList {
        ExchangeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Exchange>>(
                "exchanges",
                |m: &ExchangeList| { &m.exchanges },
                |m: &mut ExchangeList| { &mut m.exchanges },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExchangeList>(
                "ExchangeList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExchangeList {
        static instance: ::protobuf::rt::LazyV2<ExchangeList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExchangeList::new)
    }
}

impl ::protobuf::Clear for ExchangeList {
    fn clear(&mut self) {
        self.exchanges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AssetIssueList {
    // message fields
    pub assetIssue: ::protobuf::RepeatedField<super::Contract::AssetIssueContract>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetIssueList {
    fn default() -> &'a AssetIssueList {
        <AssetIssueList as ::protobuf::Message>::default_instance()
    }
}

impl AssetIssueList {
    pub fn new() -> AssetIssueList {
        ::std::default::Default::default()
    }

    // repeated .protocol.AssetIssueContract assetIssue = 1;


    pub fn get_assetIssue(&self) -> &[super::Contract::AssetIssueContract] {
        &self.assetIssue
    }
    pub fn clear_assetIssue(&mut self) {
        self.assetIssue.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetIssue(&mut self, v: ::protobuf::RepeatedField<super::Contract::AssetIssueContract>) {
        self.assetIssue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetIssue(&mut self) -> &mut ::protobuf::RepeatedField<super::Contract::AssetIssueContract> {
        &mut self.assetIssue
    }

    // Take field
    pub fn take_assetIssue(&mut self) -> ::protobuf::RepeatedField<super::Contract::AssetIssueContract> {
        ::std::mem::replace(&mut self.assetIssue, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AssetIssueList {
    fn is_initialized(&self) -> bool {
        for v in &self.assetIssue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.assetIssue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.assetIssue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.assetIssue {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetIssueList {
        AssetIssueList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Contract::AssetIssueContract>>(
                "assetIssue",
                |m: &AssetIssueList| { &m.assetIssue },
                |m: &mut AssetIssueList| { &mut m.assetIssue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AssetIssueList>(
                "AssetIssueList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetIssueList {
        static instance: ::protobuf::rt::LazyV2<AssetIssueList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AssetIssueList::new)
    }
}

impl ::protobuf::Clear for AssetIssueList {
    fn clear(&mut self) {
        self.assetIssue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetIssueList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIssueList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockList {
    // message fields
    pub block: ::protobuf::RepeatedField<super::Tron::Block>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockList {
    fn default() -> &'a BlockList {
        <BlockList as ::protobuf::Message>::default_instance()
    }
}

impl BlockList {
    pub fn new() -> BlockList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Block block = 1;


    pub fn get_block(&self) -> &[super::Tron::Block] {
        &self.block
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::protobuf::RepeatedField<super::Tron::Block>) {
        self.block = v;
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Block> {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::protobuf::RepeatedField<super::Tron::Block> {
        ::std::mem::replace(&mut self.block, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockList {
    fn is_initialized(&self) -> bool {
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.block {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.block {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockList {
        BlockList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Block>>(
                "block",
                |m: &BlockList| { &m.block },
                |m: &mut BlockList| { &mut m.block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockList>(
                "BlockList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockList {
        static instance: ::protobuf::rt::LazyV2<BlockList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockList::new)
    }
}

impl ::protobuf::Clear for BlockList {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionList {
    // message fields
    pub transaction: ::protobuf::RepeatedField<super::Tron::Transaction>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionList {
    fn default() -> &'a TransactionList {
        <TransactionList as ::protobuf::Message>::default_instance()
    }
}

impl TransactionList {
    pub fn new() -> TransactionList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Transaction transaction = 1;


    pub fn get_transaction(&self) -> &[super::Tron::Transaction] {
        &self.transaction
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::protobuf::RepeatedField<super::Tron::Transaction>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Transaction> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::protobuf::RepeatedField<super::Tron::Transaction> {
        ::std::mem::replace(&mut self.transaction, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionList {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transaction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transaction {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionList {
        TransactionList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Transaction>>(
                "transaction",
                |m: &TransactionList| { &m.transaction },
                |m: &mut TransactionList| { &mut m.transaction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionList>(
                "TransactionList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionList {
        static instance: ::protobuf::rt::LazyV2<TransactionList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionList::new)
    }
}

impl ::protobuf::Clear for TransactionList {
    fn clear(&mut self) {
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DelegatedResourceMessage {
    // message fields
    pub fromAddress: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegatedResourceMessage {
    fn default() -> &'a DelegatedResourceMessage {
        <DelegatedResourceMessage as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResourceMessage {
    pub fn new() -> DelegatedResourceMessage {
        ::std::default::Default::default()
    }

    // bytes fromAddress = 1;


    pub fn get_fromAddress(&self) -> &[u8] {
        &self.fromAddress
    }
    pub fn clear_fromAddress(&mut self) {
        self.fromAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_fromAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.fromAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.fromAddress
    }

    // Take field
    pub fn take_fromAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.fromAddress, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DelegatedResourceMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.fromAddress)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.fromAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.fromAddress);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.fromAddress.is_empty() {
            os.write_bytes(1, &self.fromAddress)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegatedResourceMessage {
        DelegatedResourceMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "fromAddress",
                |m: &DelegatedResourceMessage| { &m.fromAddress },
                |m: &mut DelegatedResourceMessage| { &mut m.fromAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "toAddress",
                |m: &DelegatedResourceMessage| { &m.toAddress },
                |m: &mut DelegatedResourceMessage| { &mut m.toAddress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DelegatedResourceMessage>(
                "DelegatedResourceMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DelegatedResourceMessage {
        static instance: ::protobuf::rt::LazyV2<DelegatedResourceMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DelegatedResourceMessage::new)
    }
}

impl ::protobuf::Clear for DelegatedResourceMessage {
    fn clear(&mut self) {
        self.fromAddress.clear();
        self.toAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegatedResourceMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResourceMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DelegatedResourceList {
    // message fields
    pub delegatedResource: ::protobuf::RepeatedField<super::Tron::DelegatedResource>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegatedResourceList {
    fn default() -> &'a DelegatedResourceList {
        <DelegatedResourceList as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResourceList {
    pub fn new() -> DelegatedResourceList {
        ::std::default::Default::default()
    }

    // repeated .protocol.DelegatedResource delegatedResource = 1;


    pub fn get_delegatedResource(&self) -> &[super::Tron::DelegatedResource] {
        &self.delegatedResource
    }
    pub fn clear_delegatedResource(&mut self) {
        self.delegatedResource.clear();
    }

    // Param is passed by value, moved
    pub fn set_delegatedResource(&mut self, v: ::protobuf::RepeatedField<super::Tron::DelegatedResource>) {
        self.delegatedResource = v;
    }

    // Mutable pointer to the field.
    pub fn mut_delegatedResource(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::DelegatedResource> {
        &mut self.delegatedResource
    }

    // Take field
    pub fn take_delegatedResource(&mut self) -> ::protobuf::RepeatedField<super::Tron::DelegatedResource> {
        ::std::mem::replace(&mut self.delegatedResource, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DelegatedResourceList {
    fn is_initialized(&self) -> bool {
        for v in &self.delegatedResource {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.delegatedResource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.delegatedResource {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.delegatedResource {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegatedResourceList {
        DelegatedResourceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::DelegatedResource>>(
                "delegatedResource",
                |m: &DelegatedResourceList| { &m.delegatedResource },
                |m: &mut DelegatedResourceList| { &mut m.delegatedResource },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DelegatedResourceList>(
                "DelegatedResourceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DelegatedResourceList {
        static instance: ::protobuf::rt::LazyV2<DelegatedResourceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DelegatedResourceList::new)
    }
}

impl ::protobuf::Clear for DelegatedResourceList {
    fn clear(&mut self) {
        self.delegatedResource.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegatedResourceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResourceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NodeList {
    // message fields
    pub nodes: ::protobuf::RepeatedField<Node>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeList {
    fn default() -> &'a NodeList {
        <NodeList as ::protobuf::Message>::default_instance()
    }
}

impl NodeList {
    pub fn new() -> NodeList {
        ::std::default::Default::default()
    }

    // repeated .protocol.Node nodes = 1;


    pub fn get_nodes(&self) -> &[Node] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<Node> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeList {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeList {
        NodeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Node>>(
                "nodes",
                |m: &NodeList| { &m.nodes },
                |m: &mut NodeList| { &mut m.nodes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeList>(
                "NodeList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeList {
        static instance: ::protobuf::rt::LazyV2<NodeList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeList::new)
    }
}

impl ::protobuf::Clear for NodeList {
    fn clear(&mut self) {
        self.nodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Node {
    // message fields
    pub address: ::protobuf::SingularPtrField<Address>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // .protocol.Address address = 1;


    pub fn get_address(&self) -> &Address {
        self.address.as_ref().unwrap_or_else(|| <Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Address>>(
                "address",
                |m: &Node| { &m.address },
                |m: &mut Node| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Node>(
                "Node",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Node {
        static instance: ::protobuf::rt::LazyV2<Node> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Node::new)
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Address {
    // message fields
    pub host: ::std::vec::Vec<u8>,
    pub port: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Address {
    fn default() -> &'a Address {
        <Address as ::protobuf::Message>::default_instance()
    }
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // bytes host = 1;


    pub fn get_host(&self) -> &[u8] {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::vec::Vec<u8>) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.host, ::std::vec::Vec::new())
    }

    // int32 port = 2;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_bytes(1, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(2, self.port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "host",
                |m: &Address| { &m.host },
                |m: &mut Address| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &Address| { &m.port },
                |m: &mut Address| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Address>(
                "Address",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Address {
        static instance: ::protobuf::rt::LazyV2<Address> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Address::new)
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.host.clear();
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EmptyMessage {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmptyMessage {
    fn default() -> &'a EmptyMessage {
        <EmptyMessage as ::protobuf::Message>::default_instance()
    }
}

impl EmptyMessage {
    pub fn new() -> EmptyMessage {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EmptyMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmptyMessage {
        EmptyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmptyMessage>(
                "EmptyMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EmptyMessage {
        static instance: ::protobuf::rt::LazyV2<EmptyMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmptyMessage::new)
    }
}

impl ::protobuf::Clear for EmptyMessage {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmptyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NumberMessage {
    // message fields
    pub num: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NumberMessage {
    fn default() -> &'a NumberMessage {
        <NumberMessage as ::protobuf::Message>::default_instance()
    }
}

impl NumberMessage {
    pub fn new() -> NumberMessage {
        ::std::default::Default::default()
    }

    // int64 num = 1;


    pub fn get_num(&self) -> i64 {
        self.num
    }
    pub fn clear_num(&mut self) {
        self.num = 0;
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: i64) {
        self.num = v;
    }
}

impl ::protobuf::Message for NumberMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num != 0 {
            os.write_int64(1, self.num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NumberMessage {
        NumberMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num",
                |m: &NumberMessage| { &m.num },
                |m: &mut NumberMessage| { &mut m.num },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NumberMessage>(
                "NumberMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NumberMessage {
        static instance: ::protobuf::rt::LazyV2<NumberMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NumberMessage::new)
    }
}

impl ::protobuf::Clear for NumberMessage {
    fn clear(&mut self) {
        self.num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NumberMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BytesMessage {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BytesMessage {
    fn default() -> &'a BytesMessage {
        <BytesMessage as ::protobuf::Message>::default_instance()
    }
}

impl BytesMessage {
    pub fn new() -> BytesMessage {
        ::std::default::Default::default()
    }

    // bytes value = 1;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BytesMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BytesMessage {
        BytesMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value",
                |m: &BytesMessage| { &m.value },
                |m: &mut BytesMessage| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BytesMessage>(
                "BytesMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BytesMessage {
        static instance: ::protobuf::rt::LazyV2<BytesMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BytesMessage::new)
    }
}

impl ::protobuf::Clear for BytesMessage {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BytesMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BytesMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TimeMessage {
    // message fields
    pub beginInMilliseconds: i64,
    pub endInMilliseconds: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeMessage {
    fn default() -> &'a TimeMessage {
        <TimeMessage as ::protobuf::Message>::default_instance()
    }
}

impl TimeMessage {
    pub fn new() -> TimeMessage {
        ::std::default::Default::default()
    }

    // int64 beginInMilliseconds = 1;


    pub fn get_beginInMilliseconds(&self) -> i64 {
        self.beginInMilliseconds
    }
    pub fn clear_beginInMilliseconds(&mut self) {
        self.beginInMilliseconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_beginInMilliseconds(&mut self, v: i64) {
        self.beginInMilliseconds = v;
    }

    // int64 endInMilliseconds = 2;


    pub fn get_endInMilliseconds(&self) -> i64 {
        self.endInMilliseconds
    }
    pub fn clear_endInMilliseconds(&mut self) {
        self.endInMilliseconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_endInMilliseconds(&mut self, v: i64) {
        self.endInMilliseconds = v;
    }
}

impl ::protobuf::Message for TimeMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.beginInMilliseconds = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endInMilliseconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.beginInMilliseconds != 0 {
            my_size += ::protobuf::rt::value_size(1, self.beginInMilliseconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endInMilliseconds != 0 {
            my_size += ::protobuf::rt::value_size(2, self.endInMilliseconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.beginInMilliseconds != 0 {
            os.write_int64(1, self.beginInMilliseconds)?;
        }
        if self.endInMilliseconds != 0 {
            os.write_int64(2, self.endInMilliseconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeMessage {
        TimeMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "beginInMilliseconds",
                |m: &TimeMessage| { &m.beginInMilliseconds },
                |m: &mut TimeMessage| { &mut m.beginInMilliseconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "endInMilliseconds",
                |m: &TimeMessage| { &m.endInMilliseconds },
                |m: &mut TimeMessage| { &mut m.endInMilliseconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeMessage>(
                "TimeMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeMessage {
        static instance: ::protobuf::rt::LazyV2<TimeMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeMessage::new)
    }
}

impl ::protobuf::Clear for TimeMessage {
    fn clear(&mut self) {
        self.beginInMilliseconds = 0;
        self.endInMilliseconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockLimit {
    // message fields
    pub startNum: i64,
    pub endNum: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockLimit {
    fn default() -> &'a BlockLimit {
        <BlockLimit as ::protobuf::Message>::default_instance()
    }
}

impl BlockLimit {
    pub fn new() -> BlockLimit {
        ::std::default::Default::default()
    }

    // int64 startNum = 1;


    pub fn get_startNum(&self) -> i64 {
        self.startNum
    }
    pub fn clear_startNum(&mut self) {
        self.startNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_startNum(&mut self, v: i64) {
        self.startNum = v;
    }

    // int64 endNum = 2;


    pub fn get_endNum(&self) -> i64 {
        self.endNum
    }
    pub fn clear_endNum(&mut self) {
        self.endNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_endNum(&mut self, v: i64) {
        self.endNum = v;
    }
}

impl ::protobuf::Message for BlockLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startNum = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.startNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.startNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.endNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.endNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.startNum != 0 {
            os.write_int64(1, self.startNum)?;
        }
        if self.endNum != 0 {
            os.write_int64(2, self.endNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockLimit {
        BlockLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startNum",
                |m: &BlockLimit| { &m.startNum },
                |m: &mut BlockLimit| { &mut m.startNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "endNum",
                |m: &BlockLimit| { &m.endNum },
                |m: &mut BlockLimit| { &mut m.endNum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockLimit>(
                "BlockLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockLimit {
        static instance: ::protobuf::rt::LazyV2<BlockLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockLimit::new)
    }
}

impl ::protobuf::Clear for BlockLimit {
    fn clear(&mut self) {
        self.startNum = 0;
        self.endNum = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionLimit {
    // message fields
    pub transactionId: ::std::vec::Vec<u8>,
    pub limitNum: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionLimit {
    fn default() -> &'a TransactionLimit {
        <TransactionLimit as ::protobuf::Message>::default_instance()
    }
}

impl TransactionLimit {
    pub fn new() -> TransactionLimit {
        ::std::default::Default::default()
    }

    // bytes transactionId = 1;


    pub fn get_transactionId(&self) -> &[u8] {
        &self.transactionId
    }
    pub fn clear_transactionId(&mut self) {
        self.transactionId.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactionId(&mut self, v: ::std::vec::Vec<u8>) {
        self.transactionId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transactionId(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transactionId
    }

    // Take field
    pub fn take_transactionId(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transactionId, ::std::vec::Vec::new())
    }

    // int64 limitNum = 2;


    pub fn get_limitNum(&self) -> i64 {
        self.limitNum
    }
    pub fn clear_limitNum(&mut self) {
        self.limitNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_limitNum(&mut self, v: i64) {
        self.limitNum = v;
    }
}

impl ::protobuf::Message for TransactionLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transactionId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limitNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transactionId.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transactionId);
        }
        if self.limitNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limitNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.transactionId.is_empty() {
            os.write_bytes(1, &self.transactionId)?;
        }
        if self.limitNum != 0 {
            os.write_int64(2, self.limitNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionLimit {
        TransactionLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transactionId",
                |m: &TransactionLimit| { &m.transactionId },
                |m: &mut TransactionLimit| { &mut m.transactionId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limitNum",
                |m: &TransactionLimit| { &m.limitNum },
                |m: &mut TransactionLimit| { &mut m.limitNum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionLimit>(
                "TransactionLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionLimit {
        static instance: ::protobuf::rt::LazyV2<TransactionLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionLimit::new)
    }
}

impl ::protobuf::Clear for TransactionLimit {
    fn clear(&mut self) {
        self.transactionId.clear();
        self.limitNum = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AccountPaginated {
    // message fields
    pub account: ::protobuf::SingularPtrField<super::Tron::Account>,
    pub offset: i64,
    pub limit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountPaginated {
    fn default() -> &'a AccountPaginated {
        <AccountPaginated as ::protobuf::Message>::default_instance()
    }
}

impl AccountPaginated {
    pub fn new() -> AccountPaginated {
        ::std::default::Default::default()
    }

    // .protocol.Account account = 1;


    pub fn get_account(&self) -> &super::Tron::Account {
        self.account.as_ref().unwrap_or_else(|| <super::Tron::Account as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: super::Tron::Account) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut super::Tron::Account {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> super::Tron::Account {
        self.account.take().unwrap_or_else(|| super::Tron::Account::new())
    }

    // int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 limit = 3;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for AccountPaginated {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int64(3, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountPaginated {
        AccountPaginated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Account>>(
                "account",
                |m: &AccountPaginated| { &m.account },
                |m: &mut AccountPaginated| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "offset",
                |m: &AccountPaginated| { &m.offset },
                |m: &mut AccountPaginated| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limit",
                |m: &AccountPaginated| { &m.limit },
                |m: &mut AccountPaginated| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccountPaginated>(
                "AccountPaginated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccountPaginated {
        static instance: ::protobuf::rt::LazyV2<AccountPaginated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountPaginated::new)
    }
}

impl ::protobuf::Clear for AccountPaginated {
    fn clear(&mut self) {
        self.account.clear();
        self.offset = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountPaginated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountPaginated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TimePaginatedMessage {
    // message fields
    pub timeMessage: ::protobuf::SingularPtrField<TimeMessage>,
    pub offset: i64,
    pub limit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimePaginatedMessage {
    fn default() -> &'a TimePaginatedMessage {
        <TimePaginatedMessage as ::protobuf::Message>::default_instance()
    }
}

impl TimePaginatedMessage {
    pub fn new() -> TimePaginatedMessage {
        ::std::default::Default::default()
    }

    // .protocol.TimeMessage timeMessage = 1;


    pub fn get_timeMessage(&self) -> &TimeMessage {
        self.timeMessage.as_ref().unwrap_or_else(|| <TimeMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timeMessage(&mut self) {
        self.timeMessage.clear();
    }

    pub fn has_timeMessage(&self) -> bool {
        self.timeMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeMessage(&mut self, v: TimeMessage) {
        self.timeMessage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeMessage(&mut self) -> &mut TimeMessage {
        if self.timeMessage.is_none() {
            self.timeMessage.set_default();
        }
        self.timeMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeMessage(&mut self) -> TimeMessage {
        self.timeMessage.take().unwrap_or_else(|| TimeMessage::new())
    }

    // int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 limit = 3;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for TimePaginatedMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.timeMessage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeMessage)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.timeMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.timeMessage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int64(3, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimePaginatedMessage {
        TimePaginatedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeMessage>>(
                "timeMessage",
                |m: &TimePaginatedMessage| { &m.timeMessage },
                |m: &mut TimePaginatedMessage| { &mut m.timeMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "offset",
                |m: &TimePaginatedMessage| { &m.offset },
                |m: &mut TimePaginatedMessage| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limit",
                |m: &TimePaginatedMessage| { &m.limit },
                |m: &mut TimePaginatedMessage| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimePaginatedMessage>(
                "TimePaginatedMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimePaginatedMessage {
        static instance: ::protobuf::rt::LazyV2<TimePaginatedMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimePaginatedMessage::new)
    }
}

impl ::protobuf::Clear for TimePaginatedMessage {
    fn clear(&mut self) {
        self.timeMessage.clear();
        self.offset = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimePaginatedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimePaginatedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AccountNetMessage {
    // message fields
    pub freeNetUsed: i64,
    pub freeNetLimit: i64,
    pub NetUsed: i64,
    pub NetLimit: i64,
    pub assetNetUsed: ::std::collections::HashMap<::std::string::String, i64>,
    pub assetNetLimit: ::std::collections::HashMap<::std::string::String, i64>,
    pub TotalNetLimit: i64,
    pub TotalNetWeight: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountNetMessage {
    fn default() -> &'a AccountNetMessage {
        <AccountNetMessage as ::protobuf::Message>::default_instance()
    }
}

impl AccountNetMessage {
    pub fn new() -> AccountNetMessage {
        ::std::default::Default::default()
    }

    // int64 freeNetUsed = 1;


    pub fn get_freeNetUsed(&self) -> i64 {
        self.freeNetUsed
    }
    pub fn clear_freeNetUsed(&mut self) {
        self.freeNetUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeNetUsed(&mut self, v: i64) {
        self.freeNetUsed = v;
    }

    // int64 freeNetLimit = 2;


    pub fn get_freeNetLimit(&self) -> i64 {
        self.freeNetLimit
    }
    pub fn clear_freeNetLimit(&mut self) {
        self.freeNetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeNetLimit(&mut self, v: i64) {
        self.freeNetLimit = v;
    }

    // int64 NetUsed = 3;


    pub fn get_NetUsed(&self) -> i64 {
        self.NetUsed
    }
    pub fn clear_NetUsed(&mut self) {
        self.NetUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_NetUsed(&mut self, v: i64) {
        self.NetUsed = v;
    }

    // int64 NetLimit = 4;


    pub fn get_NetLimit(&self) -> i64 {
        self.NetLimit
    }
    pub fn clear_NetLimit(&mut self) {
        self.NetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_NetLimit(&mut self, v: i64) {
        self.NetLimit = v;
    }

    // repeated .protocol.AccountNetMessage.AssetNetUsedEntry assetNetUsed = 5;


    pub fn get_assetNetUsed(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetNetUsed
    }
    pub fn clear_assetNetUsed(&mut self) {
        self.assetNetUsed.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetNetUsed(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetNetUsed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetNetUsed(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetNetUsed
    }

    // Take field
    pub fn take_assetNetUsed(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetNetUsed, ::std::collections::HashMap::new())
    }

    // repeated .protocol.AccountNetMessage.AssetNetLimitEntry assetNetLimit = 6;


    pub fn get_assetNetLimit(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetNetLimit
    }
    pub fn clear_assetNetLimit(&mut self) {
        self.assetNetLimit.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetNetLimit(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetNetLimit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetNetLimit(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetNetLimit
    }

    // Take field
    pub fn take_assetNetLimit(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetNetLimit, ::std::collections::HashMap::new())
    }

    // int64 TotalNetLimit = 7;


    pub fn get_TotalNetLimit(&self) -> i64 {
        self.TotalNetLimit
    }
    pub fn clear_TotalNetLimit(&mut self) {
        self.TotalNetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalNetLimit(&mut self, v: i64) {
        self.TotalNetLimit = v;
    }

    // int64 TotalNetWeight = 8;


    pub fn get_TotalNetWeight(&self) -> i64 {
        self.TotalNetWeight
    }
    pub fn clear_TotalNetWeight(&mut self) {
        self.TotalNetWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalNetWeight(&mut self, v: i64) {
        self.TotalNetWeight = v;
    }
}

impl ::protobuf::Message for AccountNetMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeNetUsed = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeNetLimit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NetUsed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NetLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetNetUsed)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetNetLimit)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalNetLimit = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalNetWeight = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.freeNetUsed != 0 {
            my_size += ::protobuf::rt::value_size(1, self.freeNetUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.freeNetLimit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.freeNetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.NetUsed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.NetUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.NetLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.NetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(5, &self.assetNetUsed);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.assetNetLimit);
        if self.TotalNetLimit != 0 {
            my_size += ::protobuf::rt::value_size(7, self.TotalNetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalNetWeight != 0 {
            my_size += ::protobuf::rt::value_size(8, self.TotalNetWeight, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.freeNetUsed != 0 {
            os.write_int64(1, self.freeNetUsed)?;
        }
        if self.freeNetLimit != 0 {
            os.write_int64(2, self.freeNetLimit)?;
        }
        if self.NetUsed != 0 {
            os.write_int64(3, self.NetUsed)?;
        }
        if self.NetLimit != 0 {
            os.write_int64(4, self.NetLimit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(5, &self.assetNetUsed, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.assetNetLimit, os)?;
        if self.TotalNetLimit != 0 {
            os.write_int64(7, self.TotalNetLimit)?;
        }
        if self.TotalNetWeight != 0 {
            os.write_int64(8, self.TotalNetWeight)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountNetMessage {
        AccountNetMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "freeNetUsed",
                |m: &AccountNetMessage| { &m.freeNetUsed },
                |m: &mut AccountNetMessage| { &mut m.freeNetUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "freeNetLimit",
                |m: &AccountNetMessage| { &m.freeNetLimit },
                |m: &mut AccountNetMessage| { &mut m.freeNetLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "NetUsed",
                |m: &AccountNetMessage| { &m.NetUsed },
                |m: &mut AccountNetMessage| { &mut m.NetUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "NetLimit",
                |m: &AccountNetMessage| { &m.NetLimit },
                |m: &mut AccountNetMessage| { &mut m.NetLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "assetNetUsed",
                |m: &AccountNetMessage| { &m.assetNetUsed },
                |m: &mut AccountNetMessage| { &mut m.assetNetUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "assetNetLimit",
                |m: &AccountNetMessage| { &m.assetNetLimit },
                |m: &mut AccountNetMessage| { &mut m.assetNetLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TotalNetLimit",
                |m: &AccountNetMessage| { &m.TotalNetLimit },
                |m: &mut AccountNetMessage| { &mut m.TotalNetLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TotalNetWeight",
                |m: &AccountNetMessage| { &m.TotalNetWeight },
                |m: &mut AccountNetMessage| { &mut m.TotalNetWeight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccountNetMessage>(
                "AccountNetMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccountNetMessage {
        static instance: ::protobuf::rt::LazyV2<AccountNetMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountNetMessage::new)
    }
}

impl ::protobuf::Clear for AccountNetMessage {
    fn clear(&mut self) {
        self.freeNetUsed = 0;
        self.freeNetLimit = 0;
        self.NetUsed = 0;
        self.NetLimit = 0;
        self.assetNetUsed.clear();
        self.assetNetLimit.clear();
        self.TotalNetLimit = 0;
        self.TotalNetWeight = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountNetMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountNetMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AccountResourceMessage {
    // message fields
    pub freeNetUsed: i64,
    pub freeNetLimit: i64,
    pub NetUsed: i64,
    pub NetLimit: i64,
    pub assetNetUsed: ::std::collections::HashMap<::std::string::String, i64>,
    pub assetNetLimit: ::std::collections::HashMap<::std::string::String, i64>,
    pub TotalNetLimit: i64,
    pub TotalNetWeight: i64,
    pub EnergyUsed: i64,
    pub EnergyLimit: i64,
    pub TotalEnergyLimit: i64,
    pub TotalEnergyWeight: i64,
    pub storageUsed: i64,
    pub storageLimit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountResourceMessage {
    fn default() -> &'a AccountResourceMessage {
        <AccountResourceMessage as ::protobuf::Message>::default_instance()
    }
}

impl AccountResourceMessage {
    pub fn new() -> AccountResourceMessage {
        ::std::default::Default::default()
    }

    // int64 freeNetUsed = 1;


    pub fn get_freeNetUsed(&self) -> i64 {
        self.freeNetUsed
    }
    pub fn clear_freeNetUsed(&mut self) {
        self.freeNetUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeNetUsed(&mut self, v: i64) {
        self.freeNetUsed = v;
    }

    // int64 freeNetLimit = 2;


    pub fn get_freeNetLimit(&self) -> i64 {
        self.freeNetLimit
    }
    pub fn clear_freeNetLimit(&mut self) {
        self.freeNetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeNetLimit(&mut self, v: i64) {
        self.freeNetLimit = v;
    }

    // int64 NetUsed = 3;


    pub fn get_NetUsed(&self) -> i64 {
        self.NetUsed
    }
    pub fn clear_NetUsed(&mut self) {
        self.NetUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_NetUsed(&mut self, v: i64) {
        self.NetUsed = v;
    }

    // int64 NetLimit = 4;


    pub fn get_NetLimit(&self) -> i64 {
        self.NetLimit
    }
    pub fn clear_NetLimit(&mut self) {
        self.NetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_NetLimit(&mut self, v: i64) {
        self.NetLimit = v;
    }

    // repeated .protocol.AccountResourceMessage.AssetNetUsedEntry assetNetUsed = 5;


    pub fn get_assetNetUsed(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetNetUsed
    }
    pub fn clear_assetNetUsed(&mut self) {
        self.assetNetUsed.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetNetUsed(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetNetUsed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetNetUsed(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetNetUsed
    }

    // Take field
    pub fn take_assetNetUsed(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetNetUsed, ::std::collections::HashMap::new())
    }

    // repeated .protocol.AccountResourceMessage.AssetNetLimitEntry assetNetLimit = 6;


    pub fn get_assetNetLimit(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetNetLimit
    }
    pub fn clear_assetNetLimit(&mut self) {
        self.assetNetLimit.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetNetLimit(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetNetLimit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetNetLimit(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetNetLimit
    }

    // Take field
    pub fn take_assetNetLimit(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetNetLimit, ::std::collections::HashMap::new())
    }

    // int64 TotalNetLimit = 7;


    pub fn get_TotalNetLimit(&self) -> i64 {
        self.TotalNetLimit
    }
    pub fn clear_TotalNetLimit(&mut self) {
        self.TotalNetLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalNetLimit(&mut self, v: i64) {
        self.TotalNetLimit = v;
    }

    // int64 TotalNetWeight = 8;


    pub fn get_TotalNetWeight(&self) -> i64 {
        self.TotalNetWeight
    }
    pub fn clear_TotalNetWeight(&mut self) {
        self.TotalNetWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalNetWeight(&mut self, v: i64) {
        self.TotalNetWeight = v;
    }

    // int64 EnergyUsed = 13;


    pub fn get_EnergyUsed(&self) -> i64 {
        self.EnergyUsed
    }
    pub fn clear_EnergyUsed(&mut self) {
        self.EnergyUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_EnergyUsed(&mut self, v: i64) {
        self.EnergyUsed = v;
    }

    // int64 EnergyLimit = 14;


    pub fn get_EnergyLimit(&self) -> i64 {
        self.EnergyLimit
    }
    pub fn clear_EnergyLimit(&mut self) {
        self.EnergyLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_EnergyLimit(&mut self, v: i64) {
        self.EnergyLimit = v;
    }

    // int64 TotalEnergyLimit = 15;


    pub fn get_TotalEnergyLimit(&self) -> i64 {
        self.TotalEnergyLimit
    }
    pub fn clear_TotalEnergyLimit(&mut self) {
        self.TotalEnergyLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalEnergyLimit(&mut self, v: i64) {
        self.TotalEnergyLimit = v;
    }

    // int64 TotalEnergyWeight = 16;


    pub fn get_TotalEnergyWeight(&self) -> i64 {
        self.TotalEnergyWeight
    }
    pub fn clear_TotalEnergyWeight(&mut self) {
        self.TotalEnergyWeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_TotalEnergyWeight(&mut self, v: i64) {
        self.TotalEnergyWeight = v;
    }

    // int64 storageUsed = 21;


    pub fn get_storageUsed(&self) -> i64 {
        self.storageUsed
    }
    pub fn clear_storageUsed(&mut self) {
        self.storageUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_storageUsed(&mut self, v: i64) {
        self.storageUsed = v;
    }

    // int64 storageLimit = 22;


    pub fn get_storageLimit(&self) -> i64 {
        self.storageLimit
    }
    pub fn clear_storageLimit(&mut self) {
        self.storageLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_storageLimit(&mut self, v: i64) {
        self.storageLimit = v;
    }
}

impl ::protobuf::Message for AccountResourceMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeNetUsed = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeNetLimit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NetUsed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.NetLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetNetUsed)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetNetLimit)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalNetLimit = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalNetWeight = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.EnergyUsed = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.EnergyLimit = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalEnergyLimit = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.TotalEnergyWeight = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storageUsed = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storageLimit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.freeNetUsed != 0 {
            my_size += ::protobuf::rt::value_size(1, self.freeNetUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.freeNetLimit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.freeNetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.NetUsed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.NetUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.NetLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.NetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(5, &self.assetNetUsed);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.assetNetLimit);
        if self.TotalNetLimit != 0 {
            my_size += ::protobuf::rt::value_size(7, self.TotalNetLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalNetWeight != 0 {
            my_size += ::protobuf::rt::value_size(8, self.TotalNetWeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EnergyUsed != 0 {
            my_size += ::protobuf::rt::value_size(13, self.EnergyUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.EnergyLimit != 0 {
            my_size += ::protobuf::rt::value_size(14, self.EnergyLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalEnergyLimit != 0 {
            my_size += ::protobuf::rt::value_size(15, self.TotalEnergyLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalEnergyWeight != 0 {
            my_size += ::protobuf::rt::value_size(16, self.TotalEnergyWeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storageUsed != 0 {
            my_size += ::protobuf::rt::value_size(21, self.storageUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storageLimit != 0 {
            my_size += ::protobuf::rt::value_size(22, self.storageLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.freeNetUsed != 0 {
            os.write_int64(1, self.freeNetUsed)?;
        }
        if self.freeNetLimit != 0 {
            os.write_int64(2, self.freeNetLimit)?;
        }
        if self.NetUsed != 0 {
            os.write_int64(3, self.NetUsed)?;
        }
        if self.NetLimit != 0 {
            os.write_int64(4, self.NetLimit)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(5, &self.assetNetUsed, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.assetNetLimit, os)?;
        if self.TotalNetLimit != 0 {
            os.write_int64(7, self.TotalNetLimit)?;
        }
        if self.TotalNetWeight != 0 {
            os.write_int64(8, self.TotalNetWeight)?;
        }
        if self.EnergyUsed != 0 {
            os.write_int64(13, self.EnergyUsed)?;
        }
        if self.EnergyLimit != 0 {
            os.write_int64(14, self.EnergyLimit)?;
        }
        if self.TotalEnergyLimit != 0 {
            os.write_int64(15, self.TotalEnergyLimit)?;
        }
        if self.TotalEnergyWeight != 0 {
            os.write_int64(16, self.TotalEnergyWeight)?;
        }
        if self.storageUsed != 0 {
            os.write_int64(21, self.storageUsed)?;
        }
        if self.storageLimit != 0 {
            os.write_int64(22, self.storageLimit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountResourceMessage {
        AccountResourceMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "freeNetUsed",
                |m: &AccountResourceMessage| { &m.freeNetUsed },
                |m: &mut AccountResourceMessage| { &mut m.freeNetUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "freeNetLimit",
                |m: &AccountResourceMessage| { &m.freeNetLimit },
                |m: &mut AccountResourceMessage| { &mut m.freeNetLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "NetUsed",
                |m: &AccountResourceMessage| { &m.NetUsed },
                |m: &mut AccountResourceMessage| { &mut m.NetUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "NetLimit",
                |m: &AccountResourceMessage| { &m.NetLimit },
                |m: &mut AccountResourceMessage| { &mut m.NetLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "assetNetUsed",
                |m: &AccountResourceMessage| { &m.assetNetUsed },
                |m: &mut AccountResourceMessage| { &mut m.assetNetUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "assetNetLimit",
                |m: &AccountResourceMessage| { &m.assetNetLimit },
                |m: &mut AccountResourceMessage| { &mut m.assetNetLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TotalNetLimit",
                |m: &AccountResourceMessage| { &m.TotalNetLimit },
                |m: &mut AccountResourceMessage| { &mut m.TotalNetLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TotalNetWeight",
                |m: &AccountResourceMessage| { &m.TotalNetWeight },
                |m: &mut AccountResourceMessage| { &mut m.TotalNetWeight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "EnergyUsed",
                |m: &AccountResourceMessage| { &m.EnergyUsed },
                |m: &mut AccountResourceMessage| { &mut m.EnergyUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "EnergyLimit",
                |m: &AccountResourceMessage| { &m.EnergyLimit },
                |m: &mut AccountResourceMessage| { &mut m.EnergyLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TotalEnergyLimit",
                |m: &AccountResourceMessage| { &m.TotalEnergyLimit },
                |m: &mut AccountResourceMessage| { &mut m.TotalEnergyLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "TotalEnergyWeight",
                |m: &AccountResourceMessage| { &m.TotalEnergyWeight },
                |m: &mut AccountResourceMessage| { &mut m.TotalEnergyWeight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "storageUsed",
                |m: &AccountResourceMessage| { &m.storageUsed },
                |m: &mut AccountResourceMessage| { &mut m.storageUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "storageLimit",
                |m: &AccountResourceMessage| { &m.storageLimit },
                |m: &mut AccountResourceMessage| { &mut m.storageLimit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccountResourceMessage>(
                "AccountResourceMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccountResourceMessage {
        static instance: ::protobuf::rt::LazyV2<AccountResourceMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountResourceMessage::new)
    }
}

impl ::protobuf::Clear for AccountResourceMessage {
    fn clear(&mut self) {
        self.freeNetUsed = 0;
        self.freeNetLimit = 0;
        self.NetUsed = 0;
        self.NetLimit = 0;
        self.assetNetUsed.clear();
        self.assetNetLimit.clear();
        self.TotalNetLimit = 0;
        self.TotalNetWeight = 0;
        self.EnergyUsed = 0;
        self.EnergyLimit = 0;
        self.TotalEnergyLimit = 0;
        self.TotalEnergyWeight = 0;
        self.storageUsed = 0;
        self.storageLimit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountResourceMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountResourceMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PaginatedMessage {
    // message fields
    pub offset: i64,
    pub limit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaginatedMessage {
    fn default() -> &'a PaginatedMessage {
        <PaginatedMessage as ::protobuf::Message>::default_instance()
    }
}

impl PaginatedMessage {
    pub fn new() -> PaginatedMessage {
        ::std::default::Default::default()
    }

    // int64 offset = 1;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 limit = 2;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for PaginatedMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(1, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.offset != 0 {
            os.write_int64(1, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int64(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaginatedMessage {
        PaginatedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "offset",
                |m: &PaginatedMessage| { &m.offset },
                |m: &mut PaginatedMessage| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limit",
                |m: &PaginatedMessage| { &m.limit },
                |m: &mut PaginatedMessage| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaginatedMessage>(
                "PaginatedMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaginatedMessage {
        static instance: ::protobuf::rt::LazyV2<PaginatedMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaginatedMessage::new)
    }
}

impl ::protobuf::Clear for PaginatedMessage {
    fn clear(&mut self) {
        self.offset = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaginatedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaginatedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EasyTransferMessage {
    // message fields
    pub passPhrase: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferMessage {
    fn default() -> &'a EasyTransferMessage {
        <EasyTransferMessage as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferMessage {
    pub fn new() -> EasyTransferMessage {
        ::std::default::Default::default()
    }

    // bytes passPhrase = 1;


    pub fn get_passPhrase(&self) -> &[u8] {
        &self.passPhrase
    }
    pub fn clear_passPhrase(&mut self) {
        self.passPhrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_passPhrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.passPhrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passPhrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.passPhrase
    }

    // Take field
    pub fn take_passPhrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.passPhrase, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }

    // int64 amount = 3;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for EasyTransferMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.passPhrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.passPhrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.passPhrase);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.passPhrase.is_empty() {
            os.write_bytes(1, &self.passPhrase)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        if self.amount != 0 {
            os.write_int64(3, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferMessage {
        EasyTransferMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "passPhrase",
                |m: &EasyTransferMessage| { &m.passPhrase },
                |m: &mut EasyTransferMessage| { &mut m.passPhrase },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "toAddress",
                |m: &EasyTransferMessage| { &m.toAddress },
                |m: &mut EasyTransferMessage| { &mut m.toAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &EasyTransferMessage| { &m.amount },
                |m: &mut EasyTransferMessage| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EasyTransferMessage>(
                "EasyTransferMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EasyTransferMessage {
        static instance: ::protobuf::rt::LazyV2<EasyTransferMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EasyTransferMessage::new)
    }
}

impl ::protobuf::Clear for EasyTransferMessage {
    fn clear(&mut self) {
        self.passPhrase.clear();
        self.toAddress.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EasyTransferAssetMessage {
    // message fields
    pub passPhrase: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    pub assetId: ::std::string::String,
    pub amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferAssetMessage {
    fn default() -> &'a EasyTransferAssetMessage {
        <EasyTransferAssetMessage as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferAssetMessage {
    pub fn new() -> EasyTransferAssetMessage {
        ::std::default::Default::default()
    }

    // bytes passPhrase = 1;


    pub fn get_passPhrase(&self) -> &[u8] {
        &self.passPhrase
    }
    pub fn clear_passPhrase(&mut self) {
        self.passPhrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_passPhrase(&mut self, v: ::std::vec::Vec<u8>) {
        self.passPhrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passPhrase(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.passPhrase
    }

    // Take field
    pub fn take_passPhrase(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.passPhrase, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }

    // string assetId = 3;


    pub fn get_assetId(&self) -> &str {
        &self.assetId
    }
    pub fn clear_assetId(&mut self) {
        self.assetId.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetId(&mut self, v: ::std::string::String) {
        self.assetId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assetId(&mut self) -> &mut ::std::string::String {
        &mut self.assetId
    }

    // Take field
    pub fn take_assetId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.assetId, ::std::string::String::new())
    }

    // int64 amount = 4;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for EasyTransferAssetMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.passPhrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.assetId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.passPhrase.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.passPhrase);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        if !self.assetId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.assetId);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.passPhrase.is_empty() {
            os.write_bytes(1, &self.passPhrase)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        if !self.assetId.is_empty() {
            os.write_string(3, &self.assetId)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferAssetMessage {
        EasyTransferAssetMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "passPhrase",
                |m: &EasyTransferAssetMessage| { &m.passPhrase },
                |m: &mut EasyTransferAssetMessage| { &mut m.passPhrase },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "toAddress",
                |m: &EasyTransferAssetMessage| { &m.toAddress },
                |m: &mut EasyTransferAssetMessage| { &mut m.toAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &EasyTransferAssetMessage| { &m.assetId },
                |m: &mut EasyTransferAssetMessage| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &EasyTransferAssetMessage| { &m.amount },
                |m: &mut EasyTransferAssetMessage| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EasyTransferAssetMessage>(
                "EasyTransferAssetMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EasyTransferAssetMessage {
        static instance: ::protobuf::rt::LazyV2<EasyTransferAssetMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EasyTransferAssetMessage::new)
    }
}

impl ::protobuf::Clear for EasyTransferAssetMessage {
    fn clear(&mut self) {
        self.passPhrase.clear();
        self.toAddress.clear();
        self.assetId.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferAssetMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferAssetMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EasyTransferByPrivateMessage {
    // message fields
    pub privateKey: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferByPrivateMessage {
    fn default() -> &'a EasyTransferByPrivateMessage {
        <EasyTransferByPrivateMessage as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferByPrivateMessage {
    pub fn new() -> EasyTransferByPrivateMessage {
        ::std::default::Default::default()
    }

    // bytes privateKey = 1;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }

    // int64 amount = 3;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for EasyTransferByPrivateMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.privateKey);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.privateKey.is_empty() {
            os.write_bytes(1, &self.privateKey)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        if self.amount != 0 {
            os.write_int64(3, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferByPrivateMessage {
        EasyTransferByPrivateMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "privateKey",
                |m: &EasyTransferByPrivateMessage| { &m.privateKey },
                |m: &mut EasyTransferByPrivateMessage| { &mut m.privateKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "toAddress",
                |m: &EasyTransferByPrivateMessage| { &m.toAddress },
                |m: &mut EasyTransferByPrivateMessage| { &mut m.toAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &EasyTransferByPrivateMessage| { &m.amount },
                |m: &mut EasyTransferByPrivateMessage| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EasyTransferByPrivateMessage>(
                "EasyTransferByPrivateMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EasyTransferByPrivateMessage {
        static instance: ::protobuf::rt::LazyV2<EasyTransferByPrivateMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EasyTransferByPrivateMessage::new)
    }
}

impl ::protobuf::Clear for EasyTransferByPrivateMessage {
    fn clear(&mut self) {
        self.privateKey.clear();
        self.toAddress.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferByPrivateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferByPrivateMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EasyTransferAssetByPrivateMessage {
    // message fields
    pub privateKey: ::std::vec::Vec<u8>,
    pub toAddress: ::std::vec::Vec<u8>,
    pub assetId: ::std::string::String,
    pub amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferAssetByPrivateMessage {
    fn default() -> &'a EasyTransferAssetByPrivateMessage {
        <EasyTransferAssetByPrivateMessage as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferAssetByPrivateMessage {
    pub fn new() -> EasyTransferAssetByPrivateMessage {
        ::std::default::Default::default()
    }

    // bytes privateKey = 1;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }

    // bytes toAddress = 2;


    pub fn get_toAddress(&self) -> &[u8] {
        &self.toAddress
    }
    pub fn clear_toAddress(&mut self) {
        self.toAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddress
    }

    // Take field
    pub fn take_toAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddress, ::std::vec::Vec::new())
    }

    // string assetId = 3;


    pub fn get_assetId(&self) -> &str {
        &self.assetId
    }
    pub fn clear_assetId(&mut self) {
        self.assetId.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetId(&mut self, v: ::std::string::String) {
        self.assetId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assetId(&mut self) -> &mut ::std::string::String {
        &mut self.assetId
    }

    // Take field
    pub fn take_assetId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.assetId, ::std::string::String::new())
    }

    // int64 amount = 4;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for EasyTransferAssetByPrivateMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.assetId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.privateKey);
        }
        if !self.toAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddress);
        }
        if !self.assetId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.assetId);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.privateKey.is_empty() {
            os.write_bytes(1, &self.privateKey)?;
        }
        if !self.toAddress.is_empty() {
            os.write_bytes(2, &self.toAddress)?;
        }
        if !self.assetId.is_empty() {
            os.write_string(3, &self.assetId)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferAssetByPrivateMessage {
        EasyTransferAssetByPrivateMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "privateKey",
                |m: &EasyTransferAssetByPrivateMessage| { &m.privateKey },
                |m: &mut EasyTransferAssetByPrivateMessage| { &mut m.privateKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "toAddress",
                |m: &EasyTransferAssetByPrivateMessage| { &m.toAddress },
                |m: &mut EasyTransferAssetByPrivateMessage| { &mut m.toAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetId",
                |m: &EasyTransferAssetByPrivateMessage| { &m.assetId },
                |m: &mut EasyTransferAssetByPrivateMessage| { &mut m.assetId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &EasyTransferAssetByPrivateMessage| { &m.amount },
                |m: &mut EasyTransferAssetByPrivateMessage| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EasyTransferAssetByPrivateMessage>(
                "EasyTransferAssetByPrivateMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EasyTransferAssetByPrivateMessage {
        static instance: ::protobuf::rt::LazyV2<EasyTransferAssetByPrivateMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EasyTransferAssetByPrivateMessage::new)
    }
}

impl ::protobuf::Clear for EasyTransferAssetByPrivateMessage {
    fn clear(&mut self) {
        self.privateKey.clear();
        self.toAddress.clear();
        self.assetId.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferAssetByPrivateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferAssetByPrivateMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct EasyTransferResponse {
    // message fields
    pub transaction: ::protobuf::SingularPtrField<super::Tron::Transaction>,
    pub result: ::protobuf::SingularPtrField<Return>,
    pub txid: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EasyTransferResponse {
    fn default() -> &'a EasyTransferResponse {
        <EasyTransferResponse as ::protobuf::Message>::default_instance()
    }
}

impl EasyTransferResponse {
    pub fn new() -> EasyTransferResponse {
        ::std::default::Default::default()
    }

    // .protocol.Transaction transaction = 1;


    pub fn get_transaction(&self) -> &super::Tron::Transaction {
        self.transaction.as_ref().unwrap_or_else(|| <super::Tron::Transaction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: super::Tron::Transaction) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut super::Tron::Transaction {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> super::Tron::Transaction {
        self.transaction.take().unwrap_or_else(|| super::Tron::Transaction::new())
    }

    // .protocol.Return result = 2;


    pub fn get_result(&self) -> &Return {
        self.result.as_ref().unwrap_or_else(|| <Return as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Return) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Return {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Return {
        self.result.take().unwrap_or_else(|| Return::new())
    }

    // bytes txid = 3;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EasyTransferResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(3, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EasyTransferResponse {
        EasyTransferResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Transaction>>(
                "transaction",
                |m: &EasyTransferResponse| { &m.transaction },
                |m: &mut EasyTransferResponse| { &mut m.transaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Return>>(
                "result",
                |m: &EasyTransferResponse| { &m.result },
                |m: &mut EasyTransferResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txid",
                |m: &EasyTransferResponse| { &m.txid },
                |m: &mut EasyTransferResponse| { &mut m.txid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EasyTransferResponse>(
                "EasyTransferResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EasyTransferResponse {
        static instance: ::protobuf::rt::LazyV2<EasyTransferResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EasyTransferResponse::new)
    }
}

impl ::protobuf::Clear for EasyTransferResponse {
    fn clear(&mut self) {
        self.transaction.clear();
        self.result.clear();
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EasyTransferResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EasyTransferResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AddressPrKeyPairMessage {
    // message fields
    pub address: ::std::string::String,
    pub privateKey: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressPrKeyPairMessage {
    fn default() -> &'a AddressPrKeyPairMessage {
        <AddressPrKeyPairMessage as ::protobuf::Message>::default_instance()
    }
}

impl AddressPrKeyPairMessage {
    pub fn new() -> AddressPrKeyPairMessage {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string privateKey = 2;


    pub fn get_privateKey(&self) -> &str {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::string::String) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::string::String {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.privateKey, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddressPrKeyPairMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.privateKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.privateKey.is_empty() {
            os.write_string(2, &self.privateKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressPrKeyPairMessage {
        AddressPrKeyPairMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &AddressPrKeyPairMessage| { &m.address },
                |m: &mut AddressPrKeyPairMessage| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "privateKey",
                |m: &AddressPrKeyPairMessage| { &m.privateKey },
                |m: &mut AddressPrKeyPairMessage| { &mut m.privateKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressPrKeyPairMessage>(
                "AddressPrKeyPairMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressPrKeyPairMessage {
        static instance: ::protobuf::rt::LazyV2<AddressPrKeyPairMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressPrKeyPairMessage::new)
    }
}

impl ::protobuf::Clear for AddressPrKeyPairMessage {
    fn clear(&mut self) {
        self.address.clear();
        self.privateKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressPrKeyPairMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressPrKeyPairMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionExtention {
    // message fields
    pub transaction: ::protobuf::SingularPtrField<super::Tron::Transaction>,
    pub txid: ::std::vec::Vec<u8>,
    pub constant_result: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub result: ::protobuf::SingularPtrField<Return>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionExtention {
    fn default() -> &'a TransactionExtention {
        <TransactionExtention as ::protobuf::Message>::default_instance()
    }
}

impl TransactionExtention {
    pub fn new() -> TransactionExtention {
        ::std::default::Default::default()
    }

    // .protocol.Transaction transaction = 1;


    pub fn get_transaction(&self) -> &super::Tron::Transaction {
        self.transaction.as_ref().unwrap_or_else(|| <super::Tron::Transaction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: super::Tron::Transaction) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut super::Tron::Transaction {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> super::Tron::Transaction {
        self.transaction.take().unwrap_or_else(|| super::Tron::Transaction::new())
    }

    // bytes txid = 2;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // repeated bytes constant_result = 3;


    pub fn get_constant_result(&self) -> &[::std::vec::Vec<u8>] {
        &self.constant_result
    }
    pub fn clear_constant_result(&mut self) {
        self.constant_result.clear();
    }

    // Param is passed by value, moved
    pub fn set_constant_result(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.constant_result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_constant_result(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.constant_result
    }

    // Take field
    pub fn take_constant_result(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.constant_result, ::protobuf::RepeatedField::new())
    }

    // .protocol.Return result = 4;


    pub fn get_result(&self) -> &Return {
        self.result.as_ref().unwrap_or_else(|| <Return as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Return) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut Return {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> Return {
        self.result.take().unwrap_or_else(|| Return::new())
    }
}

impl ::protobuf::Message for TransactionExtention {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.constant_result)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.txid);
        }
        for value in &self.constant_result {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(2, &self.txid)?;
        }
        for v in &self.constant_result {
            os.write_bytes(3, &v)?;
        };
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionExtention {
        TransactionExtention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Transaction>>(
                "transaction",
                |m: &TransactionExtention| { &m.transaction },
                |m: &mut TransactionExtention| { &mut m.transaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txid",
                |m: &TransactionExtention| { &m.txid },
                |m: &mut TransactionExtention| { &mut m.txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "constant_result",
                |m: &TransactionExtention| { &m.constant_result },
                |m: &mut TransactionExtention| { &mut m.constant_result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Return>>(
                "result",
                |m: &TransactionExtention| { &m.result },
                |m: &mut TransactionExtention| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionExtention>(
                "TransactionExtention",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionExtention {
        static instance: ::protobuf::rt::LazyV2<TransactionExtention> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionExtention::new)
    }
}

impl ::protobuf::Clear for TransactionExtention {
    fn clear(&mut self) {
        self.transaction.clear();
        self.txid.clear();
        self.constant_result.clear();
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionExtention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionExtention {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockExtention {
    // message fields
    pub transactions: ::protobuf::RepeatedField<TransactionExtention>,
    pub block_header: ::protobuf::SingularPtrField<super::Tron::BlockHeader>,
    pub blockid: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockExtention {
    fn default() -> &'a BlockExtention {
        <BlockExtention as ::protobuf::Message>::default_instance()
    }
}

impl BlockExtention {
    pub fn new() -> BlockExtention {
        ::std::default::Default::default()
    }

    // repeated .protocol.TransactionExtention transactions = 1;


    pub fn get_transactions(&self) -> &[TransactionExtention] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<TransactionExtention>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<TransactionExtention> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<TransactionExtention> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    // .protocol.BlockHeader block_header = 2;


    pub fn get_block_header(&self) -> &super::Tron::BlockHeader {
        self.block_header.as_ref().unwrap_or_else(|| <super::Tron::BlockHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block_header(&mut self) {
        self.block_header.clear();
    }

    pub fn has_block_header(&self) -> bool {
        self.block_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_header(&mut self, v: super::Tron::BlockHeader) {
        self.block_header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_header(&mut self) -> &mut super::Tron::BlockHeader {
        if self.block_header.is_none() {
            self.block_header.set_default();
        }
        self.block_header.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_header(&mut self) -> super::Tron::BlockHeader {
        self.block_header.take().unwrap_or_else(|| super::Tron::BlockHeader::new())
    }

    // bytes blockid = 3;


    pub fn get_blockid(&self) -> &[u8] {
        &self.blockid
    }
    pub fn clear_blockid(&mut self) {
        self.blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockid
    }

    // Take field
    pub fn take_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockid, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockExtention {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block_header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block_header)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.block_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.blockid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.block_header.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.blockid.is_empty() {
            os.write_bytes(3, &self.blockid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockExtention {
        BlockExtention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionExtention>>(
                "transactions",
                |m: &BlockExtention| { &m.transactions },
                |m: &mut BlockExtention| { &mut m.transactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::BlockHeader>>(
                "block_header",
                |m: &BlockExtention| { &m.block_header },
                |m: &mut BlockExtention| { &mut m.block_header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blockid",
                |m: &BlockExtention| { &m.blockid },
                |m: &mut BlockExtention| { &mut m.blockid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockExtention>(
                "BlockExtention",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockExtention {
        static instance: ::protobuf::rt::LazyV2<BlockExtention> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockExtention::new)
    }
}

impl ::protobuf::Clear for BlockExtention {
    fn clear(&mut self) {
        self.transactions.clear();
        self.block_header.clear();
        self.blockid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockExtention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockExtention {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockListExtention {
    // message fields
    pub block: ::protobuf::RepeatedField<BlockExtention>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockListExtention {
    fn default() -> &'a BlockListExtention {
        <BlockListExtention as ::protobuf::Message>::default_instance()
    }
}

impl BlockListExtention {
    pub fn new() -> BlockListExtention {
        ::std::default::Default::default()
    }

    // repeated .protocol.BlockExtention block = 1;


    pub fn get_block(&self) -> &[BlockExtention] {
        &self.block
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::protobuf::RepeatedField<BlockExtention>) {
        self.block = v;
    }

    // Mutable pointer to the field.
    pub fn mut_block(&mut self) -> &mut ::protobuf::RepeatedField<BlockExtention> {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::protobuf::RepeatedField<BlockExtention> {
        ::std::mem::replace(&mut self.block, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockListExtention {
    fn is_initialized(&self) -> bool {
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.block {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.block {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockListExtention {
        BlockListExtention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockExtention>>(
                "block",
                |m: &BlockListExtention| { &m.block },
                |m: &mut BlockListExtention| { &mut m.block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockListExtention>(
                "BlockListExtention",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockListExtention {
        static instance: ::protobuf::rt::LazyV2<BlockListExtention> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockListExtention::new)
    }
}

impl ::protobuf::Clear for BlockListExtention {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockListExtention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockListExtention {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionListExtention {
    // message fields
    pub transaction: ::protobuf::RepeatedField<TransactionExtention>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionListExtention {
    fn default() -> &'a TransactionListExtention {
        <TransactionListExtention as ::protobuf::Message>::default_instance()
    }
}

impl TransactionListExtention {
    pub fn new() -> TransactionListExtention {
        ::std::default::Default::default()
    }

    // repeated .protocol.TransactionExtention transaction = 1;


    pub fn get_transaction(&self) -> &[TransactionExtention] {
        &self.transaction
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::protobuf::RepeatedField<TransactionExtention>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::protobuf::RepeatedField<TransactionExtention> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::protobuf::RepeatedField<TransactionExtention> {
        ::std::mem::replace(&mut self.transaction, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionListExtention {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transaction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transaction {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionListExtention {
        TransactionListExtention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionExtention>>(
                "transaction",
                |m: &TransactionListExtention| { &m.transaction },
                |m: &mut TransactionListExtention| { &mut m.transaction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionListExtention>(
                "TransactionListExtention",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionListExtention {
        static instance: ::protobuf::rt::LazyV2<TransactionListExtention> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionListExtention::new)
    }
}

impl ::protobuf::Clear for TransactionListExtention {
    fn clear(&mut self) {
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionListExtention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionListExtention {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockIncrementalMerkleTree {
    // message fields
    pub number: i64,
    pub merkleTree: ::protobuf::SingularPtrField<super::Contract::IncrementalMerkleTree>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockIncrementalMerkleTree {
    fn default() -> &'a BlockIncrementalMerkleTree {
        <BlockIncrementalMerkleTree as ::protobuf::Message>::default_instance()
    }
}

impl BlockIncrementalMerkleTree {
    pub fn new() -> BlockIncrementalMerkleTree {
        ::std::default::Default::default()
    }

    // int64 number = 1;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }

    // .protocol.IncrementalMerkleTree merkleTree = 2;


    pub fn get_merkleTree(&self) -> &super::Contract::IncrementalMerkleTree {
        self.merkleTree.as_ref().unwrap_or_else(|| <super::Contract::IncrementalMerkleTree as ::protobuf::Message>::default_instance())
    }
    pub fn clear_merkleTree(&mut self) {
        self.merkleTree.clear();
    }

    pub fn has_merkleTree(&self) -> bool {
        self.merkleTree.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merkleTree(&mut self, v: super::Contract::IncrementalMerkleTree) {
        self.merkleTree = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merkleTree(&mut self) -> &mut super::Contract::IncrementalMerkleTree {
        if self.merkleTree.is_none() {
            self.merkleTree.set_default();
        }
        self.merkleTree.as_mut().unwrap()
    }

    // Take field
    pub fn take_merkleTree(&mut self) -> super::Contract::IncrementalMerkleTree {
        self.merkleTree.take().unwrap_or_else(|| super::Contract::IncrementalMerkleTree::new())
    }
}

impl ::protobuf::Message for BlockIncrementalMerkleTree {
    fn is_initialized(&self) -> bool {
        for v in &self.merkleTree {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.merkleTree)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(1, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.merkleTree.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.number != 0 {
            os.write_int64(1, self.number)?;
        }
        if let Some(ref v) = self.merkleTree.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockIncrementalMerkleTree {
        BlockIncrementalMerkleTree::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "number",
                |m: &BlockIncrementalMerkleTree| { &m.number },
                |m: &mut BlockIncrementalMerkleTree| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Contract::IncrementalMerkleTree>>(
                "merkleTree",
                |m: &BlockIncrementalMerkleTree| { &m.merkleTree },
                |m: &mut BlockIncrementalMerkleTree| { &mut m.merkleTree },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockIncrementalMerkleTree>(
                "BlockIncrementalMerkleTree",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockIncrementalMerkleTree {
        static instance: ::protobuf::rt::LazyV2<BlockIncrementalMerkleTree> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockIncrementalMerkleTree::new)
    }
}

impl ::protobuf::Clear for BlockIncrementalMerkleTree {
    fn clear(&mut self) {
        self.number = 0;
        self.merkleTree.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockIncrementalMerkleTree {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockIncrementalMerkleTree {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionSignWeight {
    // message fields
    pub permission: ::protobuf::SingularPtrField<super::Tron::Permission>,
    pub approved_list: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub current_weight: i64,
    pub result: ::protobuf::SingularPtrField<TransactionSignWeight_Result>,
    pub transaction: ::protobuf::SingularPtrField<TransactionExtention>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionSignWeight {
    fn default() -> &'a TransactionSignWeight {
        <TransactionSignWeight as ::protobuf::Message>::default_instance()
    }
}

impl TransactionSignWeight {
    pub fn new() -> TransactionSignWeight {
        ::std::default::Default::default()
    }

    // .protocol.Permission permission = 1;


    pub fn get_permission(&self) -> &super::Tron::Permission {
        self.permission.as_ref().unwrap_or_else(|| <super::Tron::Permission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: super::Tron::Permission) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut super::Tron::Permission {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> super::Tron::Permission {
        self.permission.take().unwrap_or_else(|| super::Tron::Permission::new())
    }

    // repeated bytes approved_list = 2;


    pub fn get_approved_list(&self) -> &[::std::vec::Vec<u8>] {
        &self.approved_list
    }
    pub fn clear_approved_list(&mut self) {
        self.approved_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_approved_list(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.approved_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_approved_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.approved_list
    }

    // Take field
    pub fn take_approved_list(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.approved_list, ::protobuf::RepeatedField::new())
    }

    // int64 current_weight = 3;


    pub fn get_current_weight(&self) -> i64 {
        self.current_weight
    }
    pub fn clear_current_weight(&mut self) {
        self.current_weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_weight(&mut self, v: i64) {
        self.current_weight = v;
    }

    // .protocol.TransactionSignWeight.Result result = 4;


    pub fn get_result(&self) -> &TransactionSignWeight_Result {
        self.result.as_ref().unwrap_or_else(|| <TransactionSignWeight_Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: TransactionSignWeight_Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut TransactionSignWeight_Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> TransactionSignWeight_Result {
        self.result.take().unwrap_or_else(|| TransactionSignWeight_Result::new())
    }

    // .protocol.TransactionExtention transaction = 5;


    pub fn get_transaction(&self) -> &TransactionExtention {
        self.transaction.as_ref().unwrap_or_else(|| <TransactionExtention as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: TransactionExtention) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut TransactionExtention {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> TransactionExtention {
        self.transaction.take().unwrap_or_else(|| TransactionExtention::new())
    }
}

impl ::protobuf::Message for TransactionSignWeight {
    fn is_initialized(&self) -> bool {
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.approved_list)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.current_weight = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.approved_list {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.current_weight != 0 {
            my_size += ::protobuf::rt::value_size(3, self.current_weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.approved_list {
            os.write_bytes(2, &v)?;
        };
        if self.current_weight != 0 {
            os.write_int64(3, self.current_weight)?;
        }
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSignWeight {
        TransactionSignWeight::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Permission>>(
                "permission",
                |m: &TransactionSignWeight| { &m.permission },
                |m: &mut TransactionSignWeight| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "approved_list",
                |m: &TransactionSignWeight| { &m.approved_list },
                |m: &mut TransactionSignWeight| { &mut m.approved_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "current_weight",
                |m: &TransactionSignWeight| { &m.current_weight },
                |m: &mut TransactionSignWeight| { &mut m.current_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionSignWeight_Result>>(
                "result",
                |m: &TransactionSignWeight| { &m.result },
                |m: &mut TransactionSignWeight| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionExtention>>(
                "transaction",
                |m: &TransactionSignWeight| { &m.transaction },
                |m: &mut TransactionSignWeight| { &mut m.transaction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionSignWeight>(
                "TransactionSignWeight",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionSignWeight {
        static instance: ::protobuf::rt::LazyV2<TransactionSignWeight> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionSignWeight::new)
    }
}

impl ::protobuf::Clear for TransactionSignWeight {
    fn clear(&mut self) {
        self.permission.clear();
        self.approved_list.clear();
        self.current_weight = 0;
        self.result.clear();
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSignWeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSignWeight {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionSignWeight_Result {
    // message fields
    pub code: TransactionSignWeight_Result_response_code,
    pub message: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionSignWeight_Result {
    fn default() -> &'a TransactionSignWeight_Result {
        <TransactionSignWeight_Result as ::protobuf::Message>::default_instance()
    }
}

impl TransactionSignWeight_Result {
    pub fn new() -> TransactionSignWeight_Result {
        ::std::default::Default::default()
    }

    // .protocol.TransactionSignWeight.Result.response_code code = 1;


    pub fn get_code(&self) -> TransactionSignWeight_Result_response_code {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: TransactionSignWeight_Result_response_code) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TransactionSignWeight_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSignWeight_Result {
        TransactionSignWeight_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionSignWeight_Result_response_code>>(
                "code",
                |m: &TransactionSignWeight_Result| { &m.code },
                |m: &mut TransactionSignWeight_Result| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &TransactionSignWeight_Result| { &m.message },
                |m: &mut TransactionSignWeight_Result| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionSignWeight_Result>(
                "TransactionSignWeight.Result",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionSignWeight_Result {
        static instance: ::protobuf::rt::LazyV2<TransactionSignWeight_Result> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionSignWeight_Result::new)
    }
}

impl ::protobuf::Clear for TransactionSignWeight_Result {
    fn clear(&mut self) {
        self.code = TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSignWeight_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSignWeight_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum TransactionSignWeight_Result_response_code {
    ENOUGH_PERMISSION = 0,
    NOT_ENOUGH_PERMISSION = 1,
    SIGNATURE_FORMAT_ERROR = 2,
    COMPUTE_ADDRESS_ERROR = 3,
    PERMISSION_ERROR = 4,
    OTHER_ERROR = 20,
}

impl ::protobuf::ProtobufEnum for TransactionSignWeight_Result_response_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionSignWeight_Result_response_code> {
        match value {
            0 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION),
            1 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::NOT_ENOUGH_PERMISSION),
            2 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::SIGNATURE_FORMAT_ERROR),
            3 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::COMPUTE_ADDRESS_ERROR),
            4 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::PERMISSION_ERROR),
            20 => ::std::option::Option::Some(TransactionSignWeight_Result_response_code::OTHER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionSignWeight_Result_response_code] = &[
            TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION,
            TransactionSignWeight_Result_response_code::NOT_ENOUGH_PERMISSION,
            TransactionSignWeight_Result_response_code::SIGNATURE_FORMAT_ERROR,
            TransactionSignWeight_Result_response_code::COMPUTE_ADDRESS_ERROR,
            TransactionSignWeight_Result_response_code::PERMISSION_ERROR,
            TransactionSignWeight_Result_response_code::OTHER_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TransactionSignWeight_Result_response_code>("TransactionSignWeight.Result.response_code", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TransactionSignWeight_Result_response_code {
}

impl ::std::default::Default for TransactionSignWeight_Result_response_code {
    fn default() -> Self {
        TransactionSignWeight_Result_response_code::ENOUGH_PERMISSION
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSignWeight_Result_response_code {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionApprovedList {
    // message fields
    pub approved_list: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub result: ::protobuf::SingularPtrField<TransactionApprovedList_Result>,
    pub transaction: ::protobuf::SingularPtrField<TransactionExtention>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionApprovedList {
    fn default() -> &'a TransactionApprovedList {
        <TransactionApprovedList as ::protobuf::Message>::default_instance()
    }
}

impl TransactionApprovedList {
    pub fn new() -> TransactionApprovedList {
        ::std::default::Default::default()
    }

    // repeated bytes approved_list = 2;


    pub fn get_approved_list(&self) -> &[::std::vec::Vec<u8>] {
        &self.approved_list
    }
    pub fn clear_approved_list(&mut self) {
        self.approved_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_approved_list(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.approved_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_approved_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.approved_list
    }

    // Take field
    pub fn take_approved_list(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.approved_list, ::protobuf::RepeatedField::new())
    }

    // .protocol.TransactionApprovedList.Result result = 4;


    pub fn get_result(&self) -> &TransactionApprovedList_Result {
        self.result.as_ref().unwrap_or_else(|| <TransactionApprovedList_Result as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: TransactionApprovedList_Result) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut TransactionApprovedList_Result {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> TransactionApprovedList_Result {
        self.result.take().unwrap_or_else(|| TransactionApprovedList_Result::new())
    }

    // .protocol.TransactionExtention transaction = 5;


    pub fn get_transaction(&self) -> &TransactionExtention {
        self.transaction.as_ref().unwrap_or_else(|| <TransactionExtention as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: TransactionExtention) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut TransactionExtention {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> TransactionExtention {
        self.transaction.take().unwrap_or_else(|| TransactionExtention::new())
    }
}

impl ::protobuf::Message for TransactionApprovedList {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.approved_list)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.approved_list {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.approved_list {
            os.write_bytes(2, &v)?;
        };
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionApprovedList {
        TransactionApprovedList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "approved_list",
                |m: &TransactionApprovedList| { &m.approved_list },
                |m: &mut TransactionApprovedList| { &mut m.approved_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionApprovedList_Result>>(
                "result",
                |m: &TransactionApprovedList| { &m.result },
                |m: &mut TransactionApprovedList| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionExtention>>(
                "transaction",
                |m: &TransactionApprovedList| { &m.transaction },
                |m: &mut TransactionApprovedList| { &mut m.transaction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionApprovedList>(
                "TransactionApprovedList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionApprovedList {
        static instance: ::protobuf::rt::LazyV2<TransactionApprovedList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionApprovedList::new)
    }
}

impl ::protobuf::Clear for TransactionApprovedList {
    fn clear(&mut self) {
        self.approved_list.clear();
        self.result.clear();
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionApprovedList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionApprovedList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionApprovedList_Result {
    // message fields
    pub code: TransactionApprovedList_Result_response_code,
    pub message: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionApprovedList_Result {
    fn default() -> &'a TransactionApprovedList_Result {
        <TransactionApprovedList_Result as ::protobuf::Message>::default_instance()
    }
}

impl TransactionApprovedList_Result {
    pub fn new() -> TransactionApprovedList_Result {
        ::std::default::Default::default()
    }

    // .protocol.TransactionApprovedList.Result.response_code code = 1;


    pub fn get_code(&self) -> TransactionApprovedList_Result_response_code {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = TransactionApprovedList_Result_response_code::SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: TransactionApprovedList_Result_response_code) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TransactionApprovedList_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != TransactionApprovedList_Result_response_code::SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != TransactionApprovedList_Result_response_code::SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionApprovedList_Result {
        TransactionApprovedList_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionApprovedList_Result_response_code>>(
                "code",
                |m: &TransactionApprovedList_Result| { &m.code },
                |m: &mut TransactionApprovedList_Result| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &TransactionApprovedList_Result| { &m.message },
                |m: &mut TransactionApprovedList_Result| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionApprovedList_Result>(
                "TransactionApprovedList.Result",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionApprovedList_Result {
        static instance: ::protobuf::rt::LazyV2<TransactionApprovedList_Result> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionApprovedList_Result::new)
    }
}

impl ::protobuf::Clear for TransactionApprovedList_Result {
    fn clear(&mut self) {
        self.code = TransactionApprovedList_Result_response_code::SUCCESS;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionApprovedList_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionApprovedList_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum TransactionApprovedList_Result_response_code {
    SUCCESS = 0,
    SIGNATURE_FORMAT_ERROR = 1,
    COMPUTE_ADDRESS_ERROR = 2,
    OTHER_ERROR = 20,
}

impl ::protobuf::ProtobufEnum for TransactionApprovedList_Result_response_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionApprovedList_Result_response_code> {
        match value {
            0 => ::std::option::Option::Some(TransactionApprovedList_Result_response_code::SUCCESS),
            1 => ::std::option::Option::Some(TransactionApprovedList_Result_response_code::SIGNATURE_FORMAT_ERROR),
            2 => ::std::option::Option::Some(TransactionApprovedList_Result_response_code::COMPUTE_ADDRESS_ERROR),
            20 => ::std::option::Option::Some(TransactionApprovedList_Result_response_code::OTHER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionApprovedList_Result_response_code] = &[
            TransactionApprovedList_Result_response_code::SUCCESS,
            TransactionApprovedList_Result_response_code::SIGNATURE_FORMAT_ERROR,
            TransactionApprovedList_Result_response_code::COMPUTE_ADDRESS_ERROR,
            TransactionApprovedList_Result_response_code::OTHER_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TransactionApprovedList_Result_response_code>("TransactionApprovedList.Result.response_code", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TransactionApprovedList_Result_response_code {
}

impl ::std::default::Default for TransactionApprovedList_Result_response_code {
    fn default() -> Self {
        TransactionApprovedList_Result_response_code::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionApprovedList_Result_response_code {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IvkDecryptParameters {
    // message fields
    pub start_block_index: i64,
    pub end_block_index: i64,
    pub ivk: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IvkDecryptParameters {
    fn default() -> &'a IvkDecryptParameters {
        <IvkDecryptParameters as ::protobuf::Message>::default_instance()
    }
}

impl IvkDecryptParameters {
    pub fn new() -> IvkDecryptParameters {
        ::std::default::Default::default()
    }

    // int64 start_block_index = 1;


    pub fn get_start_block_index(&self) -> i64 {
        self.start_block_index
    }
    pub fn clear_start_block_index(&mut self) {
        self.start_block_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_block_index(&mut self, v: i64) {
        self.start_block_index = v;
    }

    // int64 end_block_index = 2;


    pub fn get_end_block_index(&self) -> i64 {
        self.end_block_index
    }
    pub fn clear_end_block_index(&mut self) {
        self.end_block_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_block_index(&mut self, v: i64) {
        self.end_block_index = v;
    }

    // bytes ivk = 3;


    pub fn get_ivk(&self) -> &[u8] {
        &self.ivk
    }
    pub fn clear_ivk(&mut self) {
        self.ivk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ivk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ivk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ivk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ivk
    }

    // Take field
    pub fn take_ivk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ivk, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IvkDecryptParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_block_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_block_index = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ivk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_block_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_block_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_block_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_block_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ivk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ivk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_block_index != 0 {
            os.write_int64(1, self.start_block_index)?;
        }
        if self.end_block_index != 0 {
            os.write_int64(2, self.end_block_index)?;
        }
        if !self.ivk.is_empty() {
            os.write_bytes(3, &self.ivk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IvkDecryptParameters {
        IvkDecryptParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_block_index",
                |m: &IvkDecryptParameters| { &m.start_block_index },
                |m: &mut IvkDecryptParameters| { &mut m.start_block_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end_block_index",
                |m: &IvkDecryptParameters| { &m.end_block_index },
                |m: &mut IvkDecryptParameters| { &mut m.end_block_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ivk",
                |m: &IvkDecryptParameters| { &m.ivk },
                |m: &mut IvkDecryptParameters| { &mut m.ivk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IvkDecryptParameters>(
                "IvkDecryptParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IvkDecryptParameters {
        static instance: ::protobuf::rt::LazyV2<IvkDecryptParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IvkDecryptParameters::new)
    }
}

impl ::protobuf::Clear for IvkDecryptParameters {
    fn clear(&mut self) {
        self.start_block_index = 0;
        self.end_block_index = 0;
        self.ivk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IvkDecryptParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IvkDecryptParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IvkDecryptAndMarkParameters {
    // message fields
    pub start_block_index: i64,
    pub end_block_index: i64,
    pub ivk: ::std::vec::Vec<u8>,
    pub ak: ::std::vec::Vec<u8>,
    pub nk: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IvkDecryptAndMarkParameters {
    fn default() -> &'a IvkDecryptAndMarkParameters {
        <IvkDecryptAndMarkParameters as ::protobuf::Message>::default_instance()
    }
}

impl IvkDecryptAndMarkParameters {
    pub fn new() -> IvkDecryptAndMarkParameters {
        ::std::default::Default::default()
    }

    // int64 start_block_index = 1;


    pub fn get_start_block_index(&self) -> i64 {
        self.start_block_index
    }
    pub fn clear_start_block_index(&mut self) {
        self.start_block_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_block_index(&mut self, v: i64) {
        self.start_block_index = v;
    }

    // int64 end_block_index = 2;


    pub fn get_end_block_index(&self) -> i64 {
        self.end_block_index
    }
    pub fn clear_end_block_index(&mut self) {
        self.end_block_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_block_index(&mut self, v: i64) {
        self.end_block_index = v;
    }

    // bytes ivk = 5;


    pub fn get_ivk(&self) -> &[u8] {
        &self.ivk
    }
    pub fn clear_ivk(&mut self) {
        self.ivk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ivk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ivk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ivk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ivk
    }

    // Take field
    pub fn take_ivk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ivk, ::std::vec::Vec::new())
    }

    // bytes ak = 3;


    pub fn get_ak(&self) -> &[u8] {
        &self.ak
    }
    pub fn clear_ak(&mut self) {
        self.ak.clear();
    }

    // Param is passed by value, moved
    pub fn set_ak(&mut self, v: ::std::vec::Vec<u8>) {
        self.ak = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ak(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ak
    }

    // Take field
    pub fn take_ak(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ak, ::std::vec::Vec::new())
    }

    // bytes nk = 4;


    pub fn get_nk(&self) -> &[u8] {
        &self.nk
    }
    pub fn clear_nk(&mut self) {
        self.nk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nk
    }

    // Take field
    pub fn take_nk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nk, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IvkDecryptAndMarkParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_block_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_block_index = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ivk)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ak)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_block_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_block_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_block_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_block_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ivk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.ivk);
        }
        if !self.ak.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ak);
        }
        if !self.nk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.nk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_block_index != 0 {
            os.write_int64(1, self.start_block_index)?;
        }
        if self.end_block_index != 0 {
            os.write_int64(2, self.end_block_index)?;
        }
        if !self.ivk.is_empty() {
            os.write_bytes(5, &self.ivk)?;
        }
        if !self.ak.is_empty() {
            os.write_bytes(3, &self.ak)?;
        }
        if !self.nk.is_empty() {
            os.write_bytes(4, &self.nk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IvkDecryptAndMarkParameters {
        IvkDecryptAndMarkParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_block_index",
                |m: &IvkDecryptAndMarkParameters| { &m.start_block_index },
                |m: &mut IvkDecryptAndMarkParameters| { &mut m.start_block_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end_block_index",
                |m: &IvkDecryptAndMarkParameters| { &m.end_block_index },
                |m: &mut IvkDecryptAndMarkParameters| { &mut m.end_block_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ivk",
                |m: &IvkDecryptAndMarkParameters| { &m.ivk },
                |m: &mut IvkDecryptAndMarkParameters| { &mut m.ivk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ak",
                |m: &IvkDecryptAndMarkParameters| { &m.ak },
                |m: &mut IvkDecryptAndMarkParameters| { &mut m.ak },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nk",
                |m: &IvkDecryptAndMarkParameters| { &m.nk },
                |m: &mut IvkDecryptAndMarkParameters| { &mut m.nk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IvkDecryptAndMarkParameters>(
                "IvkDecryptAndMarkParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IvkDecryptAndMarkParameters {
        static instance: ::protobuf::rt::LazyV2<IvkDecryptAndMarkParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IvkDecryptAndMarkParameters::new)
    }
}

impl ::protobuf::Clear for IvkDecryptAndMarkParameters {
    fn clear(&mut self) {
        self.start_block_index = 0;
        self.end_block_index = 0;
        self.ivk.clear();
        self.ak.clear();
        self.nk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IvkDecryptAndMarkParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IvkDecryptAndMarkParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct OvkDecryptParameters {
    // message fields
    pub start_block_index: i64,
    pub end_block_index: i64,
    pub ovk: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OvkDecryptParameters {
    fn default() -> &'a OvkDecryptParameters {
        <OvkDecryptParameters as ::protobuf::Message>::default_instance()
    }
}

impl OvkDecryptParameters {
    pub fn new() -> OvkDecryptParameters {
        ::std::default::Default::default()
    }

    // int64 start_block_index = 1;


    pub fn get_start_block_index(&self) -> i64 {
        self.start_block_index
    }
    pub fn clear_start_block_index(&mut self) {
        self.start_block_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_block_index(&mut self, v: i64) {
        self.start_block_index = v;
    }

    // int64 end_block_index = 2;


    pub fn get_end_block_index(&self) -> i64 {
        self.end_block_index
    }
    pub fn clear_end_block_index(&mut self) {
        self.end_block_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_block_index(&mut self, v: i64) {
        self.end_block_index = v;
    }

    // bytes ovk = 3;


    pub fn get_ovk(&self) -> &[u8] {
        &self.ovk
    }
    pub fn clear_ovk(&mut self) {
        self.ovk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ovk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ovk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ovk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ovk
    }

    // Take field
    pub fn take_ovk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ovk, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OvkDecryptParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_block_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_block_index = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ovk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_block_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_block_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_block_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.end_block_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ovk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ovk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start_block_index != 0 {
            os.write_int64(1, self.start_block_index)?;
        }
        if self.end_block_index != 0 {
            os.write_int64(2, self.end_block_index)?;
        }
        if !self.ovk.is_empty() {
            os.write_bytes(3, &self.ovk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OvkDecryptParameters {
        OvkDecryptParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_block_index",
                |m: &OvkDecryptParameters| { &m.start_block_index },
                |m: &mut OvkDecryptParameters| { &mut m.start_block_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end_block_index",
                |m: &OvkDecryptParameters| { &m.end_block_index },
                |m: &mut OvkDecryptParameters| { &mut m.end_block_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ovk",
                |m: &OvkDecryptParameters| { &m.ovk },
                |m: &mut OvkDecryptParameters| { &mut m.ovk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OvkDecryptParameters>(
                "OvkDecryptParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OvkDecryptParameters {
        static instance: ::protobuf::rt::LazyV2<OvkDecryptParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OvkDecryptParameters::new)
    }
}

impl ::protobuf::Clear for OvkDecryptParameters {
    fn clear(&mut self) {
        self.start_block_index = 0;
        self.end_block_index = 0;
        self.ovk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OvkDecryptParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OvkDecryptParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DecryptNotes {
    // message fields
    pub noteTxs: ::protobuf::RepeatedField<DecryptNotes_NoteTx>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptNotes {
    fn default() -> &'a DecryptNotes {
        <DecryptNotes as ::protobuf::Message>::default_instance()
    }
}

impl DecryptNotes {
    pub fn new() -> DecryptNotes {
        ::std::default::Default::default()
    }

    // repeated .protocol.DecryptNotes.NoteTx noteTxs = 1;


    pub fn get_noteTxs(&self) -> &[DecryptNotes_NoteTx] {
        &self.noteTxs
    }
    pub fn clear_noteTxs(&mut self) {
        self.noteTxs.clear();
    }

    // Param is passed by value, moved
    pub fn set_noteTxs(&mut self, v: ::protobuf::RepeatedField<DecryptNotes_NoteTx>) {
        self.noteTxs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_noteTxs(&mut self) -> &mut ::protobuf::RepeatedField<DecryptNotes_NoteTx> {
        &mut self.noteTxs
    }

    // Take field
    pub fn take_noteTxs(&mut self) -> ::protobuf::RepeatedField<DecryptNotes_NoteTx> {
        ::std::mem::replace(&mut self.noteTxs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DecryptNotes {
    fn is_initialized(&self) -> bool {
        for v in &self.noteTxs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.noteTxs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.noteTxs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.noteTxs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptNotes {
        DecryptNotes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DecryptNotes_NoteTx>>(
                "noteTxs",
                |m: &DecryptNotes| { &m.noteTxs },
                |m: &mut DecryptNotes| { &mut m.noteTxs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptNotes>(
                "DecryptNotes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptNotes {
        static instance: ::protobuf::rt::LazyV2<DecryptNotes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptNotes::new)
    }
}

impl ::protobuf::Clear for DecryptNotes {
    fn clear(&mut self) {
        self.noteTxs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptNotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptNotes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DecryptNotes_NoteTx {
    // message fields
    pub note: ::protobuf::SingularPtrField<Note>,
    pub txid: ::std::vec::Vec<u8>,
    pub index: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptNotes_NoteTx {
    fn default() -> &'a DecryptNotes_NoteTx {
        <DecryptNotes_NoteTx as ::protobuf::Message>::default_instance()
    }
}

impl DecryptNotes_NoteTx {
    pub fn new() -> DecryptNotes_NoteTx {
        ::std::default::Default::default()
    }

    // .protocol.Note note = 1;


    pub fn get_note(&self) -> &Note {
        self.note.as_ref().unwrap_or_else(|| <Note as ::protobuf::Message>::default_instance())
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: Note) {
        self.note = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut Note {
        if self.note.is_none() {
            self.note.set_default();
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> Note {
        self.note.take().unwrap_or_else(|| Note::new())
    }

    // bytes txid = 2;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // int32 index = 3;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }
}

impl ::protobuf::Message for DecryptNotes_NoteTx {
    fn is_initialized(&self) -> bool {
        for v in &self.note {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.note)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.note.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.txid);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.note.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(2, &self.txid)?;
        }
        if self.index != 0 {
            os.write_int32(3, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptNotes_NoteTx {
        DecryptNotes_NoteTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Note>>(
                "note",
                |m: &DecryptNotes_NoteTx| { &m.note },
                |m: &mut DecryptNotes_NoteTx| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txid",
                |m: &DecryptNotes_NoteTx| { &m.txid },
                |m: &mut DecryptNotes_NoteTx| { &mut m.txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &DecryptNotes_NoteTx| { &m.index },
                |m: &mut DecryptNotes_NoteTx| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptNotes_NoteTx>(
                "DecryptNotes.NoteTx",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptNotes_NoteTx {
        static instance: ::protobuf::rt::LazyV2<DecryptNotes_NoteTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptNotes_NoteTx::new)
    }
}

impl ::protobuf::Clear for DecryptNotes_NoteTx {
    fn clear(&mut self) {
        self.note.clear();
        self.txid.clear();
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptNotes_NoteTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptNotes_NoteTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DecryptNotesMarked {
    // message fields
    pub noteTxs: ::protobuf::RepeatedField<DecryptNotesMarked_NoteTx>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptNotesMarked {
    fn default() -> &'a DecryptNotesMarked {
        <DecryptNotesMarked as ::protobuf::Message>::default_instance()
    }
}

impl DecryptNotesMarked {
    pub fn new() -> DecryptNotesMarked {
        ::std::default::Default::default()
    }

    // repeated .protocol.DecryptNotesMarked.NoteTx noteTxs = 1;


    pub fn get_noteTxs(&self) -> &[DecryptNotesMarked_NoteTx] {
        &self.noteTxs
    }
    pub fn clear_noteTxs(&mut self) {
        self.noteTxs.clear();
    }

    // Param is passed by value, moved
    pub fn set_noteTxs(&mut self, v: ::protobuf::RepeatedField<DecryptNotesMarked_NoteTx>) {
        self.noteTxs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_noteTxs(&mut self) -> &mut ::protobuf::RepeatedField<DecryptNotesMarked_NoteTx> {
        &mut self.noteTxs
    }

    // Take field
    pub fn take_noteTxs(&mut self) -> ::protobuf::RepeatedField<DecryptNotesMarked_NoteTx> {
        ::std::mem::replace(&mut self.noteTxs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DecryptNotesMarked {
    fn is_initialized(&self) -> bool {
        for v in &self.noteTxs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.noteTxs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.noteTxs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.noteTxs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptNotesMarked {
        DecryptNotesMarked::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DecryptNotesMarked_NoteTx>>(
                "noteTxs",
                |m: &DecryptNotesMarked| { &m.noteTxs },
                |m: &mut DecryptNotesMarked| { &mut m.noteTxs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptNotesMarked>(
                "DecryptNotesMarked",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptNotesMarked {
        static instance: ::protobuf::rt::LazyV2<DecryptNotesMarked> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptNotesMarked::new)
    }
}

impl ::protobuf::Clear for DecryptNotesMarked {
    fn clear(&mut self) {
        self.noteTxs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptNotesMarked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptNotesMarked {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DecryptNotesMarked_NoteTx {
    // message fields
    pub note: ::protobuf::SingularPtrField<Note>,
    pub txid: ::std::vec::Vec<u8>,
    pub index: i32,
    pub is_spend: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptNotesMarked_NoteTx {
    fn default() -> &'a DecryptNotesMarked_NoteTx {
        <DecryptNotesMarked_NoteTx as ::protobuf::Message>::default_instance()
    }
}

impl DecryptNotesMarked_NoteTx {
    pub fn new() -> DecryptNotesMarked_NoteTx {
        ::std::default::Default::default()
    }

    // .protocol.Note note = 1;


    pub fn get_note(&self) -> &Note {
        self.note.as_ref().unwrap_or_else(|| <Note as ::protobuf::Message>::default_instance())
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: Note) {
        self.note = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut Note {
        if self.note.is_none() {
            self.note.set_default();
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> Note {
        self.note.take().unwrap_or_else(|| Note::new())
    }

    // bytes txid = 2;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // int32 index = 3;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    // bool is_spend = 4;


    pub fn get_is_spend(&self) -> bool {
        self.is_spend
    }
    pub fn clear_is_spend(&mut self) {
        self.is_spend = false;
    }

    // Param is passed by value, moved
    pub fn set_is_spend(&mut self, v: bool) {
        self.is_spend = v;
    }
}

impl ::protobuf::Message for DecryptNotesMarked_NoteTx {
    fn is_initialized(&self) -> bool {
        for v in &self.note {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.note)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_spend = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.note.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.txid);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_spend != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.note.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(2, &self.txid)?;
        }
        if self.index != 0 {
            os.write_int32(3, self.index)?;
        }
        if self.is_spend != false {
            os.write_bool(4, self.is_spend)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptNotesMarked_NoteTx {
        DecryptNotesMarked_NoteTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Note>>(
                "note",
                |m: &DecryptNotesMarked_NoteTx| { &m.note },
                |m: &mut DecryptNotesMarked_NoteTx| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txid",
                |m: &DecryptNotesMarked_NoteTx| { &m.txid },
                |m: &mut DecryptNotesMarked_NoteTx| { &mut m.txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &DecryptNotesMarked_NoteTx| { &m.index },
                |m: &mut DecryptNotesMarked_NoteTx| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_spend",
                |m: &DecryptNotesMarked_NoteTx| { &m.is_spend },
                |m: &mut DecryptNotesMarked_NoteTx| { &mut m.is_spend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptNotesMarked_NoteTx>(
                "DecryptNotesMarked.NoteTx",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptNotesMarked_NoteTx {
        static instance: ::protobuf::rt::LazyV2<DecryptNotesMarked_NoteTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptNotesMarked_NoteTx::new)
    }
}

impl ::protobuf::Clear for DecryptNotesMarked_NoteTx {
    fn clear(&mut self) {
        self.note.clear();
        self.txid.clear();
        self.index = 0;
        self.is_spend = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptNotesMarked_NoteTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptNotesMarked_NoteTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Note {
    // message fields
    pub value: i64,
    pub payment_address: ::std::string::String,
    pub rcm: ::std::vec::Vec<u8>,
    pub memo: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Note {
    fn default() -> &'a Note {
        <Note as ::protobuf::Message>::default_instance()
    }
}

impl Note {
    pub fn new() -> Note {
        ::std::default::Default::default()
    }

    // int64 value = 1;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // string payment_address = 2;


    pub fn get_payment_address(&self) -> &str {
        &self.payment_address
    }
    pub fn clear_payment_address(&mut self) {
        self.payment_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_address(&mut self, v: ::std::string::String) {
        self.payment_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_address(&mut self) -> &mut ::std::string::String {
        &mut self.payment_address
    }

    // Take field
    pub fn take_payment_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_address, ::std::string::String::new())
    }

    // bytes rcm = 3;


    pub fn get_rcm(&self) -> &[u8] {
        &self.rcm
    }
    pub fn clear_rcm(&mut self) {
        self.rcm.clear();
    }

    // Param is passed by value, moved
    pub fn set_rcm(&mut self, v: ::std::vec::Vec<u8>) {
        self.rcm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rcm(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.rcm
    }

    // Take field
    pub fn take_rcm(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.rcm, ::std::vec::Vec::new())
    }

    // bytes memo = 4;


    pub fn get_memo(&self) -> &[u8] {
        &self.memo
    }
    pub fn clear_memo(&mut self) {
        self.memo.clear();
    }

    // Param is passed by value, moved
    pub fn set_memo(&mut self, v: ::std::vec::Vec<u8>) {
        self.memo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memo(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.memo
    }

    // Take field
    pub fn take_memo(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.memo, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Note {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.rcm)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.memo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.payment_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.payment_address);
        }
        if !self.rcm.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.rcm);
        }
        if !self.memo.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.memo);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int64(1, self.value)?;
        }
        if !self.payment_address.is_empty() {
            os.write_string(2, &self.payment_address)?;
        }
        if !self.rcm.is_empty() {
            os.write_bytes(3, &self.rcm)?;
        }
        if !self.memo.is_empty() {
            os.write_bytes(4, &self.memo)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Note {
        Note::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value",
                |m: &Note| { &m.value },
                |m: &mut Note| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_address",
                |m: &Note| { &m.payment_address },
                |m: &mut Note| { &mut m.payment_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rcm",
                |m: &Note| { &m.rcm },
                |m: &mut Note| { &mut m.rcm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "memo",
                |m: &Note| { &m.memo },
                |m: &mut Note| { &mut m.memo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Note>(
                "Note",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Note {
        static instance: ::protobuf::rt::LazyV2<Note> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Note::new)
    }
}

impl ::protobuf::Clear for Note {
    fn clear(&mut self) {
        self.value = 0;
        self.payment_address.clear();
        self.rcm.clear();
        self.memo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Note {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Note {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SpendNote {
    // message fields
    pub note: ::protobuf::SingularPtrField<Note>,
    pub alpha: ::std::vec::Vec<u8>,
    pub voucher: ::protobuf::SingularPtrField<super::Contract::IncrementalMerkleVoucher>,
    pub path: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpendNote {
    fn default() -> &'a SpendNote {
        <SpendNote as ::protobuf::Message>::default_instance()
    }
}

impl SpendNote {
    pub fn new() -> SpendNote {
        ::std::default::Default::default()
    }

    // .protocol.Note note = 3;


    pub fn get_note(&self) -> &Note {
        self.note.as_ref().unwrap_or_else(|| <Note as ::protobuf::Message>::default_instance())
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: Note) {
        self.note = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut Note {
        if self.note.is_none() {
            self.note.set_default();
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> Note {
        self.note.take().unwrap_or_else(|| Note::new())
    }

    // bytes alpha = 4;


    pub fn get_alpha(&self) -> &[u8] {
        &self.alpha
    }
    pub fn clear_alpha(&mut self) {
        self.alpha.clear();
    }

    // Param is passed by value, moved
    pub fn set_alpha(&mut self, v: ::std::vec::Vec<u8>) {
        self.alpha = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alpha(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.alpha
    }

    // Take field
    pub fn take_alpha(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.alpha, ::std::vec::Vec::new())
    }

    // .protocol.IncrementalMerkleVoucher voucher = 5;


    pub fn get_voucher(&self) -> &super::Contract::IncrementalMerkleVoucher {
        self.voucher.as_ref().unwrap_or_else(|| <super::Contract::IncrementalMerkleVoucher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voucher(&mut self) {
        self.voucher.clear();
    }

    pub fn has_voucher(&self) -> bool {
        self.voucher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voucher(&mut self, v: super::Contract::IncrementalMerkleVoucher) {
        self.voucher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voucher(&mut self) -> &mut super::Contract::IncrementalMerkleVoucher {
        if self.voucher.is_none() {
            self.voucher.set_default();
        }
        self.voucher.as_mut().unwrap()
    }

    // Take field
    pub fn take_voucher(&mut self) -> super::Contract::IncrementalMerkleVoucher {
        self.voucher.take().unwrap_or_else(|| super::Contract::IncrementalMerkleVoucher::new())
    }

    // bytes path = 6;


    pub fn get_path(&self) -> &[u8] {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::vec::Vec<u8>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.path, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SpendNote {
    fn is_initialized(&self) -> bool {
        for v in &self.note {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voucher {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.note)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.alpha)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voucher)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.note.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.alpha.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.alpha);
        }
        if let Some(ref v) = self.voucher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.note.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.alpha.is_empty() {
            os.write_bytes(4, &self.alpha)?;
        }
        if let Some(ref v) = self.voucher.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.path.is_empty() {
            os.write_bytes(6, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpendNote {
        SpendNote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Note>>(
                "note",
                |m: &SpendNote| { &m.note },
                |m: &mut SpendNote| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "alpha",
                |m: &SpendNote| { &m.alpha },
                |m: &mut SpendNote| { &mut m.alpha },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Contract::IncrementalMerkleVoucher>>(
                "voucher",
                |m: &SpendNote| { &m.voucher },
                |m: &mut SpendNote| { &mut m.voucher },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "path",
                |m: &SpendNote| { &m.path },
                |m: &mut SpendNote| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SpendNote>(
                "SpendNote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SpendNote {
        static instance: ::protobuf::rt::LazyV2<SpendNote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpendNote::new)
    }
}

impl ::protobuf::Clear for SpendNote {
    fn clear(&mut self) {
        self.note.clear();
        self.alpha.clear();
        self.voucher.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpendNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpendNote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ReceiveNote {
    // message fields
    pub note: ::protobuf::SingularPtrField<Note>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceiveNote {
    fn default() -> &'a ReceiveNote {
        <ReceiveNote as ::protobuf::Message>::default_instance()
    }
}

impl ReceiveNote {
    pub fn new() -> ReceiveNote {
        ::std::default::Default::default()
    }

    // .protocol.Note note = 1;


    pub fn get_note(&self) -> &Note {
        self.note.as_ref().unwrap_or_else(|| <Note as ::protobuf::Message>::default_instance())
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: Note) {
        self.note = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut Note {
        if self.note.is_none() {
            self.note.set_default();
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> Note {
        self.note.take().unwrap_or_else(|| Note::new())
    }
}

impl ::protobuf::Message for ReceiveNote {
    fn is_initialized(&self) -> bool {
        for v in &self.note {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.note)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.note.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.note.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceiveNote {
        ReceiveNote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Note>>(
                "note",
                |m: &ReceiveNote| { &m.note },
                |m: &mut ReceiveNote| { &mut m.note },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceiveNote>(
                "ReceiveNote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReceiveNote {
        static instance: ::protobuf::rt::LazyV2<ReceiveNote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReceiveNote::new)
    }
}

impl ::protobuf::Clear for ReceiveNote {
    fn clear(&mut self) {
        self.note.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceiveNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiveNote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PrivateParameters {
    // message fields
    pub transparent_from_address: ::std::vec::Vec<u8>,
    pub ask: ::std::vec::Vec<u8>,
    pub nsk: ::std::vec::Vec<u8>,
    pub ovk: ::std::vec::Vec<u8>,
    pub from_amount: i64,
    pub shielded_spends: ::protobuf::RepeatedField<SpendNote>,
    pub shielded_receives: ::protobuf::RepeatedField<ReceiveNote>,
    pub transparent_to_address: ::std::vec::Vec<u8>,
    pub to_amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrivateParameters {
    fn default() -> &'a PrivateParameters {
        <PrivateParameters as ::protobuf::Message>::default_instance()
    }
}

impl PrivateParameters {
    pub fn new() -> PrivateParameters {
        ::std::default::Default::default()
    }

    // bytes transparent_from_address = 1;


    pub fn get_transparent_from_address(&self) -> &[u8] {
        &self.transparent_from_address
    }
    pub fn clear_transparent_from_address(&mut self) {
        self.transparent_from_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_transparent_from_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.transparent_from_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transparent_from_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transparent_from_address
    }

    // Take field
    pub fn take_transparent_from_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transparent_from_address, ::std::vec::Vec::new())
    }

    // bytes ask = 2;


    pub fn get_ask(&self) -> &[u8] {
        &self.ask
    }
    pub fn clear_ask(&mut self) {
        self.ask.clear();
    }

    // Param is passed by value, moved
    pub fn set_ask(&mut self, v: ::std::vec::Vec<u8>) {
        self.ask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ask(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ask
    }

    // Take field
    pub fn take_ask(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ask, ::std::vec::Vec::new())
    }

    // bytes nsk = 3;


    pub fn get_nsk(&self) -> &[u8] {
        &self.nsk
    }
    pub fn clear_nsk(&mut self) {
        self.nsk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nsk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nsk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nsk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nsk
    }

    // Take field
    pub fn take_nsk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nsk, ::std::vec::Vec::new())
    }

    // bytes ovk = 4;


    pub fn get_ovk(&self) -> &[u8] {
        &self.ovk
    }
    pub fn clear_ovk(&mut self) {
        self.ovk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ovk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ovk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ovk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ovk
    }

    // Take field
    pub fn take_ovk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ovk, ::std::vec::Vec::new())
    }

    // int64 from_amount = 5;


    pub fn get_from_amount(&self) -> i64 {
        self.from_amount
    }
    pub fn clear_from_amount(&mut self) {
        self.from_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_amount(&mut self, v: i64) {
        self.from_amount = v;
    }

    // repeated .protocol.SpendNote shielded_spends = 6;


    pub fn get_shielded_spends(&self) -> &[SpendNote] {
        &self.shielded_spends
    }
    pub fn clear_shielded_spends(&mut self) {
        self.shielded_spends.clear();
    }

    // Param is passed by value, moved
    pub fn set_shielded_spends(&mut self, v: ::protobuf::RepeatedField<SpendNote>) {
        self.shielded_spends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shielded_spends(&mut self) -> &mut ::protobuf::RepeatedField<SpendNote> {
        &mut self.shielded_spends
    }

    // Take field
    pub fn take_shielded_spends(&mut self) -> ::protobuf::RepeatedField<SpendNote> {
        ::std::mem::replace(&mut self.shielded_spends, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.ReceiveNote shielded_receives = 7;


    pub fn get_shielded_receives(&self) -> &[ReceiveNote] {
        &self.shielded_receives
    }
    pub fn clear_shielded_receives(&mut self) {
        self.shielded_receives.clear();
    }

    // Param is passed by value, moved
    pub fn set_shielded_receives(&mut self, v: ::protobuf::RepeatedField<ReceiveNote>) {
        self.shielded_receives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shielded_receives(&mut self) -> &mut ::protobuf::RepeatedField<ReceiveNote> {
        &mut self.shielded_receives
    }

    // Take field
    pub fn take_shielded_receives(&mut self) -> ::protobuf::RepeatedField<ReceiveNote> {
        ::std::mem::replace(&mut self.shielded_receives, ::protobuf::RepeatedField::new())
    }

    // bytes transparent_to_address = 8;


    pub fn get_transparent_to_address(&self) -> &[u8] {
        &self.transparent_to_address
    }
    pub fn clear_transparent_to_address(&mut self) {
        self.transparent_to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_transparent_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.transparent_to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transparent_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transparent_to_address
    }

    // Take field
    pub fn take_transparent_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transparent_to_address, ::std::vec::Vec::new())
    }

    // int64 to_amount = 9;


    pub fn get_to_amount(&self) -> i64 {
        self.to_amount
    }
    pub fn clear_to_amount(&mut self) {
        self.to_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_amount(&mut self, v: i64) {
        self.to_amount = v;
    }
}

impl ::protobuf::Message for PrivateParameters {
    fn is_initialized(&self) -> bool {
        for v in &self.shielded_spends {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shielded_receives {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transparent_from_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ask)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nsk)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ovk)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.from_amount = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shielded_spends)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shielded_receives)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transparent_to_address)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.to_amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transparent_from_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transparent_from_address);
        }
        if !self.ask.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ask);
        }
        if !self.nsk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.nsk);
        }
        if !self.ovk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.ovk);
        }
        if self.from_amount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.from_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.shielded_spends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.shielded_receives {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.transparent_to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.transparent_to_address);
        }
        if self.to_amount != 0 {
            my_size += ::protobuf::rt::value_size(9, self.to_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.transparent_from_address.is_empty() {
            os.write_bytes(1, &self.transparent_from_address)?;
        }
        if !self.ask.is_empty() {
            os.write_bytes(2, &self.ask)?;
        }
        if !self.nsk.is_empty() {
            os.write_bytes(3, &self.nsk)?;
        }
        if !self.ovk.is_empty() {
            os.write_bytes(4, &self.ovk)?;
        }
        if self.from_amount != 0 {
            os.write_int64(5, self.from_amount)?;
        }
        for v in &self.shielded_spends {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.shielded_receives {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.transparent_to_address.is_empty() {
            os.write_bytes(8, &self.transparent_to_address)?;
        }
        if self.to_amount != 0 {
            os.write_int64(9, self.to_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrivateParameters {
        PrivateParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transparent_from_address",
                |m: &PrivateParameters| { &m.transparent_from_address },
                |m: &mut PrivateParameters| { &mut m.transparent_from_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ask",
                |m: &PrivateParameters| { &m.ask },
                |m: &mut PrivateParameters| { &mut m.ask },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nsk",
                |m: &PrivateParameters| { &m.nsk },
                |m: &mut PrivateParameters| { &mut m.nsk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ovk",
                |m: &PrivateParameters| { &m.ovk },
                |m: &mut PrivateParameters| { &mut m.ovk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "from_amount",
                |m: &PrivateParameters| { &m.from_amount },
                |m: &mut PrivateParameters| { &mut m.from_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpendNote>>(
                "shielded_spends",
                |m: &PrivateParameters| { &m.shielded_spends },
                |m: &mut PrivateParameters| { &mut m.shielded_spends },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceiveNote>>(
                "shielded_receives",
                |m: &PrivateParameters| { &m.shielded_receives },
                |m: &mut PrivateParameters| { &mut m.shielded_receives },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transparent_to_address",
                |m: &PrivateParameters| { &m.transparent_to_address },
                |m: &mut PrivateParameters| { &mut m.transparent_to_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "to_amount",
                |m: &PrivateParameters| { &m.to_amount },
                |m: &mut PrivateParameters| { &mut m.to_amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrivateParameters>(
                "PrivateParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrivateParameters {
        static instance: ::protobuf::rt::LazyV2<PrivateParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrivateParameters::new)
    }
}

impl ::protobuf::Clear for PrivateParameters {
    fn clear(&mut self) {
        self.transparent_from_address.clear();
        self.ask.clear();
        self.nsk.clear();
        self.ovk.clear();
        self.from_amount = 0;
        self.shielded_spends.clear();
        self.shielded_receives.clear();
        self.transparent_to_address.clear();
        self.to_amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrivateParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrivateParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PrivateParametersWithoutAsk {
    // message fields
    pub transparent_from_address: ::std::vec::Vec<u8>,
    pub ak: ::std::vec::Vec<u8>,
    pub nsk: ::std::vec::Vec<u8>,
    pub ovk: ::std::vec::Vec<u8>,
    pub from_amount: i64,
    pub shielded_spends: ::protobuf::RepeatedField<SpendNote>,
    pub shielded_receives: ::protobuf::RepeatedField<ReceiveNote>,
    pub transparent_to_address: ::std::vec::Vec<u8>,
    pub to_amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrivateParametersWithoutAsk {
    fn default() -> &'a PrivateParametersWithoutAsk {
        <PrivateParametersWithoutAsk as ::protobuf::Message>::default_instance()
    }
}

impl PrivateParametersWithoutAsk {
    pub fn new() -> PrivateParametersWithoutAsk {
        ::std::default::Default::default()
    }

    // bytes transparent_from_address = 1;


    pub fn get_transparent_from_address(&self) -> &[u8] {
        &self.transparent_from_address
    }
    pub fn clear_transparent_from_address(&mut self) {
        self.transparent_from_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_transparent_from_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.transparent_from_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transparent_from_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transparent_from_address
    }

    // Take field
    pub fn take_transparent_from_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transparent_from_address, ::std::vec::Vec::new())
    }

    // bytes ak = 2;


    pub fn get_ak(&self) -> &[u8] {
        &self.ak
    }
    pub fn clear_ak(&mut self) {
        self.ak.clear();
    }

    // Param is passed by value, moved
    pub fn set_ak(&mut self, v: ::std::vec::Vec<u8>) {
        self.ak = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ak(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ak
    }

    // Take field
    pub fn take_ak(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ak, ::std::vec::Vec::new())
    }

    // bytes nsk = 3;


    pub fn get_nsk(&self) -> &[u8] {
        &self.nsk
    }
    pub fn clear_nsk(&mut self) {
        self.nsk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nsk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nsk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nsk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nsk
    }

    // Take field
    pub fn take_nsk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nsk, ::std::vec::Vec::new())
    }

    // bytes ovk = 4;


    pub fn get_ovk(&self) -> &[u8] {
        &self.ovk
    }
    pub fn clear_ovk(&mut self) {
        self.ovk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ovk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ovk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ovk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ovk
    }

    // Take field
    pub fn take_ovk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ovk, ::std::vec::Vec::new())
    }

    // int64 from_amount = 5;


    pub fn get_from_amount(&self) -> i64 {
        self.from_amount
    }
    pub fn clear_from_amount(&mut self) {
        self.from_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_amount(&mut self, v: i64) {
        self.from_amount = v;
    }

    // repeated .protocol.SpendNote shielded_spends = 6;


    pub fn get_shielded_spends(&self) -> &[SpendNote] {
        &self.shielded_spends
    }
    pub fn clear_shielded_spends(&mut self) {
        self.shielded_spends.clear();
    }

    // Param is passed by value, moved
    pub fn set_shielded_spends(&mut self, v: ::protobuf::RepeatedField<SpendNote>) {
        self.shielded_spends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shielded_spends(&mut self) -> &mut ::protobuf::RepeatedField<SpendNote> {
        &mut self.shielded_spends
    }

    // Take field
    pub fn take_shielded_spends(&mut self) -> ::protobuf::RepeatedField<SpendNote> {
        ::std::mem::replace(&mut self.shielded_spends, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.ReceiveNote shielded_receives = 7;


    pub fn get_shielded_receives(&self) -> &[ReceiveNote] {
        &self.shielded_receives
    }
    pub fn clear_shielded_receives(&mut self) {
        self.shielded_receives.clear();
    }

    // Param is passed by value, moved
    pub fn set_shielded_receives(&mut self, v: ::protobuf::RepeatedField<ReceiveNote>) {
        self.shielded_receives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shielded_receives(&mut self) -> &mut ::protobuf::RepeatedField<ReceiveNote> {
        &mut self.shielded_receives
    }

    // Take field
    pub fn take_shielded_receives(&mut self) -> ::protobuf::RepeatedField<ReceiveNote> {
        ::std::mem::replace(&mut self.shielded_receives, ::protobuf::RepeatedField::new())
    }

    // bytes transparent_to_address = 8;


    pub fn get_transparent_to_address(&self) -> &[u8] {
        &self.transparent_to_address
    }
    pub fn clear_transparent_to_address(&mut self) {
        self.transparent_to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_transparent_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.transparent_to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transparent_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transparent_to_address
    }

    // Take field
    pub fn take_transparent_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transparent_to_address, ::std::vec::Vec::new())
    }

    // int64 to_amount = 9;


    pub fn get_to_amount(&self) -> i64 {
        self.to_amount
    }
    pub fn clear_to_amount(&mut self) {
        self.to_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_amount(&mut self, v: i64) {
        self.to_amount = v;
    }
}

impl ::protobuf::Message for PrivateParametersWithoutAsk {
    fn is_initialized(&self) -> bool {
        for v in &self.shielded_spends {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shielded_receives {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transparent_from_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ak)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nsk)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ovk)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.from_amount = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shielded_spends)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shielded_receives)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transparent_to_address)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.to_amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transparent_from_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transparent_from_address);
        }
        if !self.ak.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ak);
        }
        if !self.nsk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.nsk);
        }
        if !self.ovk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.ovk);
        }
        if self.from_amount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.from_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.shielded_spends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.shielded_receives {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.transparent_to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.transparent_to_address);
        }
        if self.to_amount != 0 {
            my_size += ::protobuf::rt::value_size(9, self.to_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.transparent_from_address.is_empty() {
            os.write_bytes(1, &self.transparent_from_address)?;
        }
        if !self.ak.is_empty() {
            os.write_bytes(2, &self.ak)?;
        }
        if !self.nsk.is_empty() {
            os.write_bytes(3, &self.nsk)?;
        }
        if !self.ovk.is_empty() {
            os.write_bytes(4, &self.ovk)?;
        }
        if self.from_amount != 0 {
            os.write_int64(5, self.from_amount)?;
        }
        for v in &self.shielded_spends {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.shielded_receives {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.transparent_to_address.is_empty() {
            os.write_bytes(8, &self.transparent_to_address)?;
        }
        if self.to_amount != 0 {
            os.write_int64(9, self.to_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrivateParametersWithoutAsk {
        PrivateParametersWithoutAsk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transparent_from_address",
                |m: &PrivateParametersWithoutAsk| { &m.transparent_from_address },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.transparent_from_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ak",
                |m: &PrivateParametersWithoutAsk| { &m.ak },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.ak },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nsk",
                |m: &PrivateParametersWithoutAsk| { &m.nsk },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.nsk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ovk",
                |m: &PrivateParametersWithoutAsk| { &m.ovk },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.ovk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "from_amount",
                |m: &PrivateParametersWithoutAsk| { &m.from_amount },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.from_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpendNote>>(
                "shielded_spends",
                |m: &PrivateParametersWithoutAsk| { &m.shielded_spends },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.shielded_spends },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceiveNote>>(
                "shielded_receives",
                |m: &PrivateParametersWithoutAsk| { &m.shielded_receives },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.shielded_receives },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transparent_to_address",
                |m: &PrivateParametersWithoutAsk| { &m.transparent_to_address },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.transparent_to_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "to_amount",
                |m: &PrivateParametersWithoutAsk| { &m.to_amount },
                |m: &mut PrivateParametersWithoutAsk| { &mut m.to_amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrivateParametersWithoutAsk>(
                "PrivateParametersWithoutAsk",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrivateParametersWithoutAsk {
        static instance: ::protobuf::rt::LazyV2<PrivateParametersWithoutAsk> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrivateParametersWithoutAsk::new)
    }
}

impl ::protobuf::Clear for PrivateParametersWithoutAsk {
    fn clear(&mut self) {
        self.transparent_from_address.clear();
        self.ak.clear();
        self.nsk.clear();
        self.ovk.clear();
        self.from_amount = 0;
        self.shielded_spends.clear();
        self.shielded_receives.clear();
        self.transparent_to_address.clear();
        self.to_amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrivateParametersWithoutAsk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrivateParametersWithoutAsk {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SpendAuthSigParameters {
    // message fields
    pub ask: ::std::vec::Vec<u8>,
    pub tx_hash: ::std::vec::Vec<u8>,
    pub alpha: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpendAuthSigParameters {
    fn default() -> &'a SpendAuthSigParameters {
        <SpendAuthSigParameters as ::protobuf::Message>::default_instance()
    }
}

impl SpendAuthSigParameters {
    pub fn new() -> SpendAuthSigParameters {
        ::std::default::Default::default()
    }

    // bytes ask = 1;


    pub fn get_ask(&self) -> &[u8] {
        &self.ask
    }
    pub fn clear_ask(&mut self) {
        self.ask.clear();
    }

    // Param is passed by value, moved
    pub fn set_ask(&mut self, v: ::std::vec::Vec<u8>) {
        self.ask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ask(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ask
    }

    // Take field
    pub fn take_ask(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ask, ::std::vec::Vec::new())
    }

    // bytes tx_hash = 2;


    pub fn get_tx_hash(&self) -> &[u8] {
        &self.tx_hash
    }
    pub fn clear_tx_hash(&mut self) {
        self.tx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tx_hash
    }

    // Take field
    pub fn take_tx_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tx_hash, ::std::vec::Vec::new())
    }

    // bytes alpha = 3;


    pub fn get_alpha(&self) -> &[u8] {
        &self.alpha
    }
    pub fn clear_alpha(&mut self) {
        self.alpha.clear();
    }

    // Param is passed by value, moved
    pub fn set_alpha(&mut self, v: ::std::vec::Vec<u8>) {
        self.alpha = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alpha(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.alpha
    }

    // Take field
    pub fn take_alpha(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.alpha, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SpendAuthSigParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ask)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tx_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.alpha)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ask.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ask);
        }
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tx_hash);
        }
        if !self.alpha.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.alpha);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ask.is_empty() {
            os.write_bytes(1, &self.ask)?;
        }
        if !self.tx_hash.is_empty() {
            os.write_bytes(2, &self.tx_hash)?;
        }
        if !self.alpha.is_empty() {
            os.write_bytes(3, &self.alpha)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpendAuthSigParameters {
        SpendAuthSigParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ask",
                |m: &SpendAuthSigParameters| { &m.ask },
                |m: &mut SpendAuthSigParameters| { &mut m.ask },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_hash",
                |m: &SpendAuthSigParameters| { &m.tx_hash },
                |m: &mut SpendAuthSigParameters| { &mut m.tx_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "alpha",
                |m: &SpendAuthSigParameters| { &m.alpha },
                |m: &mut SpendAuthSigParameters| { &mut m.alpha },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SpendAuthSigParameters>(
                "SpendAuthSigParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SpendAuthSigParameters {
        static instance: ::protobuf::rt::LazyV2<SpendAuthSigParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpendAuthSigParameters::new)
    }
}

impl ::protobuf::Clear for SpendAuthSigParameters {
    fn clear(&mut self) {
        self.ask.clear();
        self.tx_hash.clear();
        self.alpha.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpendAuthSigParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpendAuthSigParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NfParameters {
    // message fields
    pub note: ::protobuf::SingularPtrField<Note>,
    pub voucher: ::protobuf::SingularPtrField<super::Contract::IncrementalMerkleVoucher>,
    pub ak: ::std::vec::Vec<u8>,
    pub nk: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NfParameters {
    fn default() -> &'a NfParameters {
        <NfParameters as ::protobuf::Message>::default_instance()
    }
}

impl NfParameters {
    pub fn new() -> NfParameters {
        ::std::default::Default::default()
    }

    // .protocol.Note note = 1;


    pub fn get_note(&self) -> &Note {
        self.note.as_ref().unwrap_or_else(|| <Note as ::protobuf::Message>::default_instance())
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: Note) {
        self.note = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut Note {
        if self.note.is_none() {
            self.note.set_default();
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> Note {
        self.note.take().unwrap_or_else(|| Note::new())
    }

    // .protocol.IncrementalMerkleVoucher voucher = 2;


    pub fn get_voucher(&self) -> &super::Contract::IncrementalMerkleVoucher {
        self.voucher.as_ref().unwrap_or_else(|| <super::Contract::IncrementalMerkleVoucher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_voucher(&mut self) {
        self.voucher.clear();
    }

    pub fn has_voucher(&self) -> bool {
        self.voucher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voucher(&mut self, v: super::Contract::IncrementalMerkleVoucher) {
        self.voucher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voucher(&mut self) -> &mut super::Contract::IncrementalMerkleVoucher {
        if self.voucher.is_none() {
            self.voucher.set_default();
        }
        self.voucher.as_mut().unwrap()
    }

    // Take field
    pub fn take_voucher(&mut self) -> super::Contract::IncrementalMerkleVoucher {
        self.voucher.take().unwrap_or_else(|| super::Contract::IncrementalMerkleVoucher::new())
    }

    // bytes ak = 3;


    pub fn get_ak(&self) -> &[u8] {
        &self.ak
    }
    pub fn clear_ak(&mut self) {
        self.ak.clear();
    }

    // Param is passed by value, moved
    pub fn set_ak(&mut self, v: ::std::vec::Vec<u8>) {
        self.ak = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ak(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ak
    }

    // Take field
    pub fn take_ak(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ak, ::std::vec::Vec::new())
    }

    // bytes nk = 4;


    pub fn get_nk(&self) -> &[u8] {
        &self.nk
    }
    pub fn clear_nk(&mut self) {
        self.nk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nk
    }

    // Take field
    pub fn take_nk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nk, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NfParameters {
    fn is_initialized(&self) -> bool {
        for v in &self.note {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voucher {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.note)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.voucher)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ak)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.note.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.voucher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.ak.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ak);
        }
        if !self.nk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.nk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.note.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.voucher.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.ak.is_empty() {
            os.write_bytes(3, &self.ak)?;
        }
        if !self.nk.is_empty() {
            os.write_bytes(4, &self.nk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NfParameters {
        NfParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Note>>(
                "note",
                |m: &NfParameters| { &m.note },
                |m: &mut NfParameters| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Contract::IncrementalMerkleVoucher>>(
                "voucher",
                |m: &NfParameters| { &m.voucher },
                |m: &mut NfParameters| { &mut m.voucher },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ak",
                |m: &NfParameters| { &m.ak },
                |m: &mut NfParameters| { &mut m.ak },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nk",
                |m: &NfParameters| { &m.nk },
                |m: &mut NfParameters| { &mut m.nk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NfParameters>(
                "NfParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NfParameters {
        static instance: ::protobuf::rt::LazyV2<NfParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NfParameters::new)
    }
}

impl ::protobuf::Clear for NfParameters {
    fn clear(&mut self) {
        self.note.clear();
        self.voucher.clear();
        self.ak.clear();
        self.nk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NfParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NfParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExpandedSpendingKeyMessage {
    // message fields
    pub ask: ::std::vec::Vec<u8>,
    pub nsk: ::std::vec::Vec<u8>,
    pub ovk: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExpandedSpendingKeyMessage {
    fn default() -> &'a ExpandedSpendingKeyMessage {
        <ExpandedSpendingKeyMessage as ::protobuf::Message>::default_instance()
    }
}

impl ExpandedSpendingKeyMessage {
    pub fn new() -> ExpandedSpendingKeyMessage {
        ::std::default::Default::default()
    }

    // bytes ask = 1;


    pub fn get_ask(&self) -> &[u8] {
        &self.ask
    }
    pub fn clear_ask(&mut self) {
        self.ask.clear();
    }

    // Param is passed by value, moved
    pub fn set_ask(&mut self, v: ::std::vec::Vec<u8>) {
        self.ask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ask(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ask
    }

    // Take field
    pub fn take_ask(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ask, ::std::vec::Vec::new())
    }

    // bytes nsk = 2;


    pub fn get_nsk(&self) -> &[u8] {
        &self.nsk
    }
    pub fn clear_nsk(&mut self) {
        self.nsk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nsk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nsk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nsk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nsk
    }

    // Take field
    pub fn take_nsk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nsk, ::std::vec::Vec::new())
    }

    // bytes ovk = 3;


    pub fn get_ovk(&self) -> &[u8] {
        &self.ovk
    }
    pub fn clear_ovk(&mut self) {
        self.ovk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ovk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ovk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ovk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ovk
    }

    // Take field
    pub fn take_ovk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ovk, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ExpandedSpendingKeyMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ask)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nsk)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ovk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ask.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ask);
        }
        if !self.nsk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.nsk);
        }
        if !self.ovk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ovk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ask.is_empty() {
            os.write_bytes(1, &self.ask)?;
        }
        if !self.nsk.is_empty() {
            os.write_bytes(2, &self.nsk)?;
        }
        if !self.ovk.is_empty() {
            os.write_bytes(3, &self.ovk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExpandedSpendingKeyMessage {
        ExpandedSpendingKeyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ask",
                |m: &ExpandedSpendingKeyMessage| { &m.ask },
                |m: &mut ExpandedSpendingKeyMessage| { &mut m.ask },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nsk",
                |m: &ExpandedSpendingKeyMessage| { &m.nsk },
                |m: &mut ExpandedSpendingKeyMessage| { &mut m.nsk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ovk",
                |m: &ExpandedSpendingKeyMessage| { &m.ovk },
                |m: &mut ExpandedSpendingKeyMessage| { &mut m.ovk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExpandedSpendingKeyMessage>(
                "ExpandedSpendingKeyMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExpandedSpendingKeyMessage {
        static instance: ::protobuf::rt::LazyV2<ExpandedSpendingKeyMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExpandedSpendingKeyMessage::new)
    }
}

impl ::protobuf::Clear for ExpandedSpendingKeyMessage {
    fn clear(&mut self) {
        self.ask.clear();
        self.nsk.clear();
        self.ovk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExpandedSpendingKeyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExpandedSpendingKeyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ViewingKeyMessage {
    // message fields
    pub ak: ::std::vec::Vec<u8>,
    pub nk: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ViewingKeyMessage {
    fn default() -> &'a ViewingKeyMessage {
        <ViewingKeyMessage as ::protobuf::Message>::default_instance()
    }
}

impl ViewingKeyMessage {
    pub fn new() -> ViewingKeyMessage {
        ::std::default::Default::default()
    }

    // bytes ak = 1;


    pub fn get_ak(&self) -> &[u8] {
        &self.ak
    }
    pub fn clear_ak(&mut self) {
        self.ak.clear();
    }

    // Param is passed by value, moved
    pub fn set_ak(&mut self, v: ::std::vec::Vec<u8>) {
        self.ak = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ak(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ak
    }

    // Take field
    pub fn take_ak(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ak, ::std::vec::Vec::new())
    }

    // bytes nk = 2;


    pub fn get_nk(&self) -> &[u8] {
        &self.nk
    }
    pub fn clear_nk(&mut self) {
        self.nk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nk
    }

    // Take field
    pub fn take_nk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nk, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ViewingKeyMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ak)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ak.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ak);
        }
        if !self.nk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.nk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ak.is_empty() {
            os.write_bytes(1, &self.ak)?;
        }
        if !self.nk.is_empty() {
            os.write_bytes(2, &self.nk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ViewingKeyMessage {
        ViewingKeyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ak",
                |m: &ViewingKeyMessage| { &m.ak },
                |m: &mut ViewingKeyMessage| { &mut m.ak },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nk",
                |m: &ViewingKeyMessage| { &m.nk },
                |m: &mut ViewingKeyMessage| { &mut m.nk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ViewingKeyMessage>(
                "ViewingKeyMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ViewingKeyMessage {
        static instance: ::protobuf::rt::LazyV2<ViewingKeyMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ViewingKeyMessage::new)
    }
}

impl ::protobuf::Clear for ViewingKeyMessage {
    fn clear(&mut self) {
        self.ak.clear();
        self.nk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ViewingKeyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ViewingKeyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IncomingViewingKeyMessage {
    // message fields
    pub ivk: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IncomingViewingKeyMessage {
    fn default() -> &'a IncomingViewingKeyMessage {
        <IncomingViewingKeyMessage as ::protobuf::Message>::default_instance()
    }
}

impl IncomingViewingKeyMessage {
    pub fn new() -> IncomingViewingKeyMessage {
        ::std::default::Default::default()
    }

    // bytes ivk = 1;


    pub fn get_ivk(&self) -> &[u8] {
        &self.ivk
    }
    pub fn clear_ivk(&mut self) {
        self.ivk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ivk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ivk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ivk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ivk
    }

    // Take field
    pub fn take_ivk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ivk, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IncomingViewingKeyMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ivk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ivk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ivk);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ivk.is_empty() {
            os.write_bytes(1, &self.ivk)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IncomingViewingKeyMessage {
        IncomingViewingKeyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ivk",
                |m: &IncomingViewingKeyMessage| { &m.ivk },
                |m: &mut IncomingViewingKeyMessage| { &mut m.ivk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IncomingViewingKeyMessage>(
                "IncomingViewingKeyMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IncomingViewingKeyMessage {
        static instance: ::protobuf::rt::LazyV2<IncomingViewingKeyMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IncomingViewingKeyMessage::new)
    }
}

impl ::protobuf::Clear for IncomingViewingKeyMessage {
    fn clear(&mut self) {
        self.ivk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IncomingViewingKeyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IncomingViewingKeyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DiversifierMessage {
    // message fields
    pub d: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DiversifierMessage {
    fn default() -> &'a DiversifierMessage {
        <DiversifierMessage as ::protobuf::Message>::default_instance()
    }
}

impl DiversifierMessage {
    pub fn new() -> DiversifierMessage {
        ::std::default::Default::default()
    }

    // bytes d = 1;


    pub fn get_d(&self) -> &[u8] {
        &self.d
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: ::std::vec::Vec<u8>) {
        self.d = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.d
    }

    // Take field
    pub fn take_d(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.d, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DiversifierMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.d)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.d.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.d);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.d.is_empty() {
            os.write_bytes(1, &self.d)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiversifierMessage {
        DiversifierMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "d",
                |m: &DiversifierMessage| { &m.d },
                |m: &mut DiversifierMessage| { &mut m.d },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DiversifierMessage>(
                "DiversifierMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DiversifierMessage {
        static instance: ::protobuf::rt::LazyV2<DiversifierMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DiversifierMessage::new)
    }
}

impl ::protobuf::Clear for DiversifierMessage {
    fn clear(&mut self) {
        self.d.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiversifierMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiversifierMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IncomingViewingKeyDiversifierMessage {
    // message fields
    pub ivk: ::protobuf::SingularPtrField<IncomingViewingKeyMessage>,
    pub d: ::protobuf::SingularPtrField<DiversifierMessage>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IncomingViewingKeyDiversifierMessage {
    fn default() -> &'a IncomingViewingKeyDiversifierMessage {
        <IncomingViewingKeyDiversifierMessage as ::protobuf::Message>::default_instance()
    }
}

impl IncomingViewingKeyDiversifierMessage {
    pub fn new() -> IncomingViewingKeyDiversifierMessage {
        ::std::default::Default::default()
    }

    // .protocol.IncomingViewingKeyMessage ivk = 1;


    pub fn get_ivk(&self) -> &IncomingViewingKeyMessage {
        self.ivk.as_ref().unwrap_or_else(|| <IncomingViewingKeyMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ivk(&mut self) {
        self.ivk.clear();
    }

    pub fn has_ivk(&self) -> bool {
        self.ivk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ivk(&mut self, v: IncomingViewingKeyMessage) {
        self.ivk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ivk(&mut self) -> &mut IncomingViewingKeyMessage {
        if self.ivk.is_none() {
            self.ivk.set_default();
        }
        self.ivk.as_mut().unwrap()
    }

    // Take field
    pub fn take_ivk(&mut self) -> IncomingViewingKeyMessage {
        self.ivk.take().unwrap_or_else(|| IncomingViewingKeyMessage::new())
    }

    // .protocol.DiversifierMessage d = 2;


    pub fn get_d(&self) -> &DiversifierMessage {
        self.d.as_ref().unwrap_or_else(|| <DiversifierMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: DiversifierMessage) {
        self.d = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut DiversifierMessage {
        if self.d.is_none() {
            self.d.set_default();
        }
        self.d.as_mut().unwrap()
    }

    // Take field
    pub fn take_d(&mut self) -> DiversifierMessage {
        self.d.take().unwrap_or_else(|| DiversifierMessage::new())
    }
}

impl ::protobuf::Message for IncomingViewingKeyDiversifierMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.ivk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.d {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ivk)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ivk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ivk.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.d.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IncomingViewingKeyDiversifierMessage {
        IncomingViewingKeyDiversifierMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IncomingViewingKeyMessage>>(
                "ivk",
                |m: &IncomingViewingKeyDiversifierMessage| { &m.ivk },
                |m: &mut IncomingViewingKeyDiversifierMessage| { &mut m.ivk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiversifierMessage>>(
                "d",
                |m: &IncomingViewingKeyDiversifierMessage| { &m.d },
                |m: &mut IncomingViewingKeyDiversifierMessage| { &mut m.d },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IncomingViewingKeyDiversifierMessage>(
                "IncomingViewingKeyDiversifierMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IncomingViewingKeyDiversifierMessage {
        static instance: ::protobuf::rt::LazyV2<IncomingViewingKeyDiversifierMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IncomingViewingKeyDiversifierMessage::new)
    }
}

impl ::protobuf::Clear for IncomingViewingKeyDiversifierMessage {
    fn clear(&mut self) {
        self.ivk.clear();
        self.d.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IncomingViewingKeyDiversifierMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IncomingViewingKeyDiversifierMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PaymentAddressMessage {
    // message fields
    pub d: ::protobuf::SingularPtrField<DiversifierMessage>,
    pub pkD: ::std::vec::Vec<u8>,
    pub payment_address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaymentAddressMessage {
    fn default() -> &'a PaymentAddressMessage {
        <PaymentAddressMessage as ::protobuf::Message>::default_instance()
    }
}

impl PaymentAddressMessage {
    pub fn new() -> PaymentAddressMessage {
        ::std::default::Default::default()
    }

    // .protocol.DiversifierMessage d = 1;


    pub fn get_d(&self) -> &DiversifierMessage {
        self.d.as_ref().unwrap_or_else(|| <DiversifierMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: DiversifierMessage) {
        self.d = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut DiversifierMessage {
        if self.d.is_none() {
            self.d.set_default();
        }
        self.d.as_mut().unwrap()
    }

    // Take field
    pub fn take_d(&mut self) -> DiversifierMessage {
        self.d.take().unwrap_or_else(|| DiversifierMessage::new())
    }

    // bytes pkD = 2;


    pub fn get_pkD(&self) -> &[u8] {
        &self.pkD
    }
    pub fn clear_pkD(&mut self) {
        self.pkD.clear();
    }

    // Param is passed by value, moved
    pub fn set_pkD(&mut self, v: ::std::vec::Vec<u8>) {
        self.pkD = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pkD(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pkD
    }

    // Take field
    pub fn take_pkD(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pkD, ::std::vec::Vec::new())
    }

    // string payment_address = 3;


    pub fn get_payment_address(&self) -> &str {
        &self.payment_address
    }
    pub fn clear_payment_address(&mut self) {
        self.payment_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_address(&mut self, v: ::std::string::String) {
        self.payment_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_address(&mut self) -> &mut ::std::string::String {
        &mut self.payment_address
    }

    // Take field
    pub fn take_payment_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PaymentAddressMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.d {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.d)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pkD)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.pkD.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pkD);
        }
        if !self.payment_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.payment_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.d.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.pkD.is_empty() {
            os.write_bytes(2, &self.pkD)?;
        }
        if !self.payment_address.is_empty() {
            os.write_string(3, &self.payment_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaymentAddressMessage {
        PaymentAddressMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DiversifierMessage>>(
                "d",
                |m: &PaymentAddressMessage| { &m.d },
                |m: &mut PaymentAddressMessage| { &mut m.d },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pkD",
                |m: &PaymentAddressMessage| { &m.pkD },
                |m: &mut PaymentAddressMessage| { &mut m.pkD },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_address",
                |m: &PaymentAddressMessage| { &m.payment_address },
                |m: &mut PaymentAddressMessage| { &mut m.payment_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaymentAddressMessage>(
                "PaymentAddressMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaymentAddressMessage {
        static instance: ::protobuf::rt::LazyV2<PaymentAddressMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaymentAddressMessage::new)
    }
}

impl ::protobuf::Clear for PaymentAddressMessage {
    fn clear(&mut self) {
        self.d.clear();
        self.pkD.clear();
        self.payment_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaymentAddressMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentAddressMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ShieldedAddressInfo {
    // message fields
    pub sk: ::std::vec::Vec<u8>,
    pub ask: ::std::vec::Vec<u8>,
    pub nsk: ::std::vec::Vec<u8>,
    pub ovk: ::std::vec::Vec<u8>,
    pub ak: ::std::vec::Vec<u8>,
    pub nk: ::std::vec::Vec<u8>,
    pub ivk: ::std::vec::Vec<u8>,
    pub d: ::std::vec::Vec<u8>,
    pub pkD: ::std::vec::Vec<u8>,
    pub payment_address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShieldedAddressInfo {
    fn default() -> &'a ShieldedAddressInfo {
        <ShieldedAddressInfo as ::protobuf::Message>::default_instance()
    }
}

impl ShieldedAddressInfo {
    pub fn new() -> ShieldedAddressInfo {
        ::std::default::Default::default()
    }

    // bytes sk = 1;


    pub fn get_sk(&self) -> &[u8] {
        &self.sk
    }
    pub fn clear_sk(&mut self) {
        self.sk.clear();
    }

    // Param is passed by value, moved
    pub fn set_sk(&mut self, v: ::std::vec::Vec<u8>) {
        self.sk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sk
    }

    // Take field
    pub fn take_sk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sk, ::std::vec::Vec::new())
    }

    // bytes ask = 2;


    pub fn get_ask(&self) -> &[u8] {
        &self.ask
    }
    pub fn clear_ask(&mut self) {
        self.ask.clear();
    }

    // Param is passed by value, moved
    pub fn set_ask(&mut self, v: ::std::vec::Vec<u8>) {
        self.ask = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ask(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ask
    }

    // Take field
    pub fn take_ask(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ask, ::std::vec::Vec::new())
    }

    // bytes nsk = 3;


    pub fn get_nsk(&self) -> &[u8] {
        &self.nsk
    }
    pub fn clear_nsk(&mut self) {
        self.nsk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nsk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nsk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nsk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nsk
    }

    // Take field
    pub fn take_nsk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nsk, ::std::vec::Vec::new())
    }

    // bytes ovk = 4;


    pub fn get_ovk(&self) -> &[u8] {
        &self.ovk
    }
    pub fn clear_ovk(&mut self) {
        self.ovk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ovk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ovk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ovk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ovk
    }

    // Take field
    pub fn take_ovk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ovk, ::std::vec::Vec::new())
    }

    // bytes ak = 5;


    pub fn get_ak(&self) -> &[u8] {
        &self.ak
    }
    pub fn clear_ak(&mut self) {
        self.ak.clear();
    }

    // Param is passed by value, moved
    pub fn set_ak(&mut self, v: ::std::vec::Vec<u8>) {
        self.ak = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ak(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ak
    }

    // Take field
    pub fn take_ak(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ak, ::std::vec::Vec::new())
    }

    // bytes nk = 6;


    pub fn get_nk(&self) -> &[u8] {
        &self.nk
    }
    pub fn clear_nk(&mut self) {
        self.nk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nk
    }

    // Take field
    pub fn take_nk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nk, ::std::vec::Vec::new())
    }

    // bytes ivk = 7;


    pub fn get_ivk(&self) -> &[u8] {
        &self.ivk
    }
    pub fn clear_ivk(&mut self) {
        self.ivk.clear();
    }

    // Param is passed by value, moved
    pub fn set_ivk(&mut self, v: ::std::vec::Vec<u8>) {
        self.ivk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ivk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ivk
    }

    // Take field
    pub fn take_ivk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ivk, ::std::vec::Vec::new())
    }

    // bytes d = 8;


    pub fn get_d(&self) -> &[u8] {
        &self.d
    }
    pub fn clear_d(&mut self) {
        self.d.clear();
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: ::std::vec::Vec<u8>) {
        self.d = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_d(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.d
    }

    // Take field
    pub fn take_d(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.d, ::std::vec::Vec::new())
    }

    // bytes pkD = 9;


    pub fn get_pkD(&self) -> &[u8] {
        &self.pkD
    }
    pub fn clear_pkD(&mut self) {
        self.pkD.clear();
    }

    // Param is passed by value, moved
    pub fn set_pkD(&mut self, v: ::std::vec::Vec<u8>) {
        self.pkD = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pkD(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pkD
    }

    // Take field
    pub fn take_pkD(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pkD, ::std::vec::Vec::new())
    }

    // string payment_address = 10;


    pub fn get_payment_address(&self) -> &str {
        &self.payment_address
    }
    pub fn clear_payment_address(&mut self) {
        self.payment_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_payment_address(&mut self, v: ::std::string::String) {
        self.payment_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_address(&mut self) -> &mut ::std::string::String {
        &mut self.payment_address
    }

    // Take field
    pub fn take_payment_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payment_address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ShieldedAddressInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sk)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ask)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nsk)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ovk)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ak)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nk)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ivk)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.d)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pkD)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payment_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sk);
        }
        if !self.ask.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ask);
        }
        if !self.nsk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.nsk);
        }
        if !self.ovk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.ovk);
        }
        if !self.ak.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.ak);
        }
        if !self.nk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.nk);
        }
        if !self.ivk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.ivk);
        }
        if !self.d.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.d);
        }
        if !self.pkD.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.pkD);
        }
        if !self.payment_address.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.payment_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sk.is_empty() {
            os.write_bytes(1, &self.sk)?;
        }
        if !self.ask.is_empty() {
            os.write_bytes(2, &self.ask)?;
        }
        if !self.nsk.is_empty() {
            os.write_bytes(3, &self.nsk)?;
        }
        if !self.ovk.is_empty() {
            os.write_bytes(4, &self.ovk)?;
        }
        if !self.ak.is_empty() {
            os.write_bytes(5, &self.ak)?;
        }
        if !self.nk.is_empty() {
            os.write_bytes(6, &self.nk)?;
        }
        if !self.ivk.is_empty() {
            os.write_bytes(7, &self.ivk)?;
        }
        if !self.d.is_empty() {
            os.write_bytes(8, &self.d)?;
        }
        if !self.pkD.is_empty() {
            os.write_bytes(9, &self.pkD)?;
        }
        if !self.payment_address.is_empty() {
            os.write_string(10, &self.payment_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShieldedAddressInfo {
        ShieldedAddressInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sk",
                |m: &ShieldedAddressInfo| { &m.sk },
                |m: &mut ShieldedAddressInfo| { &mut m.sk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ask",
                |m: &ShieldedAddressInfo| { &m.ask },
                |m: &mut ShieldedAddressInfo| { &mut m.ask },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nsk",
                |m: &ShieldedAddressInfo| { &m.nsk },
                |m: &mut ShieldedAddressInfo| { &mut m.nsk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ovk",
                |m: &ShieldedAddressInfo| { &m.ovk },
                |m: &mut ShieldedAddressInfo| { &mut m.ovk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ak",
                |m: &ShieldedAddressInfo| { &m.ak },
                |m: &mut ShieldedAddressInfo| { &mut m.ak },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nk",
                |m: &ShieldedAddressInfo| { &m.nk },
                |m: &mut ShieldedAddressInfo| { &mut m.nk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ivk",
                |m: &ShieldedAddressInfo| { &m.ivk },
                |m: &mut ShieldedAddressInfo| { &mut m.ivk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "d",
                |m: &ShieldedAddressInfo| { &m.d },
                |m: &mut ShieldedAddressInfo| { &mut m.d },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pkD",
                |m: &ShieldedAddressInfo| { &m.pkD },
                |m: &mut ShieldedAddressInfo| { &mut m.pkD },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payment_address",
                |m: &ShieldedAddressInfo| { &m.payment_address },
                |m: &mut ShieldedAddressInfo| { &mut m.payment_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShieldedAddressInfo>(
                "ShieldedAddressInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShieldedAddressInfo {
        static instance: ::protobuf::rt::LazyV2<ShieldedAddressInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShieldedAddressInfo::new)
    }
}

impl ::protobuf::Clear for ShieldedAddressInfo {
    fn clear(&mut self) {
        self.sk.clear();
        self.ask.clear();
        self.nsk.clear();
        self.ovk.clear();
        self.ak.clear();
        self.nk.clear();
        self.ivk.clear();
        self.d.clear();
        self.pkD.clear();
        self.payment_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShieldedAddressInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShieldedAddressInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NoteParameters {
    // message fields
    pub ak: ::std::vec::Vec<u8>,
    pub nk: ::std::vec::Vec<u8>,
    pub note: ::protobuf::SingularPtrField<Note>,
    pub txid: ::std::vec::Vec<u8>,
    pub index: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NoteParameters {
    fn default() -> &'a NoteParameters {
        <NoteParameters as ::protobuf::Message>::default_instance()
    }
}

impl NoteParameters {
    pub fn new() -> NoteParameters {
        ::std::default::Default::default()
    }

    // bytes ak = 1;


    pub fn get_ak(&self) -> &[u8] {
        &self.ak
    }
    pub fn clear_ak(&mut self) {
        self.ak.clear();
    }

    // Param is passed by value, moved
    pub fn set_ak(&mut self, v: ::std::vec::Vec<u8>) {
        self.ak = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ak(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ak
    }

    // Take field
    pub fn take_ak(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ak, ::std::vec::Vec::new())
    }

    // bytes nk = 2;


    pub fn get_nk(&self) -> &[u8] {
        &self.nk
    }
    pub fn clear_nk(&mut self) {
        self.nk.clear();
    }

    // Param is passed by value, moved
    pub fn set_nk(&mut self, v: ::std::vec::Vec<u8>) {
        self.nk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nk
    }

    // Take field
    pub fn take_nk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nk, ::std::vec::Vec::new())
    }

    // .protocol.Note note = 3;


    pub fn get_note(&self) -> &Note {
        self.note.as_ref().unwrap_or_else(|| <Note as ::protobuf::Message>::default_instance())
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: Note) {
        self.note = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut Note {
        if self.note.is_none() {
            self.note.set_default();
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> Note {
        self.note.take().unwrap_or_else(|| Note::new())
    }

    // bytes txid = 4;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // int32 index = 5;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }
}

impl ::protobuf::Message for NoteParameters {
    fn is_initialized(&self) -> bool {
        for v in &self.note {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ak)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nk)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.note)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ak.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ak);
        }
        if !self.nk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.nk);
        }
        if let Some(ref v) = self.note.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.txid);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(5, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ak.is_empty() {
            os.write_bytes(1, &self.ak)?;
        }
        if !self.nk.is_empty() {
            os.write_bytes(2, &self.nk)?;
        }
        if let Some(ref v) = self.note.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(4, &self.txid)?;
        }
        if self.index != 0 {
            os.write_int32(5, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NoteParameters {
        NoteParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ak",
                |m: &NoteParameters| { &m.ak },
                |m: &mut NoteParameters| { &mut m.ak },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nk",
                |m: &NoteParameters| { &m.nk },
                |m: &mut NoteParameters| { &mut m.nk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Note>>(
                "note",
                |m: &NoteParameters| { &m.note },
                |m: &mut NoteParameters| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txid",
                |m: &NoteParameters| { &m.txid },
                |m: &mut NoteParameters| { &mut m.txid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &NoteParameters| { &m.index },
                |m: &mut NoteParameters| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NoteParameters>(
                "NoteParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NoteParameters {
        static instance: ::protobuf::rt::LazyV2<NoteParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NoteParameters::new)
    }
}

impl ::protobuf::Clear for NoteParameters {
    fn clear(&mut self) {
        self.ak.clear();
        self.nk.clear();
        self.note.clear();
        self.txid.clear();
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NoteParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoteParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SpendResult {
    // message fields
    pub result: bool,
    pub message: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpendResult {
    fn default() -> &'a SpendResult {
        <SpendResult as ::protobuf::Message>::default_instance()
    }
}

impl SpendResult {
    pub fn new() -> SpendResult {
        ::std::default::Default::default()
    }

    // bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = false;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SpendResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != false {
            os.write_bool(1, self.result)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpendResult {
        SpendResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &SpendResult| { &m.result },
                |m: &mut SpendResult| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &SpendResult| { &m.message },
                |m: &mut SpendResult| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SpendResult>(
                "SpendResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SpendResult {
        static instance: ::protobuf::rt::LazyV2<SpendResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpendResult::new)
    }
}

impl ::protobuf::Clear for SpendResult {
    fn clear(&mut self) {
        self.result = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpendResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpendResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rapi/api.proto\x12\x08protocol\x1a\x0fcore/Tron.proto\x1a\x13core/Con\
    tract.proto\x1a\x1cgoogle/api/annotations.proto\"\xab\x03\n\x06Return\
    \x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\x122\n\x04code\x18\
    \x02\x20\x01(\x0e2\x1e.protocol.Return.response_codeR\x04code\x12\x18\n\
    \x07message\x18\x03\x20\x01(\x0cR\x07message\"\xba\x02\n\rresponse_code\
    \x12\x0b\n\x07SUCCESS\x10\0\x12\x0c\n\x08SIGERROR\x10\x01\x12\x1b\n\x17C\
    ONTRACT_VALIDATE_ERROR\x10\x02\x12\x16\n\x12CONTRACT_EXE_ERROR\x10\x03\
    \x12\x12\n\x0eBANDWITH_ERROR\x10\x04\x12\x19\n\x15DUP_TRANSACTION_ERROR\
    \x10\x05\x12\x0f\n\x0bTAPOS_ERROR\x10\x06\x12\x1d\n\x19TOO_BIG_TRANSACTI\
    ON_ERROR\x10\x07\x12\x20\n\x1cTRANSACTION_EXPIRATION_ERROR\x10\x08\x12\
    \x0f\n\x0bSERVER_BUSY\x10\t\x12\x11\n\rNO_CONNECTION\x10\n\x12#\n\x1fNOT\
    _ENOUGH_EFFECTIVE_CONNECTION\x10\x0b\x12\x0f\n\x0bOTHER_ERROR\x10\x14\"L\
    \n\x0eBlockReference\x12\x1b\n\tblock_num\x18\x01\x20\x01(\x03R\x08block\
    Num\x12\x1d\n\nblock_hash\x18\x02\x20\x01(\x0cR\tblockHash\">\n\x0bWitne\
    ssList\x12/\n\twitnesses\x18\x01\x20\x03(\x0b2\x11.protocol.WitnessR\twi\
    tnesses\"@\n\x0cProposalList\x120\n\tproposals\x18\x01\x20\x03(\x0b2\x12\
    .protocol.ProposalR\tproposals\"@\n\x0cExchangeList\x120\n\texchanges\
    \x18\x01\x20\x03(\x0b2\x12.protocol.ExchangeR\texchanges\"N\n\x0eAssetIs\
    sueList\x12<\n\nassetIssue\x18\x01\x20\x03(\x0b2\x1c.protocol.AssetIssue\
    ContractR\nassetIssue\"2\n\tBlockList\x12%\n\x05block\x18\x01\x20\x03(\
    \x0b2\x0f.protocol.BlockR\x05block\"J\n\x0fTransactionList\x127\n\x0btra\
    nsaction\x18\x01\x20\x03(\x0b2\x15.protocol.TransactionR\x0btransaction\
    \"Z\n\x18DelegatedResourceMessage\x12\x20\n\x0bfromAddress\x18\x01\x20\
    \x01(\x0cR\x0bfromAddress\x12\x1c\n\ttoAddress\x18\x02\x20\x01(\x0cR\tto\
    Address\"b\n\x15DelegatedResourceList\x12I\n\x11delegatedResource\x18\
    \x01\x20\x03(\x0b2\x1b.protocol.DelegatedResourceR\x11delegatedResource\
    \"0\n\x08NodeList\x12$\n\x05nodes\x18\x01\x20\x03(\x0b2\x0e.protocol.Nod\
    eR\x05nodes\"3\n\x04Node\x12+\n\x07address\x18\x01\x20\x01(\x0b2\x11.pro\
    tocol.AddressR\x07address\"1\n\x07Address\x12\x12\n\x04host\x18\x01\x20\
    \x01(\x0cR\x04host\x12\x12\n\x04port\x18\x02\x20\x01(\x05R\x04port\"\x0e\
    \n\x0cEmptyMessage\"!\n\rNumberMessage\x12\x10\n\x03num\x18\x01\x20\x01(\
    \x03R\x03num\"$\n\x0cBytesMessage\x12\x14\n\x05value\x18\x01\x20\x01(\
    \x0cR\x05value\"m\n\x0bTimeMessage\x120\n\x13beginInMilliseconds\x18\x01\
    \x20\x01(\x03R\x13beginInMilliseconds\x12,\n\x11endInMilliseconds\x18\
    \x02\x20\x01(\x03R\x11endInMilliseconds\"@\n\nBlockLimit\x12\x1a\n\x08st\
    artNum\x18\x01\x20\x01(\x03R\x08startNum\x12\x16\n\x06endNum\x18\x02\x20\
    \x01(\x03R\x06endNum\"T\n\x10TransactionLimit\x12$\n\rtransactionId\x18\
    \x01\x20\x01(\x0cR\rtransactionId\x12\x1a\n\x08limitNum\x18\x02\x20\x01(\
    \x03R\x08limitNum\"m\n\x10AccountPaginated\x12+\n\x07account\x18\x01\x20\
    \x01(\x0b2\x11.protocol.AccountR\x07account\x12\x16\n\x06offset\x18\x02\
    \x20\x01(\x03R\x06offset\x12\x14\n\x05limit\x18\x03\x20\x01(\x03R\x05lim\
    it\"}\n\x14TimePaginatedMessage\x127\n\x0btimeMessage\x18\x01\x20\x01(\
    \x0b2\x15.protocol.TimeMessageR\x0btimeMessage\x12\x16\n\x06offset\x18\
    \x02\x20\x01(\x03R\x06offset\x12\x14\n\x05limit\x18\x03\x20\x01(\x03R\
    \x05limit\"\x89\x04\n\x11AccountNetMessage\x12\x20\n\x0bfreeNetUsed\x18\
    \x01\x20\x01(\x03R\x0bfreeNetUsed\x12\"\n\x0cfreeNetLimit\x18\x02\x20\
    \x01(\x03R\x0cfreeNetLimit\x12\x18\n\x07NetUsed\x18\x03\x20\x01(\x03R\
    \x07NetUsed\x12\x1a\n\x08NetLimit\x18\x04\x20\x01(\x03R\x08NetLimit\x12Q\
    \n\x0cassetNetUsed\x18\x05\x20\x03(\x0b2-.protocol.AccountNetMessage.Ass\
    etNetUsedEntryR\x0cassetNetUsed\x12T\n\rassetNetLimit\x18\x06\x20\x03(\
    \x0b2..protocol.AccountNetMessage.AssetNetLimitEntryR\rassetNetLimit\x12\
    $\n\rTotalNetLimit\x18\x07\x20\x01(\x03R\rTotalNetLimit\x12&\n\x0eTotalN\
    etWeight\x18\x08\x20\x01(\x03R\x0eTotalNetWeight\x1a?\n\x11AssetNetUsedE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x03R\x05value:\x028\x01\x1a@\n\x12AssetNetLimitEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x03R\x05value:\x028\x01\"\xfa\x05\n\x16AccountResourceMessage\x12\
    \x20\n\x0bfreeNetUsed\x18\x01\x20\x01(\x03R\x0bfreeNetUsed\x12\"\n\x0cfr\
    eeNetLimit\x18\x02\x20\x01(\x03R\x0cfreeNetLimit\x12\x18\n\x07NetUsed\
    \x18\x03\x20\x01(\x03R\x07NetUsed\x12\x1a\n\x08NetLimit\x18\x04\x20\x01(\
    \x03R\x08NetLimit\x12V\n\x0cassetNetUsed\x18\x05\x20\x03(\x0b22.protocol\
    .AccountResourceMessage.AssetNetUsedEntryR\x0cassetNetUsed\x12Y\n\rasset\
    NetLimit\x18\x06\x20\x03(\x0b23.protocol.AccountResourceMessage.AssetNet\
    LimitEntryR\rassetNetLimit\x12$\n\rTotalNetLimit\x18\x07\x20\x01(\x03R\r\
    TotalNetLimit\x12&\n\x0eTotalNetWeight\x18\x08\x20\x01(\x03R\x0eTotalNet\
    Weight\x12\x1e\n\nEnergyUsed\x18\r\x20\x01(\x03R\nEnergyUsed\x12\x20\n\
    \x0bEnergyLimit\x18\x0e\x20\x01(\x03R\x0bEnergyLimit\x12*\n\x10TotalEner\
    gyLimit\x18\x0f\x20\x01(\x03R\x10TotalEnergyLimit\x12,\n\x11TotalEnergyW\
    eight\x18\x10\x20\x01(\x03R\x11TotalEnergyWeight\x12\x20\n\x0bstorageUse\
    d\x18\x15\x20\x01(\x03R\x0bstorageUsed\x12\"\n\x0cstorageLimit\x18\x16\
    \x20\x01(\x03R\x0cstorageLimit\x1a?\n\x11AssetNetUsedEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\
    \x05value:\x028\x01\x1a@\n\x12AssetNetLimitEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05valu\
    e:\x028\x01\"@\n\x10PaginatedMessage\x12\x16\n\x06offset\x18\x01\x20\x01\
    (\x03R\x06offset\x12\x14\n\x05limit\x18\x02\x20\x01(\x03R\x05limit\"k\n\
    \x13EasyTransferMessage\x12\x1e\n\npassPhrase\x18\x01\x20\x01(\x0cR\npas\
    sPhrase\x12\x1c\n\ttoAddress\x18\x02\x20\x01(\x0cR\ttoAddress\x12\x16\n\
    \x06amount\x18\x03\x20\x01(\x03R\x06amount\"\x8a\x01\n\x18EasyTransferAs\
    setMessage\x12\x1e\n\npassPhrase\x18\x01\x20\x01(\x0cR\npassPhrase\x12\
    \x1c\n\ttoAddress\x18\x02\x20\x01(\x0cR\ttoAddress\x12\x18\n\x07assetId\
    \x18\x03\x20\x01(\tR\x07assetId\x12\x16\n\x06amount\x18\x04\x20\x01(\x03\
    R\x06amount\"t\n\x1cEasyTransferByPrivateMessage\x12\x1e\n\nprivateKey\
    \x18\x01\x20\x01(\x0cR\nprivateKey\x12\x1c\n\ttoAddress\x18\x02\x20\x01(\
    \x0cR\ttoAddress\x12\x16\n\x06amount\x18\x03\x20\x01(\x03R\x06amount\"\
    \x93\x01\n!EasyTransferAssetByPrivateMessage\x12\x1e\n\nprivateKey\x18\
    \x01\x20\x01(\x0cR\nprivateKey\x12\x1c\n\ttoAddress\x18\x02\x20\x01(\x0c\
    R\ttoAddress\x12\x18\n\x07assetId\x18\x03\x20\x01(\tR\x07assetId\x12\x16\
    \n\x06amount\x18\x04\x20\x01(\x03R\x06amount\"\x8d\x01\n\x14EasyTransfer\
    Response\x127\n\x0btransaction\x18\x01\x20\x01(\x0b2\x15.protocol.Transa\
    ctionR\x0btransaction\x12(\n\x06result\x18\x02\x20\x01(\x0b2\x10.protoco\
    l.ReturnR\x06result\x12\x12\n\x04txid\x18\x03\x20\x01(\x0cR\x04txid\"S\n\
    \x17AddressPrKeyPairMessage\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07\
    address\x12\x1e\n\nprivateKey\x18\x02\x20\x01(\tR\nprivateKey\"\xb6\x01\
    \n\x14TransactionExtention\x127\n\x0btransaction\x18\x01\x20\x01(\x0b2\
    \x15.protocol.TransactionR\x0btransaction\x12\x12\n\x04txid\x18\x02\x20\
    \x01(\x0cR\x04txid\x12'\n\x0fconstant_result\x18\x03\x20\x03(\x0cR\x0eco\
    nstantResult\x12(\n\x06result\x18\x04\x20\x01(\x0b2\x10.protocol.ReturnR\
    \x06result\"\xa8\x01\n\x0eBlockExtention\x12B\n\x0ctransactions\x18\x01\
    \x20\x03(\x0b2\x1e.protocol.TransactionExtentionR\x0ctransactions\x128\n\
    \x0cblock_header\x18\x02\x20\x01(\x0b2\x15.protocol.BlockHeaderR\x0bbloc\
    kHeader\x12\x18\n\x07blockid\x18\x03\x20\x01(\x0cR\x07blockid\"D\n\x12Bl\
    ockListExtention\x12.\n\x05block\x18\x01\x20\x03(\x0b2\x18.protocol.Bloc\
    kExtentionR\x05block\"\\\n\x18TransactionListExtention\x12@\n\x0btransac\
    tion\x18\x01\x20\x03(\x0b2\x1e.protocol.TransactionExtentionR\x0btransac\
    tion\"u\n\x1aBlockIncrementalMerkleTree\x12\x16\n\x06number\x18\x01\x20\
    \x01(\x03R\x06number\x12?\n\nmerkleTree\x18\x02\x20\x01(\x0b2\x1f.protoc\
    ol.IncrementalMerkleTreeR\nmerkleTree\"\xac\x04\n\x15TransactionSignWeig\
    ht\x124\n\npermission\x18\x01\x20\x01(\x0b2\x14.protocol.PermissionR\npe\
    rmission\x12#\n\rapproved_list\x18\x02\x20\x03(\x0cR\x0capprovedList\x12\
    %\n\x0ecurrent_weight\x18\x03\x20\x01(\x03R\rcurrentWeight\x12>\n\x06res\
    ult\x18\x04\x20\x01(\x0b2&.protocol.TransactionSignWeight.ResultR\x06res\
    ult\x12@\n\x0btransaction\x18\x05\x20\x01(\x0b2\x1e.protocol.Transaction\
    ExtentionR\x0btransaction\x1a\x8e\x02\n\x06Result\x12H\n\x04code\x18\x01\
    \x20\x01(\x0e24.protocol.TransactionSignWeight.Result.response_codeR\x04\
    code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\x9f\x01\n\rre\
    sponse_code\x12\x15\n\x11ENOUGH_PERMISSION\x10\0\x12\x19\n\x15NOT_ENOUGH\
    _PERMISSION\x10\x01\x12\x1a\n\x16SIGNATURE_FORMAT_ERROR\x10\x02\x12\x19\
    \n\x15COMPUTE_ADDRESS_ERROR\x10\x03\x12\x14\n\x10PERMISSION_ERROR\x10\
    \x04\x12\x0f\n\x0bOTHER_ERROR\x10\x14\"\x99\x03\n\x17TransactionApproved\
    List\x12#\n\rapproved_list\x18\x02\x20\x03(\x0cR\x0capprovedList\x12@\n\
    \x06result\x18\x04\x20\x01(\x0b2(.protocol.TransactionApprovedList.Resul\
    tR\x06result\x12@\n\x0btransaction\x18\x05\x20\x01(\x0b2\x1e.protocol.Tr\
    ansactionExtentionR\x0btransaction\x1a\xd4\x01\n\x06Result\x12J\n\x04cod\
    e\x18\x01\x20\x01(\x0e26.protocol.TransactionApprovedList.Result.respons\
    e_codeR\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"d\n\
    \rresponse_code\x12\x0b\n\x07SUCCESS\x10\0\x12\x1a\n\x16SIGNATURE_FORMAT\
    _ERROR\x10\x01\x12\x19\n\x15COMPUTE_ADDRESS_ERROR\x10\x02\x12\x0f\n\x0bO\
    THER_ERROR\x10\x14\"|\n\x14IvkDecryptParameters\x12*\n\x11start_block_in\
    dex\x18\x01\x20\x01(\x03R\x0fstartBlockIndex\x12&\n\x0fend_block_index\
    \x18\x02\x20\x01(\x03R\rendBlockIndex\x12\x10\n\x03ivk\x18\x03\x20\x01(\
    \x0cR\x03ivk\"\xa3\x01\n\x1bIvkDecryptAndMarkParameters\x12*\n\x11start_\
    block_index\x18\x01\x20\x01(\x03R\x0fstartBlockIndex\x12&\n\x0fend_block\
    _index\x18\x02\x20\x01(\x03R\rendBlockIndex\x12\x10\n\x03ivk\x18\x05\x20\
    \x01(\x0cR\x03ivk\x12\x0e\n\x02ak\x18\x03\x20\x01(\x0cR\x02ak\x12\x0e\n\
    \x02nk\x18\x04\x20\x01(\x0cR\x02nk\"|\n\x14OvkDecryptParameters\x12*\n\
    \x11start_block_index\x18\x01\x20\x01(\x03R\x0fstartBlockIndex\x12&\n\
    \x0fend_block_index\x18\x02\x20\x01(\x03R\rendBlockIndex\x12\x10\n\x03ov\
    k\x18\x03\x20\x01(\x0cR\x03ovk\"\x9f\x01\n\x0cDecryptNotes\x127\n\x07not\
    eTxs\x18\x01\x20\x03(\x0b2\x1d.protocol.DecryptNotes.NoteTxR\x07noteTxs\
    \x1aV\n\x06NoteTx\x12\"\n\x04note\x18\x01\x20\x01(\x0b2\x0e.protocol.Not\
    eR\x04note\x12\x12\n\x04txid\x18\x02\x20\x01(\x0cR\x04txid\x12\x14\n\x05\
    index\x18\x03\x20\x01(\x05R\x05index\"\xc6\x01\n\x12DecryptNotesMarked\
    \x12=\n\x07noteTxs\x18\x01\x20\x03(\x0b2#.protocol.DecryptNotesMarked.No\
    teTxR\x07noteTxs\x1aq\n\x06NoteTx\x12\"\n\x04note\x18\x01\x20\x01(\x0b2\
    \x0e.protocol.NoteR\x04note\x12\x12\n\x04txid\x18\x02\x20\x01(\x0cR\x04t\
    xid\x12\x14\n\x05index\x18\x03\x20\x01(\x05R\x05index\x12\x19\n\x08is_sp\
    end\x18\x04\x20\x01(\x08R\x07isSpend\"k\n\x04Note\x12\x14\n\x05value\x18\
    \x01\x20\x01(\x03R\x05value\x12'\n\x0fpayment_address\x18\x02\x20\x01(\t\
    R\x0epaymentAddress\x12\x10\n\x03rcm\x18\x03\x20\x01(\x0cR\x03rcm\x12\
    \x12\n\x04memo\x18\x04\x20\x01(\x0cR\x04memo\"\x97\x01\n\tSpendNote\x12\
    \"\n\x04note\x18\x03\x20\x01(\x0b2\x0e.protocol.NoteR\x04note\x12\x14\n\
    \x05alpha\x18\x04\x20\x01(\x0cR\x05alpha\x12<\n\x07voucher\x18\x05\x20\
    \x01(\x0b2\".protocol.IncrementalMerkleVoucherR\x07voucher\x12\x12\n\x04\
    path\x18\x06\x20\x01(\x0cR\x04path\"1\n\x0bReceiveNote\x12\"\n\x04note\
    \x18\x01\x20\x01(\x0b2\x0e.protocol.NoteR\x04note\"\xf9\x02\n\x11Private\
    Parameters\x128\n\x18transparent_from_address\x18\x01\x20\x01(\x0cR\x16t\
    ransparentFromAddress\x12\x10\n\x03ask\x18\x02\x20\x01(\x0cR\x03ask\x12\
    \x10\n\x03nsk\x18\x03\x20\x01(\x0cR\x03nsk\x12\x10\n\x03ovk\x18\x04\x20\
    \x01(\x0cR\x03ovk\x12\x1f\n\x0bfrom_amount\x18\x05\x20\x01(\x03R\nfromAm\
    ount\x12<\n\x0fshielded_spends\x18\x06\x20\x03(\x0b2\x13.protocol.SpendN\
    oteR\x0eshieldedSpends\x12B\n\x11shielded_receives\x18\x07\x20\x03(\x0b2\
    \x15.protocol.ReceiveNoteR\x10shieldedReceives\x124\n\x16transparent_to_\
    address\x18\x08\x20\x01(\x0cR\x14transparentToAddress\x12\x1b\n\tto_amou\
    nt\x18\t\x20\x01(\x03R\x08toAmount\"\x81\x03\n\x1bPrivateParametersWitho\
    utAsk\x128\n\x18transparent_from_address\x18\x01\x20\x01(\x0cR\x16transp\
    arentFromAddress\x12\x0e\n\x02ak\x18\x02\x20\x01(\x0cR\x02ak\x12\x10\n\
    \x03nsk\x18\x03\x20\x01(\x0cR\x03nsk\x12\x10\n\x03ovk\x18\x04\x20\x01(\
    \x0cR\x03ovk\x12\x1f\n\x0bfrom_amount\x18\x05\x20\x01(\x03R\nfromAmount\
    \x12<\n\x0fshielded_spends\x18\x06\x20\x03(\x0b2\x13.protocol.SpendNoteR\
    \x0eshieldedSpends\x12B\n\x11shielded_receives\x18\x07\x20\x03(\x0b2\x15\
    .protocol.ReceiveNoteR\x10shieldedReceives\x124\n\x16transparent_to_addr\
    ess\x18\x08\x20\x01(\x0cR\x14transparentToAddress\x12\x1b\n\tto_amount\
    \x18\t\x20\x01(\x03R\x08toAmount\"Y\n\x16SpendAuthSigParameters\x12\x10\
    \n\x03ask\x18\x01\x20\x01(\x0cR\x03ask\x12\x17\n\x07tx_hash\x18\x02\x20\
    \x01(\x0cR\x06txHash\x12\x14\n\x05alpha\x18\x03\x20\x01(\x0cR\x05alpha\"\
    \x90\x01\n\x0cNfParameters\x12\"\n\x04note\x18\x01\x20\x01(\x0b2\x0e.pro\
    tocol.NoteR\x04note\x12<\n\x07voucher\x18\x02\x20\x01(\x0b2\".protocol.I\
    ncrementalMerkleVoucherR\x07voucher\x12\x0e\n\x02ak\x18\x03\x20\x01(\x0c\
    R\x02ak\x12\x0e\n\x02nk\x18\x04\x20\x01(\x0cR\x02nk\"R\n\x1aExpandedSpen\
    dingKeyMessage\x12\x10\n\x03ask\x18\x01\x20\x01(\x0cR\x03ask\x12\x10\n\
    \x03nsk\x18\x02\x20\x01(\x0cR\x03nsk\x12\x10\n\x03ovk\x18\x03\x20\x01(\
    \x0cR\x03ovk\"3\n\x11ViewingKeyMessage\x12\x0e\n\x02ak\x18\x01\x20\x01(\
    \x0cR\x02ak\x12\x0e\n\x02nk\x18\x02\x20\x01(\x0cR\x02nk\"-\n\x19Incoming\
    ViewingKeyMessage\x12\x10\n\x03ivk\x18\x01\x20\x01(\x0cR\x03ivk\"\"\n\
    \x12DiversifierMessage\x12\x0c\n\x01d\x18\x01\x20\x01(\x0cR\x01d\"\x89\
    \x01\n$IncomingViewingKeyDiversifierMessage\x125\n\x03ivk\x18\x01\x20\
    \x01(\x0b2#.protocol.IncomingViewingKeyMessageR\x03ivk\x12*\n\x01d\x18\
    \x02\x20\x01(\x0b2\x1c.protocol.DiversifierMessageR\x01d\"~\n\x15Payment\
    AddressMessage\x12*\n\x01d\x18\x01\x20\x01(\x0b2\x1c.protocol.Diversifie\
    rMessageR\x01d\x12\x10\n\x03pkD\x18\x02\x20\x01(\x0cR\x03pkD\x12'\n\x0fp\
    ayment_address\x18\x03\x20\x01(\tR\x0epaymentAddress\"\xd6\x01\n\x13Shie\
    ldedAddressInfo\x12\x0e\n\x02sk\x18\x01\x20\x01(\x0cR\x02sk\x12\x10\n\
    \x03ask\x18\x02\x20\x01(\x0cR\x03ask\x12\x10\n\x03nsk\x18\x03\x20\x01(\
    \x0cR\x03nsk\x12\x10\n\x03ovk\x18\x04\x20\x01(\x0cR\x03ovk\x12\x0e\n\x02\
    ak\x18\x05\x20\x01(\x0cR\x02ak\x12\x0e\n\x02nk\x18\x06\x20\x01(\x0cR\x02\
    nk\x12\x10\n\x03ivk\x18\x07\x20\x01(\x0cR\x03ivk\x12\x0c\n\x01d\x18\x08\
    \x20\x01(\x0cR\x01d\x12\x10\n\x03pkD\x18\t\x20\x01(\x0cR\x03pkD\x12'\n\
    \x0fpayment_address\x18\n\x20\x01(\tR\x0epaymentAddress\"~\n\x0eNotePara\
    meters\x12\x0e\n\x02ak\x18\x01\x20\x01(\x0cR\x02ak\x12\x0e\n\x02nk\x18\
    \x02\x20\x01(\x0cR\x02nk\x12\"\n\x04note\x18\x03\x20\x01(\x0b2\x0e.proto\
    col.NoteR\x04note\x12\x12\n\x04txid\x18\x04\x20\x01(\x0cR\x04txid\x12\
    \x14\n\x05index\x18\x05\x20\x01(\x05R\x05index\"?\n\x0bSpendResult\x12\
    \x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\x12\x18\n\x07message\
    \x18\x02\x20\x01(\tR\x07message2\x95`\n\x06Wallet\x12g\n\nGetAccount\x12\
    \x11.protocol.Account\x1a\x11.protocol.Account\"3\x82\xd3\xe4\x93\x02-\"\
    \x12/wallet/getaccount:\x01*Z\x14\x12\x12/wallet/getaccount\x12s\n\x0eGe\
    tAccountById\x12\x11.protocol.Account\x1a\x11.protocol.Account\";\x82\
    \xd3\xe4\x93\x025\"\x16/wallet/getaccountbyid:\x01*Z\x18\x12\x16/wallet/\
    getaccountbyid\x12\x89\x01\n\x11CreateTransaction\x12\x1a.protocol.Trans\
    ferContract\x1a\x15.protocol.Transaction\"A\x82\xd3\xe4\x93\x02;\"\x19/w\
    allet/createtransaction:\x01*Z\x1b\x12\x19/wallet/createtransaction\x12R\
    \n\x12CreateTransaction2\x12\x1a.protocol.TransferContract\x1a\x1e.proto\
    col.TransactionExtention\"\0\x12\x88\x01\n\x14BroadcastTransaction\x12\
    \x15.protocol.Transaction\x1a\x10.protocol.Return\"G\x82\xd3\xe4\x93\x02\
    A\"\x1c/wallet/broadcasttransaction:\x01*Z\x1e\x12\x1c/wallet/broadcastt\
    ransaction\x12\x82\x01\n\rUpdateAccount\x12\x1f.protocol.AccountUpdateCo\
    ntract\x1a\x15.protocol.Transaction\"9\x82\xd3\xe4\x93\x023\"\x15/wallet\
    /updateaccount:\x01*Z\x17\x12\x15/wallet/updateaccount\x12~\n\x0cSetAcco\
    untId\x12\x1e.protocol.SetAccountIdContract\x1a\x15.protocol.Transaction\
    \"7\x82\xd3\xe4\x93\x021\"\x14/wallet/setaccountid:\x01*Z\x16\x12\x14/wa\
    llet/setaccountid\x12S\n\x0eUpdateAccount2\x12\x1f.protocol.AccountUpdat\
    eContract\x1a\x1e.protocol.TransactionExtention\"\0\x12\x8f\x01\n\x12Vot\
    eWitnessAccount\x12\x1d.protocol.VoteWitnessContract\x1a\x15.protocol.Tr\
    ansaction\"C\x82\xd3\xe4\x93\x02=\"\x1a/wallet/votewitnessaccount:\x01*Z\
    \x1c\x12\x1a/wallet/votewitnessaccount\x12R\n\rUpdateSetting\x12\x1f.pro\
    tocol.UpdateSettingContract\x1a\x1e.protocol.TransactionExtention\"\0\
    \x12Z\n\x11UpdateEnergyLimit\x12#.protocol.UpdateEnergyLimitContract\x1a\
    \x1e.protocol.TransactionExtention\"\0\x12V\n\x13VoteWitnessAccount2\x12\
    \x1d.protocol.VoteWitnessContract\x1a\x1e.protocol.TransactionExtention\
    \"\0\x12\x88\x01\n\x10CreateAssetIssue\x12\x1c.protocol.AssetIssueContra\
    ct\x1a\x15.protocol.Transaction\"?\x82\xd3\xe4\x93\x029\"\x18/wallet/cre\
    ateassetissue:\x01*Z\x1a\x12\x18/wallet/createassetissue\x12S\n\x11Creat\
    eAssetIssue2\x12\x1c.protocol.AssetIssueContract\x1a\x1e.protocol.Transa\
    ctionExtention\"\0\x12\x82\x01\n\rUpdateWitness\x12\x1f.protocol.Witness\
    UpdateContract\x1a\x15.protocol.Transaction\"9\x82\xd3\xe4\x93\x023\"\
    \x15/wallet/updatewitness:\x01*Z\x17\x12\x15/wallet/updatewitness\x12S\n\
    \x0eUpdateWitness2\x12\x1f.protocol.WitnessUpdateContract\x1a\x1e.protoc\
    ol.TransactionExtention\"\0\x12\x82\x01\n\rCreateAccount\x12\x1f.protoco\
    l.AccountCreateContract\x1a\x15.protocol.Transaction\"9\x82\xd3\xe4\x93\
    \x023\"\x15/wallet/createaccount:\x01*Z\x17\x12\x15/wallet/createaccount\
    \x12S\n\x0eCreateAccount2\x12\x1f.protocol.AccountCreateContract\x1a\x1e\
    .protocol.TransactionExtention\"\0\x12\x82\x01\n\rCreateWitness\x12\x1f.\
    protocol.WitnessCreateContract\x1a\x15.protocol.Transaction\"9\x82\xd3\
    \xe4\x93\x023\"\x15/wallet/createwitness:\x01*Z\x17\x12\x15/wallet/creat\
    ewitness\x12S\n\x0eCreateWitness2\x12\x1f.protocol.WitnessCreateContract\
    \x1a\x1e.protocol.TransactionExtention\"\0\x12\x82\x01\n\rTransferAsset\
    \x12\x1f.protocol.TransferAssetContract\x1a\x15.protocol.Transaction\"9\
    \x82\xd3\xe4\x93\x023\"\x15/wallet/transferasset:\x01*Z\x17\x12\x15/wall\
    et/transferasset\x12S\n\x0eTransferAsset2\x12\x1f.protocol.TransferAsset\
    Contract\x1a\x1e.protocol.TransactionExtention\"\0\x12\xa2\x01\n\x15Part\
    icipateAssetIssue\x12'.protocol.ParticipateAssetIssueContract\x1a\x15.pr\
    otocol.Transaction\"I\x82\xd3\xe4\x93\x02C\"\x1d/wallet/participateasset\
    issue:\x01*Z\x1f\x12\x1d/wallet/participateassetissue\x12c\n\x16Particip\
    ateAssetIssue2\x12'.protocol.ParticipateAssetIssueContract\x1a\x1e.proto\
    col.TransactionExtention\"\0\x12\x82\x01\n\rFreezeBalance\x12\x1f.protoc\
    ol.FreezeBalanceContract\x1a\x15.protocol.Transaction\"9\x82\xd3\xe4\x93\
    \x023\"\x15/wallet/freezebalance:\x01*Z\x17\x12\x15/wallet/freezebalance\
    \x12S\n\x0eFreezeBalance2\x12\x1f.protocol.FreezeBalanceContract\x1a\x1e\
    .protocol.TransactionExtention\"\0\x12\x8a\x01\n\x0fUnfreezeBalance\x12!\
    .protocol.UnfreezeBalanceContract\x1a\x15.protocol.Transaction\"=\x82\
    \xd3\xe4\x93\x027\"\x17/wallet/unfreezebalance:\x01*Z\x19\x12\x17/wallet\
    /unfreezebalance\x12W\n\x10UnfreezeBalance2\x12!.protocol.UnfreezeBalanc\
    eContract\x1a\x1e.protocol.TransactionExtention\"\0\x12\x82\x01\n\rUnfre\
    ezeAsset\x12\x1f.protocol.UnfreezeAssetContract\x1a\x15.protocol.Transac\
    tion\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/unfreezeasset:\x01*Z\x17\x12\
    \x15/wallet/unfreezeasset\x12S\n\x0eUnfreezeAsset2\x12\x1f.protocol.Unfr\
    eezeAssetContract\x1a\x1e.protocol.TransactionExtention\"\0\x12\x8a\x01\
    \n\x0fWithdrawBalance\x12!.protocol.WithdrawBalanceContract\x1a\x15.prot\
    ocol.Transaction\"=\x82\xd3\xe4\x93\x027\"\x17/wallet/withdrawbalance:\
    \x01*Z\x19\x12\x17/wallet/withdrawbalance\x12W\n\x10WithdrawBalance2\x12\
    !.protocol.WithdrawBalanceContract\x1a\x1e.protocol.TransactionExtention\
    \"\0\x12z\n\x0bUpdateAsset\x12\x1d.protocol.UpdateAssetContract\x1a\x15.\
    protocol.Transaction\"5\x82\xd3\xe4\x93\x02/\"\x13/wallet/updateasset:\
    \x01*Z\x15\x12\x13/wallet/updateasset\x12O\n\x0cUpdateAsset2\x12\x1d.pro\
    tocol.UpdateAssetContract\x1a\x1e.protocol.TransactionExtention\"\0\x12T\
    \n\x0eProposalCreate\x12\x20.protocol.ProposalCreateContract\x1a\x1e.pro\
    tocol.TransactionExtention\"\0\x12V\n\x0fProposalApprove\x12!.protocol.P\
    roposalApproveContract\x1a\x1e.protocol.TransactionExtention\"\0\x12T\n\
    \x0eProposalDelete\x12\x20.protocol.ProposalDeleteContract\x1a\x1e.proto\
    col.TransactionExtention\"\0\x12L\n\nBuyStorage\x12\x1c.protocol.BuyStor\
    ageContract\x1a\x1e.protocol.TransactionExtention\"\0\x12V\n\x0fBuyStora\
    geBytes\x12!.protocol.BuyStorageBytesContract\x1a\x1e.protocol.Transacti\
    onExtention\"\0\x12N\n\x0bSellStorage\x12\x1d.protocol.SellStorageContra\
    ct\x1a\x1e.protocol.TransactionExtention\"\0\x12T\n\x0eExchangeCreate\
    \x12\x20.protocol.ExchangeCreateContract\x1a\x1e.protocol.TransactionExt\
    ention\"\0\x12T\n\x0eExchangeInject\x12\x20.protocol.ExchangeInjectContr\
    act\x1a\x1e.protocol.TransactionExtention\"\0\x12X\n\x10ExchangeWithdraw\
    \x12\".protocol.ExchangeWithdrawContract\x1a\x1e.protocol.TransactionExt\
    ention\"\0\x12^\n\x13ExchangeTransaction\x12%.protocol.ExchangeTransacti\
    onContract\x1a\x1e.protocol.TransactionExtention\"\0\x12j\n\tListNodes\
    \x12\x16.protocol.EmptyMessage\x1a\x12.protocol.NodeList\"1\x82\xd3\xe4\
    \x93\x02+\"\x11/wallet/listnodes:\x01*Z\x13\x12\x11/wallet/listnodes\x12\
    \x92\x01\n\x16GetAssetIssueByAccount\x12\x11.protocol.Account\x1a\x18.pr\
    otocol.AssetIssueList\"K\x82\xd3\xe4\x93\x02E\"\x1e/wallet/getassetissue\
    byaccount:\x01*Z\x20\x12\x1e/wallet/getassetissuebyaccount\x12z\n\rGetAc\
    countNet\x12\x11.protocol.Account\x1a\x1b.protocol.AccountNetMessage\"9\
    \x82\xd3\xe4\x93\x023\"\x15/wallet/getaccountnet:\x01*Z\x17\x12\x15/wall\
    et/getaccountnet\x12K\n\x12GetAccountResource\x12\x11.protocol.Account\
    \x1a\x20.protocol.AccountResourceMessage\"\0\x12\x92\x01\n\x13GetAssetIs\
    sueByName\x12\x16.protocol.BytesMessage\x1a\x1c.protocol.AssetIssueContr\
    act\"E\x82\xd3\xe4\x93\x02?\"\x1b/wallet/getassetissuebyname:\x01*Z\x1d\
    \x12\x1b/wallet/getassetissuebyname\x12M\n\x17GetAssetIssueListByName\
    \x12\x16.protocol.BytesMessage\x1a\x18.protocol.AssetIssueList\"\0\x12K\
    \n\x11GetAssetIssueById\x12\x16.protocol.BytesMessage\x1a\x1c.protocol.A\
    ssetIssueContract\"\0\x12m\n\x0bGetNowBlock\x12\x16.protocol.EmptyMessag\
    e\x1a\x0f.protocol.Block\"5\x82\xd3\xe4\x93\x02/\"\x13/wallet/getnowbloc\
    k:\x01*Z\x15\x12\x13/wallet/getnowblock\x12B\n\x0cGetNowBlock2\x12\x16.p\
    rotocol.EmptyMessage\x1a\x18.protocol.BlockExtention\"\0\x12t\n\rGetBloc\
    kByNum\x12\x17.protocol.NumberMessage\x1a\x0f.protocol.Block\"9\x82\xd3\
    \xe4\x93\x023\"\x15/wallet/getblockbynum:\x01*Z\x17\x12\x15/wallet/getbl\
    ockbynum\x12E\n\x0eGetBlockByNum2\x12\x17.protocol.NumberMessage\x1a\x18\
    .protocol.BlockExtention\"\0\x12S\n\x1dGetTransactionCountByBlockNum\x12\
    \x17.protocol.NumberMessage\x1a\x17.protocol.NumberMessage\"\0\x12p\n\
    \x0cGetBlockById\x12\x16.protocol.BytesMessage\x1a\x0f.protocol.Block\"7\
    \x82\xd3\xe4\x93\x021\"\x14/wallet/getblockbyid:\x01*Z\x16\x12\x14/walle\
    t/getblockbyid\x12\x87\x01\n\x13GetBlockByLimitNext\x12\x14.protocol.Blo\
    ckLimit\x1a\x13.protocol.BlockList\"E\x82\xd3\xe4\x93\x02?\"\x1b/wallet/\
    getblockbylimitnext:\x01*Z\x1d\x12\x1b/wallet/getblockbylimitnext\x12L\n\
    \x14GetBlockByLimitNext2\x12\x14.protocol.BlockLimit\x1a\x1c.protocol.Bl\
    ockListExtention\"\0\x12\x8a\x01\n\x13GetBlockByLatestNum\x12\x17.protoc\
    ol.NumberMessage\x1a\x13.protocol.BlockList\"E\x82\xd3\xe4\x93\x02?\"\
    \x1b/wallet/getblockbylatestnum:\x01*Z\x1d\x12\x1b/wallet/getblockbylate\
    stnum\x12O\n\x14GetBlockByLatestNum2\x12\x17.protocol.NumberMessage\x1a\
    \x1c.protocol.BlockListExtention\"\0\x12\x88\x01\n\x12GetTransactionById\
    \x12\x16.protocol.BytesMessage\x1a\x15.protocol.Transaction\"C\x82\xd3\
    \xe4\x93\x02=\"\x1a/wallet/gettransactionbyid:\x01*Z\x1c\x12\x1a/wallet/\
    gettransactionbyid\x12Q\n\x0eDeployContract\x12\x1d.protocol.CreateSmart\
    Contract\x1a\x1e.protocol.TransactionExtention\"\0\x12@\n\x0bGetContract\
    \x12\x16.protocol.BytesMessage\x1a\x17.protocol.SmartContract\"\0\x12S\n\
    \x0fTriggerContract\x12\x1e.protocol.TriggerSmartContract\x1a\x1e.protoc\
    ol.TransactionExtention\"\0\x12[\n\x17TriggerConstantContract\x12\x1e.pr\
    otocol.TriggerSmartContract\x1a\x1e.protocol.TransactionExtention\"\0\
    \x12P\n\x10ClearContractABI\x12\x1a.protocol.ClearABIContract\x1a\x1e.pr\
    otocol.TransactionExtention\"\0\x12y\n\rListWitnesses\x12\x16.protocol.E\
    mptyMessage\x1a\x15.protocol.WitnessList\"9\x82\xd3\xe4\x93\x023\"\x15/w\
    allet/listwitnesses:\x01*Z\x17\x12\x15/wallet/listwitnesses\x12]\n\x14Ge\
    tDelegatedResource\x12\".protocol.DelegatedResourceMessage\x1a\x1f.proto\
    col.DelegatedResourceList\"\0\x12e\n\x20GetDelegatedResourceAccountIndex\
    \x12\x16.protocol.BytesMessage\x1a'.protocol.DelegatedResourceAccountInd\
    ex\"\0\x12z\n\rListProposals\x12\x16.protocol.EmptyMessage\x1a\x16.proto\
    col.ProposalList\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/listproposals:\x01\
    *Z\x17\x12\x15/wallet/listproposals\x12\x9f\x01\n\x18GetPaginatedProposa\
    lList\x12\x1a.protocol.PaginatedMessage\x1a\x16.protocol.ProposalList\"O\
    \x82\xd3\xe4\x93\x02I\"\x20/wallet/getpaginatedproposallist:\x01*Z\"\x12\
    \x20/wallet/getpaginatedproposallist\x12|\n\x0fGetProposalById\x12\x16.p\
    rotocol.BytesMessage\x1a\x12.protocol.Proposal\"=\x82\xd3\xe4\x93\x027\"\
    \x17/wallet/getproposalbyid:\x01*Z\x19\x12\x17/wallet/getproposalbyid\
    \x12z\n\rListExchanges\x12\x16.protocol.EmptyMessage\x1a\x16.protocol.Ex\
    changeList\"9\x82\xd3\xe4\x93\x023\"\x15/wallet/listexchanges:\x01*Z\x17\
    \x12\x15/wallet/listexchanges\x12\x9f\x01\n\x18GetPaginatedExchangeList\
    \x12\x1a.protocol.PaginatedMessage\x1a\x16.protocol.ExchangeList\"O\x82\
    \xd3\xe4\x93\x02I\"\x20/wallet/getpaginatedexchangelist:\x01*Z\"\x12\x20\
    /wallet/getpaginatedexchangelist\x12|\n\x0fGetExchangeById\x12\x16.proto\
    col.BytesMessage\x1a\x12.protocol.Exchange\"=\x82\xd3\xe4\x93\x027\"\x17\
    /wallet/getexchangebyid:\x01*Z\x19\x12\x17/wallet/getexchangebyid\x12\
    \x8c\x01\n\x12GetChainParameters\x12\x16.protocol.EmptyMessage\x1a\x19.p\
    rotocol.ChainParameters\"C\x82\xd3\xe4\x93\x02=\"\x1a/wallet/getchainpar\
    ameters:\x01*Z\x1c\x12\x1a/wallet/getchainparameters\x12\x88\x01\n\x11Ge\
    tAssetIssueList\x12\x16.protocol.EmptyMessage\x1a\x18.protocol.AssetIssu\
    eList\"A\x82\xd3\xe4\x93\x02;\"\x19/wallet/getassetissuelist:\x01*Z\x1b\
    \x12\x19/wallet/getassetissuelist\x12\xa7\x01\n\x1aGetPaginatedAssetIssu\
    eList\x12\x1a.protocol.PaginatedMessage\x1a\x18.protocol.AssetIssueList\
    \"S\x82\xd3\xe4\x93\x02M\"\"/wallet/getpaginatedassetissuelist:\x01*Z$\
    \x12\"/wallet/getpaginatedassetissuelist\x12\x84\x01\n\x10TotalTransacti\
    on\x12\x16.protocol.EmptyMessage\x1a\x17.protocol.NumberMessage\"?\x82\
    \xd3\xe4\x93\x029\"\x18/wallet/totaltransaction:\x01*Z\x1a\x12\x18/walle\
    t/totaltransaction\x12\x96\x01\n\x16GetNextMaintenanceTime\x12\x16.proto\
    col.EmptyMessage\x1a\x17.protocol.NumberMessage\"K\x82\xd3\xe4\x93\x02E\
    \"\x1e/wallet/getnextmaintenancetime:\x01*Z\x20\x12\x1e/wallet/getnextma\
    intenancetime\x12\x8b\x01\n\x12GetTransactionSign\x12\x19.protocol.Trans\
    actionSign\x1a\x15.protocol.Transaction\"C\x82\xd3\xe4\x93\x02=\"\x1a/wa\
    llet/gettransactionsign:\x01*Z\x1c\x12\x1a/wallet/gettransactionsign\x12\
    R\n\x13GetTransactionSign2\x12\x19.protocol.TransactionSign\x1a\x1e.prot\
    ocol.TransactionExtention\"\0\x12z\n\rCreateAddress\x12\x16.protocol.Byt\
    esMessage\x1a\x16.protocol.BytesMessage\"9\x82\xd3\xe4\x93\x023\"\x15/wa\
    llet/createaddress:\x01*Z\x17\x12\x15/wallet/createaddress\x12Y\n\x11Eas\
    yTransferAsset\x12\".protocol.EasyTransferAssetMessage\x1a\x1e.protocol.\
    EasyTransferResponse\"\0\x12k\n\x1aEasyTransferAssetByPrivate\x12+.proto\
    col.EasyTransferAssetByPrivateMessage\x1a\x1e.protocol.EasyTransferRespo\
    nse\"\0\x12\x86\x01\n\x0cEasyTransfer\x12\x1d.protocol.EasyTransferMessa\
    ge\x1a\x1e.protocol.EasyTransferResponse\"7\x82\xd3\xe4\x93\x021\"\x14/w\
    allet/easytransfer:\x01*Z\x16\x12\x14/wallet/easytransfer\x12\xaa\x01\n\
    \x15EasyTransferByPrivate\x12&.protocol.EasyTransferByPrivateMessage\x1a\
    \x1e.protocol.EasyTransferResponse\"I\x82\xd3\xe4\x93\x02C\"\x1d/wallet/\
    easytransferbyprivate:\x01*Z\x1f\x12\x1d/wallet/easytransferbyprivate\
    \x12\x8b\x01\n\x0fGenerateAddress\x12\x16.protocol.EmptyMessage\x1a!.pro\
    tocol.AddressPrKeyPairMessage\"=\x82\xd3\xe4\x93\x027\"\x17/wallet/gener\
    ateaddress:\x01*Z\x19\x12\x17/wallet/generateaddress\x12\x98\x01\n\x16Ge\
    tTransactionInfoById\x12\x16.protocol.BytesMessage\x1a\x19.protocol.Tran\
    sactionInfo\"K\x82\xd3\xe4\x93\x02E\"\x1e/wallet/gettransactioninfobyid:\
    \x01*Z\x20\x12\x1e/wallet/gettransactioninfobyid\x12\xb3\x01\n\x17Accoun\
    tPermissionUpdate\x12).protocol.AccountPermissionUpdateContract\x1a\x1e.\
    protocol.TransactionExtention\"M\x82\xd3\xe4\x93\x02G\"\x1f/wallet/accou\
    ntpermissionupdate:\x01*Z!\x12\x1f/wallet/accountpermissionupdate\x12F\n\
    \x07AddSign\x12\x19.protocol.TransactionSign\x1a\x1e.protocol.Transactio\
    nExtention\"\0\x12T\n\x18GetTransactionSignWeight\x12\x15.protocol.Trans\
    action\x1a\x1f.protocol.TransactionSignWeight\"\0\x12X\n\x1aGetTransacti\
    onApprovedList\x12\x15.protocol.Transaction\x1a!.protocol.TransactionApp\
    rovedList\"\0\x12;\n\x0bGetNodeInfo\x12\x16.protocol.EmptyMessage\x1a\
    \x12.protocol.NodeInfo\"\0\x12Z\n\x19CreateShieldedTransaction\x12\x1b.p\
    rotocol.PrivateParameters\x1a\x1e.protocol.TransactionExtention\"\0\x12_\
    \n\x18GetMerkleTreeVoucherInfo\x12\x19.protocol.OutputPointInfo\x1a&.pro\
    tocol.IncrementalMerkleVoucherInfo\"\0\x12I\n\rScanNoteByIvk\x12\x1e.pro\
    tocol.IvkDecryptParameters\x1a\x16.protocol.DecryptNotes\"\0\x12]\n\x14S\
    canAndMarkNoteByIvk\x12%.protocol.IvkDecryptAndMarkParameters\x1a\x1c.pr\
    otocol.DecryptNotesMarked\"\0\x12I\n\rScanNoteByOvk\x12\x1e.protocol.Ovk\
    DecryptParameters\x1a\x16.protocol.DecryptNotes\"\0\x12B\n\x0eGetSpendin\
    gKey\x12\x16.protocol.EmptyMessage\x1a\x16.protocol.BytesMessage\"\0\x12\
    X\n\x16GetExpandedSpendingKey\x12\x16.protocol.BytesMessage\x1a$.protoco\
    l.ExpandedSpendingKeyMessage\"\0\x12@\n\x0cGetAkFromAsk\x12\x16.protocol\
    .BytesMessage\x1a\x16.protocol.BytesMessage\"\0\x12@\n\x0cGetNkFromNsk\
    \x12\x16.protocol.BytesMessage\x1a\x16.protocol.BytesMessage\"\0\x12[\n\
    \x15GetIncomingViewingKey\x12\x1b.protocol.ViewingKeyMessage\x1a#.protoc\
    ol.IncomingViewingKeyMessage\"\0\x12H\n\x0eGetDiversifier\x12\x16.protoc\
    ol.EmptyMessage\x1a\x1c.protocol.DiversifierMessage\"\0\x12P\n\x15GetNew\
    ShieldedAddress\x12\x16.protocol.EmptyMessage\x1a\x1d.protocol.ShieldedA\
    ddressInfo\"\0\x12i\n\x14GetZenPaymentAddress\x12..protocol.IncomingView\
    ingKeyDiversifierMessage\x1a\x1f.protocol.PaymentAddressMessage\"\0\x12:\
    \n\x06GetRcm\x12\x16.protocol.EmptyMessage\x1a\x16.protocol.BytesMessage\
    \"\0\x12<\n\x07IsSpend\x12\x18.protocol.NoteParameters\x1a\x15.protocol.\
    SpendResult\"\0\x12w\n,CreateShieldedTransactionWithoutSpendAuthSig\x12%\
    .protocol.PrivateParametersWithoutAsk\x1a\x1e.protocol.TransactionExtent\
    ion\"\0\x12K\n\x18GetShieldTransactionHash\x12\x15.protocol.Transaction\
    \x1a\x16.protocol.BytesMessage\"\0\x12P\n\x12CreateSpendAuthSig\x12\x20.\
    protocol.SpendAuthSigParameters\x1a\x16.protocol.BytesMessage\"\0\x12I\n\
    \x15CreateShieldNullifier\x12\x16.protocol.NfParameters\x1a\x16.protocol\
    .BytesMessage\"\0\x12B\n\rGetRewardInfo\x12\x16.protocol.BytesMessage\
    \x1a\x17.protocol.NumberMessage\"\0\x12E\n\x10GetBrokerageInfo\x12\x16.p\
    rotocol.BytesMessage\x1a\x17.protocol.NumberMessage\"\0\x12V\n\x0fUpdate\
    Brokerage\x12!.protocol.UpdateBrokerageContract\x1a\x1e.protocol.Transac\
    tionExtention\"\02\xeb\x16\n\x0eWalletSolidity\x12w\n\nGetAccount\x12\
    \x11.protocol.Account\x1a\x11.protocol.Account\"C\x82\xd3\xe4\x93\x02=\"\
    \x1a/walletsolidity/getaccount:\x01*Z\x1c\x12\x1a/walletsolidity/getacco\
    unt\x12\x83\x01\n\x0eGetAccountById\x12\x11.protocol.Account\x1a\x11.pro\
    tocol.Account\"K\x82\xd3\xe4\x93\x02E\"\x1e/walletsolidity/getaccountbyi\
    d:\x01*Z\x20\x12\x1e/walletsolidity/getaccountbyid\x12\x89\x01\n\rListWi\
    tnesses\x12\x16.protocol.EmptyMessage\x1a\x15.protocol.WitnessList\"I\
    \x82\xd3\xe4\x93\x02C\"\x1d/walletsolidity/listwitnesses:\x01*Z\x1f\x12\
    \x1d/walletsolidity/listwitnesses\x12\x98\x01\n\x11GetAssetIssueList\x12\
    \x16.protocol.EmptyMessage\x1a\x18.protocol.AssetIssueList\"Q\x82\xd3\
    \xe4\x93\x02K\"!/walletsolidity/getassetissuelist:\x01*Z#\x12!/walletsol\
    idity/getassetissuelist\x12\xb7\x01\n\x1aGetPaginatedAssetIssueList\x12\
    \x1a.protocol.PaginatedMessage\x1a\x18.protocol.AssetIssueList\"c\x82\
    \xd3\xe4\x93\x02]\"*/walletsolidity/getpaginatedassetissuelist:\x01*Z,\
    \x12*/walletsolidity/getpaginatedassetissuelist\x12M\n\x13GetAssetIssueB\
    yName\x12\x16.protocol.BytesMessage\x1a\x1c.protocol.AssetIssueContract\
    \"\0\x12M\n\x17GetAssetIssueListByName\x12\x16.protocol.BytesMessage\x1a\
    \x18.protocol.AssetIssueList\"\0\x12K\n\x11GetAssetIssueById\x12\x16.pro\
    tocol.BytesMessage\x1a\x1c.protocol.AssetIssueContract\"\0\x12}\n\x0bGet\
    NowBlock\x12\x16.protocol.EmptyMessage\x1a\x0f.protocol.Block\"E\x82\xd3\
    \xe4\x93\x02?\"\x1b/walletsolidity/getnowblock:\x01*Z\x1d\x12\x1b/wallet\
    solidity/getnowblock\x12B\n\x0cGetNowBlock2\x12\x16.protocol.EmptyMessag\
    e\x1a\x18.protocol.BlockExtention\"\0\x12\x84\x01\n\rGetBlockByNum\x12\
    \x17.protocol.NumberMessage\x1a\x0f.protocol.Block\"I\x82\xd3\xe4\x93\
    \x02C\"\x1d/walletsolidity/getblockbynum:\x01*Z\x1f\x12\x1d/walletsolidi\
    ty/getblockbynum\x12E\n\x0eGetBlockByNum2\x12\x17.protocol.NumberMessage\
    \x1a\x18.protocol.BlockExtention\"\0\x12S\n\x1dGetTransactionCountByBloc\
    kNum\x12\x17.protocol.NumberMessage\x1a\x17.protocol.NumberMessage\"\0\
    \x12]\n\x14GetDelegatedResource\x12\".protocol.DelegatedResourceMessage\
    \x1a\x1f.protocol.DelegatedResourceList\"\0\x12e\n\x20GetDelegatedResour\
    ceAccountIndex\x12\x16.protocol.BytesMessage\x1a'.protocol.DelegatedReso\
    urceAccountIndex\"\0\x12?\n\x0fGetExchangeById\x12\x16.protocol.BytesMes\
    sage\x1a\x12.protocol.Exchange\"\0\x12A\n\rListExchanges\x12\x16.protoco\
    l.EmptyMessage\x1a\x16.protocol.ExchangeList\"\0\x12\x98\x01\n\x12GetTra\
    nsactionById\x12\x16.protocol.BytesMessage\x1a\x15.protocol.Transaction\
    \"S\x82\xd3\xe4\x93\x02M\"\"/walletsolidity/gettransactionbyid:\x01*Z$\
    \x12\"/walletsolidity/gettransactionbyid\x12\xa8\x01\n\x16GetTransaction\
    InfoById\x12\x16.protocol.BytesMessage\x1a\x19.protocol.TransactionInfo\
    \"[\x82\xd3\xe4\x93\x02U\"&/walletsolidity/gettransactioninfobyid:\x01*Z\
    (\x12&/walletsolidity/gettransactioninfobyid\x12\x9b\x01\n\x0fGenerateAd\
    dress\x12\x16.protocol.EmptyMessage\x1a!.protocol.AddressPrKeyPairMessag\
    e\"M\x82\xd3\xe4\x93\x02G\"\x1f/walletsolidity/generateaddress:\x01*Z!\
    \x12\x1f/walletsolidity/generateaddress\x12_\n\x18GetMerkleTreeVoucherIn\
    fo\x12\x19.protocol.OutputPointInfo\x1a&.protocol.IncrementalMerkleVouch\
    erInfo\"\0\x12I\n\rScanNoteByIvk\x12\x1e.protocol.IvkDecryptParameters\
    \x1a\x16.protocol.DecryptNotes\"\0\x12]\n\x14ScanAndMarkNoteByIvk\x12%.p\
    rotocol.IvkDecryptAndMarkParameters\x1a\x1c.protocol.DecryptNotesMarked\
    \"\0\x12I\n\rScanNoteByOvk\x12\x1e.protocol.OvkDecryptParameters\x1a\x16\
    .protocol.DecryptNotes\"\0\x12<\n\x07IsSpend\x12\x18.protocol.NoteParame\
    ters\x1a\x15.protocol.SpendResult\"\0\x12[\n\x17TriggerConstantContract\
    \x12\x1e.protocol.TriggerSmartContract\x1a\x1e.protocol.TransactionExten\
    tion\"\0\x12B\n\rGetRewardInfo\x12\x16.protocol.BytesMessage\x1a\x17.pro\
    tocol.NumberMessage\"\0\x12E\n\x10GetBrokerageInfo\x12\x16.protocol.Byte\
    sMessage\x1a\x17.protocol.NumberMessage\"\02\xad\x04\n\x0fWalletExtensio\
    n\x12\xb1\x01\n\x17GetTransactionsFromThis\x12\x1a.protocol.AccountPagin\
    ated\x1a\x19.protocol.TransactionList\"_\x82\xd3\xe4\x93\x02Y\"(/wallete\
    xtension/gettransactionsfromthis:\x01*Z*\x12(/walletextension/gettransac\
    tionsfromthis\x12\\\n\x18GetTransactionsFromThis2\x12\x1a.protocol.Accou\
    ntPaginated\x1a\".protocol.TransactionListExtention\"\0\x12\xab\x01\n\
    \x15GetTransactionsToThis\x12\x1a.protocol.AccountPaginated\x1a\x19.prot\
    ocol.TransactionList\"[\x82\xd3\xe4\x93\x02U\"&/walletextension/gettrans\
    actionstothis:\x01*Z(\x12&/walletextension/gettransactionstothis\x12Z\n\
    \x16GetTransactionsToThis2\x12\x1a.protocol.AccountPaginated\x1a\".proto\
    col.TransactionListExtention\"\02\x99\x02\n\x08Database\x12G\n\x11getBlo\
    ckReference\x12\x16.protocol.EmptyMessage\x1a\x18.protocol.BlockReferenc\
    e\"\0\x12M\n\x14GetDynamicProperties\x12\x16.protocol.EmptyMessage\x1a\
    \x1b.protocol.DynamicProperties\"\0\x128\n\x0bGetNowBlock\x12\x16.protoc\
    ol.EmptyMessage\x1a\x0f.protocol.Block\"\0\x12;\n\rGetBlockByNum\x12\x17\
    .protocol.NumberMessage\x1a\x0f.protocol.Block\"\02\t\n\x07NetworkBA\n\
    \x0corg.tron.apiB\x07GrpcAPIZ(github.com/tronprotocol/grpc-gateway/apib\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
