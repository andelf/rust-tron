// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `core/Tron.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AccountId {
    // message fields
    pub name: ::std::vec::Vec<u8>,
    pub address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountId {
    fn default() -> &'a AccountId {
        <AccountId as ::protobuf::Message>::default_instance()
    }
}

impl AccountId {
    pub fn new() -> AccountId {
        ::std::default::Default::default()
    }

    // bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }

    // bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AccountId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountId {
        AccountId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &AccountId| { &m.name },
                |m: &mut AccountId| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &AccountId| { &m.address },
                |m: &mut AccountId| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccountId>(
                "AccountId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccountId {
        static instance: ::protobuf::rt::LazyV2<AccountId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountId::new)
    }
}

impl ::protobuf::Clear for AccountId {
    fn clear(&mut self) {
        self.name.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Vote {
    // message fields
    pub vote_address: ::std::vec::Vec<u8>,
    pub vote_count: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    // bytes vote_address = 1;


    pub fn get_vote_address(&self) -> &[u8] {
        &self.vote_address
    }
    pub fn clear_vote_address(&mut self) {
        self.vote_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_vote_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.vote_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.vote_address
    }

    // Take field
    pub fn take_vote_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.vote_address, ::std::vec::Vec::new())
    }

    // int64 vote_count = 2;


    pub fn get_vote_count(&self) -> i64 {
        self.vote_count
    }
    pub fn clear_vote_count(&mut self) {
        self.vote_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: i64) {
        self.vote_count = v;
    }
}

impl ::protobuf::Message for Vote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.vote_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vote_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vote_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vote_address);
        }
        if self.vote_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.vote_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.vote_address.is_empty() {
            os.write_bytes(1, &self.vote_address)?;
        }
        if self.vote_count != 0 {
            os.write_int64(2, self.vote_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vote_address",
                |m: &Vote| { &m.vote_address },
                |m: &mut Vote| { &mut m.vote_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "vote_count",
                |m: &Vote| { &m.vote_count },
                |m: &mut Vote| { &mut m.vote_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vote>(
                "Vote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Vote {
        static instance: ::protobuf::rt::LazyV2<Vote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vote::new)
    }
}

impl ::protobuf::Clear for Vote {
    fn clear(&mut self) {
        self.vote_address.clear();
        self.vote_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Proposal {
    // message fields
    pub proposal_id: i64,
    pub proposer_address: ::std::vec::Vec<u8>,
    pub parameters: ::std::collections::HashMap<i64, i64>,
    pub expiration_time: i64,
    pub create_time: i64,
    pub approvals: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub state: Proposal_State,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    // int64 proposal_id = 1;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }

    // bytes proposer_address = 2;


    pub fn get_proposer_address(&self) -> &[u8] {
        &self.proposer_address
    }
    pub fn clear_proposer_address(&mut self) {
        self.proposer_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.proposer_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proposer_address
    }

    // Take field
    pub fn take_proposer_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proposer_address, ::std::vec::Vec::new())
    }

    // repeated .protocol.Proposal.ParametersEntry parameters = 3;


    pub fn get_parameters(&self) -> &::std::collections::HashMap<i64, i64> {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::std::collections::HashMap<i64, i64>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::std::collections::HashMap<i64, i64> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::std::collections::HashMap<i64, i64> {
        ::std::mem::replace(&mut self.parameters, ::std::collections::HashMap::new())
    }

    // int64 expiration_time = 4;


    pub fn get_expiration_time(&self) -> i64 {
        self.expiration_time
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: i64) {
        self.expiration_time = v;
    }

    // int64 create_time = 5;


    pub fn get_create_time(&self) -> i64 {
        self.create_time
    }
    pub fn clear_create_time(&mut self) {
        self.create_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: i64) {
        self.create_time = v;
    }

    // repeated bytes approvals = 6;


    pub fn get_approvals(&self) -> &[::std::vec::Vec<u8>] {
        &self.approvals
    }
    pub fn clear_approvals(&mut self) {
        self.approvals.clear();
    }

    // Param is passed by value, moved
    pub fn set_approvals(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.approvals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_approvals(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.approvals
    }

    // Take field
    pub fn take_approvals(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.approvals, ::protobuf::RepeatedField::new())
    }

    // .protocol.Proposal.State state = 7;


    pub fn get_state(&self) -> Proposal_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = Proposal_State::PENDING;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: Proposal_State) {
        self.state = v;
    }
}

impl ::protobuf::Message for Proposal {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.proposal_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proposer_address)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.parameters)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration_time = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.create_time = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.approvals)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.proposal_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proposer_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proposer_address);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(3, &self.parameters);
        if self.expiration_time != 0 {
            my_size += ::protobuf::rt::value_size(4, self.expiration_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::value_size(5, self.create_time, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.approvals {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if self.state != Proposal_State::PENDING {
            my_size += ::protobuf::rt::enum_size(7, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.proposal_id != 0 {
            os.write_int64(1, self.proposal_id)?;
        }
        if !self.proposer_address.is_empty() {
            os.write_bytes(2, &self.proposer_address)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(3, &self.parameters, os)?;
        if self.expiration_time != 0 {
            os.write_int64(4, self.expiration_time)?;
        }
        if self.create_time != 0 {
            os.write_int64(5, self.create_time)?;
        }
        for v in &self.approvals {
            os.write_bytes(6, &v)?;
        };
        if self.state != Proposal_State::PENDING {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "proposal_id",
                |m: &Proposal| { &m.proposal_id },
                |m: &mut Proposal| { &mut m.proposal_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proposer_address",
                |m: &Proposal| { &m.proposer_address },
                |m: &mut Proposal| { &mut m.proposer_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(
                "parameters",
                |m: &Proposal| { &m.parameters },
                |m: &mut Proposal| { &mut m.parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiration_time",
                |m: &Proposal| { &m.expiration_time },
                |m: &mut Proposal| { &mut m.expiration_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "create_time",
                |m: &Proposal| { &m.create_time },
                |m: &mut Proposal| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "approvals",
                |m: &Proposal| { &m.approvals },
                |m: &mut Proposal| { &mut m.approvals },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Proposal_State>>(
                "state",
                |m: &Proposal| { &m.state },
                |m: &mut Proposal| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Proposal>(
                "Proposal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Proposal {
        static instance: ::protobuf::rt::LazyV2<Proposal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Proposal::new)
    }
}

impl ::protobuf::Clear for Proposal {
    fn clear(&mut self) {
        self.proposal_id = 0;
        self.proposer_address.clear();
        self.parameters.clear();
        self.expiration_time = 0;
        self.create_time = 0;
        self.approvals.clear();
        self.state = Proposal_State::PENDING;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Proposal_State {
    PENDING = 0,
    DISAPPROVED = 1,
    APPROVED = 2,
    CANCELED = 3,
}

impl ::protobuf::ProtobufEnum for Proposal_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Proposal_State> {
        match value {
            0 => ::std::option::Option::Some(Proposal_State::PENDING),
            1 => ::std::option::Option::Some(Proposal_State::DISAPPROVED),
            2 => ::std::option::Option::Some(Proposal_State::APPROVED),
            3 => ::std::option::Option::Some(Proposal_State::CANCELED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Proposal_State] = &[
            Proposal_State::PENDING,
            Proposal_State::DISAPPROVED,
            Proposal_State::APPROVED,
            Proposal_State::CANCELED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Proposal_State>("Proposal.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Proposal_State {
}

impl ::std::default::Default for Proposal_State {
    fn default() -> Self {
        Proposal_State::PENDING
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Exchange {
    // message fields
    pub exchange_id: i64,
    pub creator_address: ::std::vec::Vec<u8>,
    pub create_time: i64,
    pub first_token_id: ::std::vec::Vec<u8>,
    pub first_token_balance: i64,
    pub second_token_id: ::std::vec::Vec<u8>,
    pub second_token_balance: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Exchange {
    fn default() -> &'a Exchange {
        <Exchange as ::protobuf::Message>::default_instance()
    }
}

impl Exchange {
    pub fn new() -> Exchange {
        ::std::default::Default::default()
    }

    // int64 exchange_id = 1;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // bytes creator_address = 2;


    pub fn get_creator_address(&self) -> &[u8] {
        &self.creator_address
    }
    pub fn clear_creator_address(&mut self) {
        self.creator_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_creator_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.creator_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.creator_address
    }

    // Take field
    pub fn take_creator_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.creator_address, ::std::vec::Vec::new())
    }

    // int64 create_time = 3;


    pub fn get_create_time(&self) -> i64 {
        self.create_time
    }
    pub fn clear_create_time(&mut self) {
        self.create_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: i64) {
        self.create_time = v;
    }

    // bytes first_token_id = 6;


    pub fn get_first_token_id(&self) -> &[u8] {
        &self.first_token_id
    }
    pub fn clear_first_token_id(&mut self) {
        self.first_token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_first_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.first_token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.first_token_id
    }

    // Take field
    pub fn take_first_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.first_token_id, ::std::vec::Vec::new())
    }

    // int64 first_token_balance = 7;


    pub fn get_first_token_balance(&self) -> i64 {
        self.first_token_balance
    }
    pub fn clear_first_token_balance(&mut self) {
        self.first_token_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_token_balance(&mut self, v: i64) {
        self.first_token_balance = v;
    }

    // bytes second_token_id = 8;


    pub fn get_second_token_id(&self) -> &[u8] {
        &self.second_token_id
    }
    pub fn clear_second_token_id(&mut self) {
        self.second_token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_second_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.second_token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_second_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.second_token_id
    }

    // Take field
    pub fn take_second_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.second_token_id, ::std::vec::Vec::new())
    }

    // int64 second_token_balance = 9;


    pub fn get_second_token_balance(&self) -> i64 {
        self.second_token_balance
    }
    pub fn clear_second_token_balance(&mut self) {
        self.second_token_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_second_token_balance(&mut self, v: i64) {
        self.second_token_balance = v;
    }
}

impl ::protobuf::Message for Exchange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.creator_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.create_time = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.first_token_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.first_token_balance = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.second_token_id)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.second_token_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.creator_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.creator_address);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::value_size(3, self.create_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.first_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.first_token_id);
        }
        if self.first_token_balance != 0 {
            my_size += ::protobuf::rt::value_size(7, self.first_token_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.second_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.second_token_id);
        }
        if self.second_token_balance != 0 {
            my_size += ::protobuf::rt::value_size(9, self.second_token_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.exchange_id != 0 {
            os.write_int64(1, self.exchange_id)?;
        }
        if !self.creator_address.is_empty() {
            os.write_bytes(2, &self.creator_address)?;
        }
        if self.create_time != 0 {
            os.write_int64(3, self.create_time)?;
        }
        if !self.first_token_id.is_empty() {
            os.write_bytes(6, &self.first_token_id)?;
        }
        if self.first_token_balance != 0 {
            os.write_int64(7, self.first_token_balance)?;
        }
        if !self.second_token_id.is_empty() {
            os.write_bytes(8, &self.second_token_id)?;
        }
        if self.second_token_balance != 0 {
            os.write_int64(9, self.second_token_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Exchange {
        Exchange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_id",
                |m: &Exchange| { &m.exchange_id },
                |m: &mut Exchange| { &mut m.exchange_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "creator_address",
                |m: &Exchange| { &m.creator_address },
                |m: &mut Exchange| { &mut m.creator_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "create_time",
                |m: &Exchange| { &m.create_time },
                |m: &mut Exchange| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "first_token_id",
                |m: &Exchange| { &m.first_token_id },
                |m: &mut Exchange| { &mut m.first_token_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "first_token_balance",
                |m: &Exchange| { &m.first_token_balance },
                |m: &mut Exchange| { &mut m.first_token_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "second_token_id",
                |m: &Exchange| { &m.second_token_id },
                |m: &mut Exchange| { &mut m.second_token_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "second_token_balance",
                |m: &Exchange| { &m.second_token_balance },
                |m: &mut Exchange| { &mut m.second_token_balance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Exchange>(
                "Exchange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Exchange {
        static instance: ::protobuf::rt::LazyV2<Exchange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Exchange::new)
    }
}

impl ::protobuf::Clear for Exchange {
    fn clear(&mut self) {
        self.exchange_id = 0;
        self.creator_address.clear();
        self.create_time = 0;
        self.first_token_id.clear();
        self.first_token_balance = 0;
        self.second_token_id.clear();
        self.second_token_balance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Exchange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Exchange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ChainParameters {
    // message fields
    pub chainParameter: ::protobuf::RepeatedField<ChainParameters_ChainParameter>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainParameters {
    fn default() -> &'a ChainParameters {
        <ChainParameters as ::protobuf::Message>::default_instance()
    }
}

impl ChainParameters {
    pub fn new() -> ChainParameters {
        ::std::default::Default::default()
    }

    // repeated .protocol.ChainParameters.ChainParameter chainParameter = 1;


    pub fn get_chainParameter(&self) -> &[ChainParameters_ChainParameter] {
        &self.chainParameter
    }
    pub fn clear_chainParameter(&mut self) {
        self.chainParameter.clear();
    }

    // Param is passed by value, moved
    pub fn set_chainParameter(&mut self, v: ::protobuf::RepeatedField<ChainParameters_ChainParameter>) {
        self.chainParameter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chainParameter(&mut self) -> &mut ::protobuf::RepeatedField<ChainParameters_ChainParameter> {
        &mut self.chainParameter
    }

    // Take field
    pub fn take_chainParameter(&mut self) -> ::protobuf::RepeatedField<ChainParameters_ChainParameter> {
        ::std::mem::replace(&mut self.chainParameter, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChainParameters {
    fn is_initialized(&self) -> bool {
        for v in &self.chainParameter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chainParameter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.chainParameter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.chainParameter {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainParameters {
        ChainParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainParameters_ChainParameter>>(
                "chainParameter",
                |m: &ChainParameters| { &m.chainParameter },
                |m: &mut ChainParameters| { &mut m.chainParameter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainParameters>(
                "ChainParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainParameters {
        static instance: ::protobuf::rt::LazyV2<ChainParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainParameters::new)
    }
}

impl ::protobuf::Clear for ChainParameters {
    fn clear(&mut self) {
        self.chainParameter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ChainParameters_ChainParameter {
    // message fields
    pub key: ::std::string::String,
    pub value: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainParameters_ChainParameter {
    fn default() -> &'a ChainParameters_ChainParameter {
        <ChainParameters_ChainParameter as ::protobuf::Message>::default_instance()
    }
}

impl ChainParameters_ChainParameter {
    pub fn new() -> ChainParameters_ChainParameter {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // int64 value = 2;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }
}

impl ::protobuf::Message for ChainParameters_ChainParameter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.value != 0 {
            os.write_int64(2, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainParameters_ChainParameter {
        ChainParameters_ChainParameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &ChainParameters_ChainParameter| { &m.key },
                |m: &mut ChainParameters_ChainParameter| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value",
                |m: &ChainParameters_ChainParameter| { &m.value },
                |m: &mut ChainParameters_ChainParameter| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainParameters_ChainParameter>(
                "ChainParameters.ChainParameter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainParameters_ChainParameter {
        static instance: ::protobuf::rt::LazyV2<ChainParameters_ChainParameter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainParameters_ChainParameter::new)
    }
}

impl ::protobuf::Clear for ChainParameters_ChainParameter {
    fn clear(&mut self) {
        self.key.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainParameters_ChainParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainParameters_ChainParameter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Account {
    // message fields
    pub account_name: ::std::vec::Vec<u8>,
    pub field_type: AccountType,
    pub address: ::std::vec::Vec<u8>,
    pub balance: i64,
    pub votes: ::protobuf::RepeatedField<Vote>,
    pub asset: ::std::collections::HashMap<::std::string::String, i64>,
    pub assetV2: ::std::collections::HashMap<::std::string::String, i64>,
    pub frozen: ::protobuf::RepeatedField<Account_Frozen>,
    pub net_usage: i64,
    pub acquired_delegated_frozen_balance_for_bandwidth: i64,
    pub delegated_frozen_balance_for_bandwidth: i64,
    pub create_time: i64,
    pub latest_opration_time: i64,
    pub allowance: i64,
    pub latest_withdraw_time: i64,
    pub code: ::std::vec::Vec<u8>,
    pub is_witness: bool,
    pub is_committee: bool,
    pub frozen_supply: ::protobuf::RepeatedField<Account_Frozen>,
    pub asset_issued_name: ::std::vec::Vec<u8>,
    pub asset_issued_ID: ::std::vec::Vec<u8>,
    pub latest_asset_operation_time: ::std::collections::HashMap<::std::string::String, i64>,
    pub latest_asset_operation_timeV2: ::std::collections::HashMap<::std::string::String, i64>,
    pub free_net_usage: i64,
    pub free_asset_net_usage: ::std::collections::HashMap<::std::string::String, i64>,
    pub free_asset_net_usageV2: ::std::collections::HashMap<::std::string::String, i64>,
    pub latest_consume_time: i64,
    pub latest_consume_free_time: i64,
    pub account_id: ::std::vec::Vec<u8>,
    pub account_resource: ::protobuf::SingularPtrField<Account_AccountResource>,
    pub codeHash: ::std::vec::Vec<u8>,
    pub owner_permission: ::protobuf::SingularPtrField<Permission>,
    pub witness_permission: ::protobuf::SingularPtrField<Permission>,
    pub active_permission: ::protobuf::RepeatedField<Permission>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Account {
    fn default() -> &'a Account {
        <Account as ::protobuf::Message>::default_instance()
    }
}

impl Account {
    pub fn new() -> Account {
        ::std::default::Default::default()
    }

    // bytes account_name = 1;


    pub fn get_account_name(&self) -> &[u8] {
        &self.account_name
    }
    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_name
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_name, ::std::vec::Vec::new())
    }

    // .protocol.AccountType type = 2;


    pub fn get_field_type(&self) -> AccountType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AccountType::Normal;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AccountType) {
        self.field_type = v;
    }

    // bytes address = 3;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // int64 balance = 4;


    pub fn get_balance(&self) -> i64 {
        self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i64) {
        self.balance = v;
    }

    // repeated .protocol.Vote votes = 5;


    pub fn get_votes(&self) -> &[Vote] {
        &self.votes
    }
    pub fn clear_votes(&mut self) {
        self.votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_votes(&mut self, v: ::protobuf::RepeatedField<Vote>) {
        self.votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_votes(&mut self) -> &mut ::protobuf::RepeatedField<Vote> {
        &mut self.votes
    }

    // Take field
    pub fn take_votes(&mut self) -> ::protobuf::RepeatedField<Vote> {
        ::std::mem::replace(&mut self.votes, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.Account.AssetEntry asset = 6;


    pub fn get_asset(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.asset
    }
    pub fn clear_asset(&mut self) {
        self.asset.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.asset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_asset(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.asset
    }

    // Take field
    pub fn take_asset(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.asset, ::std::collections::HashMap::new())
    }

    // repeated .protocol.Account.AssetV2Entry assetV2 = 56;


    pub fn get_assetV2(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.assetV2
    }
    pub fn clear_assetV2(&mut self) {
        self.assetV2.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetV2(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.assetV2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assetV2(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.assetV2
    }

    // Take field
    pub fn take_assetV2(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.assetV2, ::std::collections::HashMap::new())
    }

    // repeated .protocol.Account.Frozen frozen = 7;


    pub fn get_frozen(&self) -> &[Account_Frozen] {
        &self.frozen
    }
    pub fn clear_frozen(&mut self) {
        self.frozen.clear();
    }

    // Param is passed by value, moved
    pub fn set_frozen(&mut self, v: ::protobuf::RepeatedField<Account_Frozen>) {
        self.frozen = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frozen(&mut self) -> &mut ::protobuf::RepeatedField<Account_Frozen> {
        &mut self.frozen
    }

    // Take field
    pub fn take_frozen(&mut self) -> ::protobuf::RepeatedField<Account_Frozen> {
        ::std::mem::replace(&mut self.frozen, ::protobuf::RepeatedField::new())
    }

    // int64 net_usage = 8;


    pub fn get_net_usage(&self) -> i64 {
        self.net_usage
    }
    pub fn clear_net_usage(&mut self) {
        self.net_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_net_usage(&mut self, v: i64) {
        self.net_usage = v;
    }

    // int64 acquired_delegated_frozen_balance_for_bandwidth = 41;


    pub fn get_acquired_delegated_frozen_balance_for_bandwidth(&self) -> i64 {
        self.acquired_delegated_frozen_balance_for_bandwidth
    }
    pub fn clear_acquired_delegated_frozen_balance_for_bandwidth(&mut self) {
        self.acquired_delegated_frozen_balance_for_bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_acquired_delegated_frozen_balance_for_bandwidth(&mut self, v: i64) {
        self.acquired_delegated_frozen_balance_for_bandwidth = v;
    }

    // int64 delegated_frozen_balance_for_bandwidth = 42;


    pub fn get_delegated_frozen_balance_for_bandwidth(&self) -> i64 {
        self.delegated_frozen_balance_for_bandwidth
    }
    pub fn clear_delegated_frozen_balance_for_bandwidth(&mut self) {
        self.delegated_frozen_balance_for_bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_delegated_frozen_balance_for_bandwidth(&mut self, v: i64) {
        self.delegated_frozen_balance_for_bandwidth = v;
    }

    // int64 create_time = 9;


    pub fn get_create_time(&self) -> i64 {
        self.create_time
    }
    pub fn clear_create_time(&mut self) {
        self.create_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: i64) {
        self.create_time = v;
    }

    // int64 latest_opration_time = 10;


    pub fn get_latest_opration_time(&self) -> i64 {
        self.latest_opration_time
    }
    pub fn clear_latest_opration_time(&mut self) {
        self.latest_opration_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_opration_time(&mut self, v: i64) {
        self.latest_opration_time = v;
    }

    // int64 allowance = 11;


    pub fn get_allowance(&self) -> i64 {
        self.allowance
    }
    pub fn clear_allowance(&mut self) {
        self.allowance = 0;
    }

    // Param is passed by value, moved
    pub fn set_allowance(&mut self, v: i64) {
        self.allowance = v;
    }

    // int64 latest_withdraw_time = 12;


    pub fn get_latest_withdraw_time(&self) -> i64 {
        self.latest_withdraw_time
    }
    pub fn clear_latest_withdraw_time(&mut self) {
        self.latest_withdraw_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_withdraw_time(&mut self, v: i64) {
        self.latest_withdraw_time = v;
    }

    // bytes code = 13;


    pub fn get_code(&self) -> &[u8] {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.code, ::std::vec::Vec::new())
    }

    // bool is_witness = 14;


    pub fn get_is_witness(&self) -> bool {
        self.is_witness
    }
    pub fn clear_is_witness(&mut self) {
        self.is_witness = false;
    }

    // Param is passed by value, moved
    pub fn set_is_witness(&mut self, v: bool) {
        self.is_witness = v;
    }

    // bool is_committee = 15;


    pub fn get_is_committee(&self) -> bool {
        self.is_committee
    }
    pub fn clear_is_committee(&mut self) {
        self.is_committee = false;
    }

    // Param is passed by value, moved
    pub fn set_is_committee(&mut self, v: bool) {
        self.is_committee = v;
    }

    // repeated .protocol.Account.Frozen frozen_supply = 16;


    pub fn get_frozen_supply(&self) -> &[Account_Frozen] {
        &self.frozen_supply
    }
    pub fn clear_frozen_supply(&mut self) {
        self.frozen_supply.clear();
    }

    // Param is passed by value, moved
    pub fn set_frozen_supply(&mut self, v: ::protobuf::RepeatedField<Account_Frozen>) {
        self.frozen_supply = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frozen_supply(&mut self) -> &mut ::protobuf::RepeatedField<Account_Frozen> {
        &mut self.frozen_supply
    }

    // Take field
    pub fn take_frozen_supply(&mut self) -> ::protobuf::RepeatedField<Account_Frozen> {
        ::std::mem::replace(&mut self.frozen_supply, ::protobuf::RepeatedField::new())
    }

    // bytes asset_issued_name = 17;


    pub fn get_asset_issued_name(&self) -> &[u8] {
        &self.asset_issued_name
    }
    pub fn clear_asset_issued_name(&mut self) {
        self.asset_issued_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_issued_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.asset_issued_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_issued_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.asset_issued_name
    }

    // Take field
    pub fn take_asset_issued_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.asset_issued_name, ::std::vec::Vec::new())
    }

    // bytes asset_issued_ID = 57;


    pub fn get_asset_issued_ID(&self) -> &[u8] {
        &self.asset_issued_ID
    }
    pub fn clear_asset_issued_ID(&mut self) {
        self.asset_issued_ID.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_issued_ID(&mut self, v: ::std::vec::Vec<u8>) {
        self.asset_issued_ID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_issued_ID(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.asset_issued_ID
    }

    // Take field
    pub fn take_asset_issued_ID(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.asset_issued_ID, ::std::vec::Vec::new())
    }

    // repeated .protocol.Account.LatestAssetOperationTimeEntry latest_asset_operation_time = 18;


    pub fn get_latest_asset_operation_time(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.latest_asset_operation_time
    }
    pub fn clear_latest_asset_operation_time(&mut self) {
        self.latest_asset_operation_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_asset_operation_time(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.latest_asset_operation_time = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_asset_operation_time(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.latest_asset_operation_time
    }

    // Take field
    pub fn take_latest_asset_operation_time(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.latest_asset_operation_time, ::std::collections::HashMap::new())
    }

    // repeated .protocol.Account.LatestAssetOperationTimeV2Entry latest_asset_operation_timeV2 = 58;


    pub fn get_latest_asset_operation_timeV2(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.latest_asset_operation_timeV2
    }
    pub fn clear_latest_asset_operation_timeV2(&mut self) {
        self.latest_asset_operation_timeV2.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_asset_operation_timeV2(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.latest_asset_operation_timeV2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_latest_asset_operation_timeV2(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.latest_asset_operation_timeV2
    }

    // Take field
    pub fn take_latest_asset_operation_timeV2(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.latest_asset_operation_timeV2, ::std::collections::HashMap::new())
    }

    // int64 free_net_usage = 19;


    pub fn get_free_net_usage(&self) -> i64 {
        self.free_net_usage
    }
    pub fn clear_free_net_usage(&mut self) {
        self.free_net_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_free_net_usage(&mut self, v: i64) {
        self.free_net_usage = v;
    }

    // repeated .protocol.Account.FreeAssetNetUsageEntry free_asset_net_usage = 20;


    pub fn get_free_asset_net_usage(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.free_asset_net_usage
    }
    pub fn clear_free_asset_net_usage(&mut self) {
        self.free_asset_net_usage.clear();
    }

    // Param is passed by value, moved
    pub fn set_free_asset_net_usage(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.free_asset_net_usage = v;
    }

    // Mutable pointer to the field.
    pub fn mut_free_asset_net_usage(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.free_asset_net_usage
    }

    // Take field
    pub fn take_free_asset_net_usage(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.free_asset_net_usage, ::std::collections::HashMap::new())
    }

    // repeated .protocol.Account.FreeAssetNetUsageV2Entry free_asset_net_usageV2 = 59;


    pub fn get_free_asset_net_usageV2(&self) -> &::std::collections::HashMap<::std::string::String, i64> {
        &self.free_asset_net_usageV2
    }
    pub fn clear_free_asset_net_usageV2(&mut self) {
        self.free_asset_net_usageV2.clear();
    }

    // Param is passed by value, moved
    pub fn set_free_asset_net_usageV2(&mut self, v: ::std::collections::HashMap<::std::string::String, i64>) {
        self.free_asset_net_usageV2 = v;
    }

    // Mutable pointer to the field.
    pub fn mut_free_asset_net_usageV2(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i64> {
        &mut self.free_asset_net_usageV2
    }

    // Take field
    pub fn take_free_asset_net_usageV2(&mut self) -> ::std::collections::HashMap<::std::string::String, i64> {
        ::std::mem::replace(&mut self.free_asset_net_usageV2, ::std::collections::HashMap::new())
    }

    // int64 latest_consume_time = 21;


    pub fn get_latest_consume_time(&self) -> i64 {
        self.latest_consume_time
    }
    pub fn clear_latest_consume_time(&mut self) {
        self.latest_consume_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_consume_time(&mut self, v: i64) {
        self.latest_consume_time = v;
    }

    // int64 latest_consume_free_time = 22;


    pub fn get_latest_consume_free_time(&self) -> i64 {
        self.latest_consume_free_time
    }
    pub fn clear_latest_consume_free_time(&mut self) {
        self.latest_consume_free_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_consume_free_time(&mut self, v: i64) {
        self.latest_consume_free_time = v;
    }

    // bytes account_id = 23;


    pub fn get_account_id(&self) -> &[u8] {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_id, ::std::vec::Vec::new())
    }

    // .protocol.Account.AccountResource account_resource = 26;


    pub fn get_account_resource(&self) -> &Account_AccountResource {
        self.account_resource.as_ref().unwrap_or_else(|| <Account_AccountResource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_resource(&mut self) {
        self.account_resource.clear();
    }

    pub fn has_account_resource(&self) -> bool {
        self.account_resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_resource(&mut self, v: Account_AccountResource) {
        self.account_resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_resource(&mut self) -> &mut Account_AccountResource {
        if self.account_resource.is_none() {
            self.account_resource.set_default();
        }
        self.account_resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_resource(&mut self) -> Account_AccountResource {
        self.account_resource.take().unwrap_or_else(|| Account_AccountResource::new())
    }

    // bytes codeHash = 30;


    pub fn get_codeHash(&self) -> &[u8] {
        &self.codeHash
    }
    pub fn clear_codeHash(&mut self) {
        self.codeHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_codeHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.codeHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codeHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.codeHash
    }

    // Take field
    pub fn take_codeHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.codeHash, ::std::vec::Vec::new())
    }

    // .protocol.Permission owner_permission = 31;


    pub fn get_owner_permission(&self) -> &Permission {
        self.owner_permission.as_ref().unwrap_or_else(|| <Permission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner_permission(&mut self) {
        self.owner_permission.clear();
    }

    pub fn has_owner_permission(&self) -> bool {
        self.owner_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_permission(&mut self, v: Permission) {
        self.owner_permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_permission(&mut self) -> &mut Permission {
        if self.owner_permission.is_none() {
            self.owner_permission.set_default();
        }
        self.owner_permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_permission(&mut self) -> Permission {
        self.owner_permission.take().unwrap_or_else(|| Permission::new())
    }

    // .protocol.Permission witness_permission = 32;


    pub fn get_witness_permission(&self) -> &Permission {
        self.witness_permission.as_ref().unwrap_or_else(|| <Permission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_witness_permission(&mut self) {
        self.witness_permission.clear();
    }

    pub fn has_witness_permission(&self) -> bool {
        self.witness_permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_witness_permission(&mut self, v: Permission) {
        self.witness_permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness_permission(&mut self) -> &mut Permission {
        if self.witness_permission.is_none() {
            self.witness_permission.set_default();
        }
        self.witness_permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_witness_permission(&mut self) -> Permission {
        self.witness_permission.take().unwrap_or_else(|| Permission::new())
    }

    // repeated .protocol.Permission active_permission = 33;


    pub fn get_active_permission(&self) -> &[Permission] {
        &self.active_permission
    }
    pub fn clear_active_permission(&mut self) {
        self.active_permission.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_permission(&mut self, v: ::protobuf::RepeatedField<Permission>) {
        self.active_permission = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_permission(&mut self) -> &mut ::protobuf::RepeatedField<Permission> {
        &mut self.active_permission
    }

    // Take field
    pub fn take_active_permission(&mut self) -> ::protobuf::RepeatedField<Permission> {
        ::std::mem::replace(&mut self.active_permission, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Account {
    fn is_initialized(&self) -> bool {
        for v in &self.votes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frozen {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frozen_supply {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner_permission {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.witness_permission {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active_permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.balance = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.votes)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.asset)?;
                },
                56 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.assetV2)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frozen)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.net_usage = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.acquired_delegated_frozen_balance_for_bandwidth = tmp;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.delegated_frozen_balance_for_bandwidth = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.create_time = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_opration_time = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allowance = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_withdraw_time = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.code)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_witness = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_committee = tmp;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frozen_supply)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.asset_issued_name)?;
                },
                57 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.asset_issued_ID)?;
                },
                18 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.latest_asset_operation_time)?;
                },
                58 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.latest_asset_operation_timeV2)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.free_net_usage = tmp;
                },
                20 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.free_asset_net_usage)?;
                },
                59 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.free_asset_net_usageV2)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_consume_time = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_consume_free_time = tmp;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_id)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_resource)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.codeHash)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_permission)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.witness_permission)?;
                },
                33 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.active_permission)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account_name);
        }
        if self.field_type != AccountType::Normal {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.address);
        }
        if self.balance != 0 {
            my_size += ::protobuf::rt::value_size(4, self.balance, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.asset);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(56, &self.assetV2);
        for value in &self.frozen {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.net_usage != 0 {
            my_size += ::protobuf::rt::value_size(8, self.net_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.acquired_delegated_frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(41, self.acquired_delegated_frozen_balance_for_bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.delegated_frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(42, self.delegated_frozen_balance_for_bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::value_size(9, self.create_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_opration_time != 0 {
            my_size += ::protobuf::rt::value_size(10, self.latest_opration_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.allowance != 0 {
            my_size += ::protobuf::rt::value_size(11, self.allowance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_withdraw_time != 0 {
            my_size += ::protobuf::rt::value_size(12, self.latest_withdraw_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.code);
        }
        if self.is_witness != false {
            my_size += 2;
        }
        if self.is_committee != false {
            my_size += 2;
        }
        for value in &self.frozen_supply {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.asset_issued_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(17, &self.asset_issued_name);
        }
        if !self.asset_issued_ID.is_empty() {
            my_size += ::protobuf::rt::bytes_size(57, &self.asset_issued_ID);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(18, &self.latest_asset_operation_time);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(58, &self.latest_asset_operation_timeV2);
        if self.free_net_usage != 0 {
            my_size += ::protobuf::rt::value_size(19, self.free_net_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(20, &self.free_asset_net_usage);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(59, &self.free_asset_net_usageV2);
        if self.latest_consume_time != 0 {
            my_size += ::protobuf::rt::value_size(21, self.latest_consume_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_consume_free_time != 0 {
            my_size += ::protobuf::rt::value_size(22, self.latest_consume_free_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(23, &self.account_id);
        }
        if let Some(ref v) = self.account_resource.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.codeHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(30, &self.codeHash);
        }
        if let Some(ref v) = self.owner_permission.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.witness_permission.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.active_permission {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account_name.is_empty() {
            os.write_bytes(1, &self.account_name)?;
        }
        if self.field_type != AccountType::Normal {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.address.is_empty() {
            os.write_bytes(3, &self.address)?;
        }
        if self.balance != 0 {
            os.write_int64(4, self.balance)?;
        }
        for v in &self.votes {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(6, &self.asset, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(56, &self.assetV2, os)?;
        for v in &self.frozen {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.net_usage != 0 {
            os.write_int64(8, self.net_usage)?;
        }
        if self.acquired_delegated_frozen_balance_for_bandwidth != 0 {
            os.write_int64(41, self.acquired_delegated_frozen_balance_for_bandwidth)?;
        }
        if self.delegated_frozen_balance_for_bandwidth != 0 {
            os.write_int64(42, self.delegated_frozen_balance_for_bandwidth)?;
        }
        if self.create_time != 0 {
            os.write_int64(9, self.create_time)?;
        }
        if self.latest_opration_time != 0 {
            os.write_int64(10, self.latest_opration_time)?;
        }
        if self.allowance != 0 {
            os.write_int64(11, self.allowance)?;
        }
        if self.latest_withdraw_time != 0 {
            os.write_int64(12, self.latest_withdraw_time)?;
        }
        if !self.code.is_empty() {
            os.write_bytes(13, &self.code)?;
        }
        if self.is_witness != false {
            os.write_bool(14, self.is_witness)?;
        }
        if self.is_committee != false {
            os.write_bool(15, self.is_committee)?;
        }
        for v in &self.frozen_supply {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.asset_issued_name.is_empty() {
            os.write_bytes(17, &self.asset_issued_name)?;
        }
        if !self.asset_issued_ID.is_empty() {
            os.write_bytes(57, &self.asset_issued_ID)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(18, &self.latest_asset_operation_time, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(58, &self.latest_asset_operation_timeV2, os)?;
        if self.free_net_usage != 0 {
            os.write_int64(19, self.free_net_usage)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(20, &self.free_asset_net_usage, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(59, &self.free_asset_net_usageV2, os)?;
        if self.latest_consume_time != 0 {
            os.write_int64(21, self.latest_consume_time)?;
        }
        if self.latest_consume_free_time != 0 {
            os.write_int64(22, self.latest_consume_free_time)?;
        }
        if !self.account_id.is_empty() {
            os.write_bytes(23, &self.account_id)?;
        }
        if let Some(ref v) = self.account_resource.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.codeHash.is_empty() {
            os.write_bytes(30, &self.codeHash)?;
        }
        if let Some(ref v) = self.owner_permission.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.witness_permission.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.active_permission {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account {
        Account::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "account_name",
                |m: &Account| { &m.account_name },
                |m: &mut Account| { &mut m.account_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccountType>>(
                "type",
                |m: &Account| { &m.field_type },
                |m: &mut Account| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &Account| { &m.address },
                |m: &mut Account| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "balance",
                |m: &Account| { &m.balance },
                |m: &mut Account| { &mut m.balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vote>>(
                "votes",
                |m: &Account| { &m.votes },
                |m: &mut Account| { &mut m.votes },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "asset",
                |m: &Account| { &m.asset },
                |m: &mut Account| { &mut m.asset },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "assetV2",
                |m: &Account| { &m.assetV2 },
                |m: &mut Account| { &mut m.assetV2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Account_Frozen>>(
                "frozen",
                |m: &Account| { &m.frozen },
                |m: &mut Account| { &mut m.frozen },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "net_usage",
                |m: &Account| { &m.net_usage },
                |m: &mut Account| { &mut m.net_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "acquired_delegated_frozen_balance_for_bandwidth",
                |m: &Account| { &m.acquired_delegated_frozen_balance_for_bandwidth },
                |m: &mut Account| { &mut m.acquired_delegated_frozen_balance_for_bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "delegated_frozen_balance_for_bandwidth",
                |m: &Account| { &m.delegated_frozen_balance_for_bandwidth },
                |m: &mut Account| { &mut m.delegated_frozen_balance_for_bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "create_time",
                |m: &Account| { &m.create_time },
                |m: &mut Account| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latest_opration_time",
                |m: &Account| { &m.latest_opration_time },
                |m: &mut Account| { &mut m.latest_opration_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "allowance",
                |m: &Account| { &m.allowance },
                |m: &mut Account| { &mut m.allowance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latest_withdraw_time",
                |m: &Account| { &m.latest_withdraw_time },
                |m: &mut Account| { &mut m.latest_withdraw_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "code",
                |m: &Account| { &m.code },
                |m: &mut Account| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_witness",
                |m: &Account| { &m.is_witness },
                |m: &mut Account| { &mut m.is_witness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_committee",
                |m: &Account| { &m.is_committee },
                |m: &mut Account| { &mut m.is_committee },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Account_Frozen>>(
                "frozen_supply",
                |m: &Account| { &m.frozen_supply },
                |m: &mut Account| { &mut m.frozen_supply },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "asset_issued_name",
                |m: &Account| { &m.asset_issued_name },
                |m: &mut Account| { &mut m.asset_issued_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "asset_issued_ID",
                |m: &Account| { &m.asset_issued_ID },
                |m: &mut Account| { &mut m.asset_issued_ID },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "latest_asset_operation_time",
                |m: &Account| { &m.latest_asset_operation_time },
                |m: &mut Account| { &mut m.latest_asset_operation_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "latest_asset_operation_timeV2",
                |m: &Account| { &m.latest_asset_operation_timeV2 },
                |m: &mut Account| { &mut m.latest_asset_operation_timeV2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "free_net_usage",
                |m: &Account| { &m.free_net_usage },
                |m: &mut Account| { &mut m.free_net_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "free_asset_net_usage",
                |m: &Account| { &m.free_asset_net_usage },
                |m: &mut Account| { &mut m.free_asset_net_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt64>(
                "free_asset_net_usageV2",
                |m: &Account| { &m.free_asset_net_usageV2 },
                |m: &mut Account| { &mut m.free_asset_net_usageV2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latest_consume_time",
                |m: &Account| { &m.latest_consume_time },
                |m: &mut Account| { &mut m.latest_consume_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latest_consume_free_time",
                |m: &Account| { &m.latest_consume_free_time },
                |m: &mut Account| { &mut m.latest_consume_free_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "account_id",
                |m: &Account| { &m.account_id },
                |m: &mut Account| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Account_AccountResource>>(
                "account_resource",
                |m: &Account| { &m.account_resource },
                |m: &mut Account| { &mut m.account_resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "codeHash",
                |m: &Account| { &m.codeHash },
                |m: &mut Account| { &mut m.codeHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                "owner_permission",
                |m: &Account| { &m.owner_permission },
                |m: &mut Account| { &mut m.owner_permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                "witness_permission",
                |m: &Account| { &m.witness_permission },
                |m: &mut Account| { &mut m.witness_permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                "active_permission",
                |m: &Account| { &m.active_permission },
                |m: &mut Account| { &mut m.active_permission },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Account>(
                "Account",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Account {
        static instance: ::protobuf::rt::LazyV2<Account> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Account::new)
    }
}

impl ::protobuf::Clear for Account {
    fn clear(&mut self) {
        self.account_name.clear();
        self.field_type = AccountType::Normal;
        self.address.clear();
        self.balance = 0;
        self.votes.clear();
        self.asset.clear();
        self.assetV2.clear();
        self.frozen.clear();
        self.net_usage = 0;
        self.acquired_delegated_frozen_balance_for_bandwidth = 0;
        self.delegated_frozen_balance_for_bandwidth = 0;
        self.create_time = 0;
        self.latest_opration_time = 0;
        self.allowance = 0;
        self.latest_withdraw_time = 0;
        self.code.clear();
        self.is_witness = false;
        self.is_committee = false;
        self.frozen_supply.clear();
        self.asset_issued_name.clear();
        self.asset_issued_ID.clear();
        self.latest_asset_operation_time.clear();
        self.latest_asset_operation_timeV2.clear();
        self.free_net_usage = 0;
        self.free_asset_net_usage.clear();
        self.free_asset_net_usageV2.clear();
        self.latest_consume_time = 0;
        self.latest_consume_free_time = 0;
        self.account_id.clear();
        self.account_resource.clear();
        self.codeHash.clear();
        self.owner_permission.clear();
        self.witness_permission.clear();
        self.active_permission.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Account_Frozen {
    // message fields
    pub frozen_balance: i64,
    pub expire_time: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Account_Frozen {
    fn default() -> &'a Account_Frozen {
        <Account_Frozen as ::protobuf::Message>::default_instance()
    }
}

impl Account_Frozen {
    pub fn new() -> Account_Frozen {
        ::std::default::Default::default()
    }

    // int64 frozen_balance = 1;


    pub fn get_frozen_balance(&self) -> i64 {
        self.frozen_balance
    }
    pub fn clear_frozen_balance(&mut self) {
        self.frozen_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance(&mut self, v: i64) {
        self.frozen_balance = v;
    }

    // int64 expire_time = 2;


    pub fn get_expire_time(&self) -> i64 {
        self.expire_time
    }
    pub fn clear_expire_time(&mut self) {
        self.expire_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: i64) {
        self.expire_time = v;
    }
}

impl ::protobuf::Message for Account_Frozen {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_balance = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expire_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.frozen_balance != 0 {
            my_size += ::protobuf::rt::value_size(1, self.frozen_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expire_time != 0 {
            my_size += ::protobuf::rt::value_size(2, self.expire_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.frozen_balance != 0 {
            os.write_int64(1, self.frozen_balance)?;
        }
        if self.expire_time != 0 {
            os.write_int64(2, self.expire_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account_Frozen {
        Account_Frozen::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "frozen_balance",
                |m: &Account_Frozen| { &m.frozen_balance },
                |m: &mut Account_Frozen| { &mut m.frozen_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expire_time",
                |m: &Account_Frozen| { &m.expire_time },
                |m: &mut Account_Frozen| { &mut m.expire_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Account_Frozen>(
                "Account.Frozen",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Account_Frozen {
        static instance: ::protobuf::rt::LazyV2<Account_Frozen> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Account_Frozen::new)
    }
}

impl ::protobuf::Clear for Account_Frozen {
    fn clear(&mut self) {
        self.frozen_balance = 0;
        self.expire_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account_Frozen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account_Frozen {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Account_AccountResource {
    // message fields
    pub energy_usage: i64,
    pub frozen_balance_for_energy: ::protobuf::SingularPtrField<Account_Frozen>,
    pub latest_consume_time_for_energy: i64,
    pub acquired_delegated_frozen_balance_for_energy: i64,
    pub delegated_frozen_balance_for_energy: i64,
    pub storage_limit: i64,
    pub storage_usage: i64,
    pub latest_exchange_storage_time: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Account_AccountResource {
    fn default() -> &'a Account_AccountResource {
        <Account_AccountResource as ::protobuf::Message>::default_instance()
    }
}

impl Account_AccountResource {
    pub fn new() -> Account_AccountResource {
        ::std::default::Default::default()
    }

    // int64 energy_usage = 1;


    pub fn get_energy_usage(&self) -> i64 {
        self.energy_usage
    }
    pub fn clear_energy_usage(&mut self) {
        self.energy_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy_usage(&mut self, v: i64) {
        self.energy_usage = v;
    }

    // .protocol.Account.Frozen frozen_balance_for_energy = 2;


    pub fn get_frozen_balance_for_energy(&self) -> &Account_Frozen {
        self.frozen_balance_for_energy.as_ref().unwrap_or_else(|| <Account_Frozen as ::protobuf::Message>::default_instance())
    }
    pub fn clear_frozen_balance_for_energy(&mut self) {
        self.frozen_balance_for_energy.clear();
    }

    pub fn has_frozen_balance_for_energy(&self) -> bool {
        self.frozen_balance_for_energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance_for_energy(&mut self, v: Account_Frozen) {
        self.frozen_balance_for_energy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frozen_balance_for_energy(&mut self) -> &mut Account_Frozen {
        if self.frozen_balance_for_energy.is_none() {
            self.frozen_balance_for_energy.set_default();
        }
        self.frozen_balance_for_energy.as_mut().unwrap()
    }

    // Take field
    pub fn take_frozen_balance_for_energy(&mut self) -> Account_Frozen {
        self.frozen_balance_for_energy.take().unwrap_or_else(|| Account_Frozen::new())
    }

    // int64 latest_consume_time_for_energy = 3;


    pub fn get_latest_consume_time_for_energy(&self) -> i64 {
        self.latest_consume_time_for_energy
    }
    pub fn clear_latest_consume_time_for_energy(&mut self) {
        self.latest_consume_time_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_consume_time_for_energy(&mut self, v: i64) {
        self.latest_consume_time_for_energy = v;
    }

    // int64 acquired_delegated_frozen_balance_for_energy = 4;


    pub fn get_acquired_delegated_frozen_balance_for_energy(&self) -> i64 {
        self.acquired_delegated_frozen_balance_for_energy
    }
    pub fn clear_acquired_delegated_frozen_balance_for_energy(&mut self) {
        self.acquired_delegated_frozen_balance_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_acquired_delegated_frozen_balance_for_energy(&mut self, v: i64) {
        self.acquired_delegated_frozen_balance_for_energy = v;
    }

    // int64 delegated_frozen_balance_for_energy = 5;


    pub fn get_delegated_frozen_balance_for_energy(&self) -> i64 {
        self.delegated_frozen_balance_for_energy
    }
    pub fn clear_delegated_frozen_balance_for_energy(&mut self) {
        self.delegated_frozen_balance_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_delegated_frozen_balance_for_energy(&mut self, v: i64) {
        self.delegated_frozen_balance_for_energy = v;
    }

    // int64 storage_limit = 6;


    pub fn get_storage_limit(&self) -> i64 {
        self.storage_limit
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: i64) {
        self.storage_limit = v;
    }

    // int64 storage_usage = 7;


    pub fn get_storage_usage(&self) -> i64 {
        self.storage_usage
    }
    pub fn clear_storage_usage(&mut self) {
        self.storage_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_usage(&mut self, v: i64) {
        self.storage_usage = v;
    }

    // int64 latest_exchange_storage_time = 8;


    pub fn get_latest_exchange_storage_time(&self) -> i64 {
        self.latest_exchange_storage_time
    }
    pub fn clear_latest_exchange_storage_time(&mut self) {
        self.latest_exchange_storage_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_exchange_storage_time(&mut self, v: i64) {
        self.latest_exchange_storage_time = v;
    }
}

impl ::protobuf::Message for Account_AccountResource {
    fn is_initialized(&self) -> bool {
        for v in &self.frozen_balance_for_energy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.energy_usage = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frozen_balance_for_energy)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_consume_time_for_energy = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.acquired_delegated_frozen_balance_for_energy = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.delegated_frozen_balance_for_energy = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage_limit = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage_usage = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_exchange_storage_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.energy_usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.energy_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.frozen_balance_for_energy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.latest_consume_time_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(3, self.latest_consume_time_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.acquired_delegated_frozen_balance_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(4, self.acquired_delegated_frozen_balance_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.delegated_frozen_balance_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(5, self.delegated_frozen_balance_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storage_limit != 0 {
            my_size += ::protobuf::rt::value_size(6, self.storage_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.storage_usage != 0 {
            my_size += ::protobuf::rt::value_size(7, self.storage_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_exchange_storage_time != 0 {
            my_size += ::protobuf::rt::value_size(8, self.latest_exchange_storage_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.energy_usage != 0 {
            os.write_int64(1, self.energy_usage)?;
        }
        if let Some(ref v) = self.frozen_balance_for_energy.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.latest_consume_time_for_energy != 0 {
            os.write_int64(3, self.latest_consume_time_for_energy)?;
        }
        if self.acquired_delegated_frozen_balance_for_energy != 0 {
            os.write_int64(4, self.acquired_delegated_frozen_balance_for_energy)?;
        }
        if self.delegated_frozen_balance_for_energy != 0 {
            os.write_int64(5, self.delegated_frozen_balance_for_energy)?;
        }
        if self.storage_limit != 0 {
            os.write_int64(6, self.storage_limit)?;
        }
        if self.storage_usage != 0 {
            os.write_int64(7, self.storage_usage)?;
        }
        if self.latest_exchange_storage_time != 0 {
            os.write_int64(8, self.latest_exchange_storage_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account_AccountResource {
        Account_AccountResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "energy_usage",
                |m: &Account_AccountResource| { &m.energy_usage },
                |m: &mut Account_AccountResource| { &mut m.energy_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Account_Frozen>>(
                "frozen_balance_for_energy",
                |m: &Account_AccountResource| { &m.frozen_balance_for_energy },
                |m: &mut Account_AccountResource| { &mut m.frozen_balance_for_energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latest_consume_time_for_energy",
                |m: &Account_AccountResource| { &m.latest_consume_time_for_energy },
                |m: &mut Account_AccountResource| { &mut m.latest_consume_time_for_energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "acquired_delegated_frozen_balance_for_energy",
                |m: &Account_AccountResource| { &m.acquired_delegated_frozen_balance_for_energy },
                |m: &mut Account_AccountResource| { &mut m.acquired_delegated_frozen_balance_for_energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "delegated_frozen_balance_for_energy",
                |m: &Account_AccountResource| { &m.delegated_frozen_balance_for_energy },
                |m: &mut Account_AccountResource| { &mut m.delegated_frozen_balance_for_energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "storage_limit",
                |m: &Account_AccountResource| { &m.storage_limit },
                |m: &mut Account_AccountResource| { &mut m.storage_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "storage_usage",
                |m: &Account_AccountResource| { &m.storage_usage },
                |m: &mut Account_AccountResource| { &mut m.storage_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latest_exchange_storage_time",
                |m: &Account_AccountResource| { &m.latest_exchange_storage_time },
                |m: &mut Account_AccountResource| { &mut m.latest_exchange_storage_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Account_AccountResource>(
                "Account.AccountResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Account_AccountResource {
        static instance: ::protobuf::rt::LazyV2<Account_AccountResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Account_AccountResource::new)
    }
}

impl ::protobuf::Clear for Account_AccountResource {
    fn clear(&mut self) {
        self.energy_usage = 0;
        self.frozen_balance_for_energy.clear();
        self.latest_consume_time_for_energy = 0;
        self.acquired_delegated_frozen_balance_for_energy = 0;
        self.delegated_frozen_balance_for_energy = 0;
        self.storage_limit = 0;
        self.storage_usage = 0;
        self.latest_exchange_storage_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account_AccountResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account_AccountResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Key {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub weight: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // int64 weight = 2;


    pub fn get_weight(&self) -> i64 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i64) {
        self.weight = v;
    }
}

impl ::protobuf::Message for Key {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.weight = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::value_size(2, self.weight, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.weight != 0 {
            os.write_int64(2, self.weight)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key {
        Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &Key| { &m.address },
                |m: &mut Key| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "weight",
                |m: &Key| { &m.weight },
                |m: &mut Key| { &mut m.weight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Key>(
                "Key",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Key {
        static instance: ::protobuf::rt::LazyV2<Key> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Key::new)
    }
}

impl ::protobuf::Clear for Key {
    fn clear(&mut self) {
        self.address.clear();
        self.weight = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DelegatedResource {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub frozen_balance_for_bandwidth: i64,
    pub frozen_balance_for_energy: i64,
    pub expire_time_for_bandwidth: i64,
    pub expire_time_for_energy: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegatedResource {
    fn default() -> &'a DelegatedResource {
        <DelegatedResource as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResource {
    pub fn new() -> DelegatedResource {
        ::std::default::Default::default()
    }

    // bytes from = 1;


    pub fn get_from(&self) -> &[u8] {
        &self.from
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    // bytes to = 2;


    pub fn get_to(&self) -> &[u8] {
        &self.to
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    // int64 frozen_balance_for_bandwidth = 3;


    pub fn get_frozen_balance_for_bandwidth(&self) -> i64 {
        self.frozen_balance_for_bandwidth
    }
    pub fn clear_frozen_balance_for_bandwidth(&mut self) {
        self.frozen_balance_for_bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance_for_bandwidth(&mut self, v: i64) {
        self.frozen_balance_for_bandwidth = v;
    }

    // int64 frozen_balance_for_energy = 4;


    pub fn get_frozen_balance_for_energy(&self) -> i64 {
        self.frozen_balance_for_energy
    }
    pub fn clear_frozen_balance_for_energy(&mut self) {
        self.frozen_balance_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance_for_energy(&mut self, v: i64) {
        self.frozen_balance_for_energy = v;
    }

    // int64 expire_time_for_bandwidth = 5;


    pub fn get_expire_time_for_bandwidth(&self) -> i64 {
        self.expire_time_for_bandwidth
    }
    pub fn clear_expire_time_for_bandwidth(&mut self) {
        self.expire_time_for_bandwidth = 0;
    }

    // Param is passed by value, moved
    pub fn set_expire_time_for_bandwidth(&mut self, v: i64) {
        self.expire_time_for_bandwidth = v;
    }

    // int64 expire_time_for_energy = 6;


    pub fn get_expire_time_for_energy(&self) -> i64 {
        self.expire_time_for_energy
    }
    pub fn clear_expire_time_for_energy(&mut self) {
        self.expire_time_for_energy = 0;
    }

    // Param is passed by value, moved
    pub fn set_expire_time_for_energy(&mut self, v: i64) {
        self.expire_time_for_energy = v;
    }
}

impl ::protobuf::Message for DelegatedResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_balance_for_bandwidth = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_balance_for_energy = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expire_time_for_bandwidth = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expire_time_for_energy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        if self.frozen_balance_for_bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(3, self.frozen_balance_for_bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frozen_balance_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(4, self.frozen_balance_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expire_time_for_bandwidth != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expire_time_for_bandwidth, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expire_time_for_energy != 0 {
            my_size += ::protobuf::rt::value_size(6, self.expire_time_for_energy, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        if self.frozen_balance_for_bandwidth != 0 {
            os.write_int64(3, self.frozen_balance_for_bandwidth)?;
        }
        if self.frozen_balance_for_energy != 0 {
            os.write_int64(4, self.frozen_balance_for_energy)?;
        }
        if self.expire_time_for_bandwidth != 0 {
            os.write_int64(5, self.expire_time_for_bandwidth)?;
        }
        if self.expire_time_for_energy != 0 {
            os.write_int64(6, self.expire_time_for_energy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegatedResource {
        DelegatedResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "from",
                |m: &DelegatedResource| { &m.from },
                |m: &mut DelegatedResource| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "to",
                |m: &DelegatedResource| { &m.to },
                |m: &mut DelegatedResource| { &mut m.to },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "frozen_balance_for_bandwidth",
                |m: &DelegatedResource| { &m.frozen_balance_for_bandwidth },
                |m: &mut DelegatedResource| { &mut m.frozen_balance_for_bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "frozen_balance_for_energy",
                |m: &DelegatedResource| { &m.frozen_balance_for_energy },
                |m: &mut DelegatedResource| { &mut m.frozen_balance_for_energy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expire_time_for_bandwidth",
                |m: &DelegatedResource| { &m.expire_time_for_bandwidth },
                |m: &mut DelegatedResource| { &mut m.expire_time_for_bandwidth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expire_time_for_energy",
                |m: &DelegatedResource| { &m.expire_time_for_energy },
                |m: &mut DelegatedResource| { &mut m.expire_time_for_energy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DelegatedResource>(
                "DelegatedResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DelegatedResource {
        static instance: ::protobuf::rt::LazyV2<DelegatedResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DelegatedResource::new)
    }
}

impl ::protobuf::Clear for DelegatedResource {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.frozen_balance_for_bandwidth = 0;
        self.frozen_balance_for_energy = 0;
        self.expire_time_for_bandwidth = 0;
        self.expire_time_for_energy = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegatedResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct authority {
    // message fields
    pub account: ::protobuf::SingularPtrField<AccountId>,
    pub permission_name: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a authority {
    fn default() -> &'a authority {
        <authority as ::protobuf::Message>::default_instance()
    }
}

impl authority {
    pub fn new() -> authority {
        ::std::default::Default::default()
    }

    // .protocol.AccountId account = 1;


    pub fn get_account(&self) -> &AccountId {
        self.account.as_ref().unwrap_or_else(|| <AccountId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: AccountId) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut AccountId {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> AccountId {
        self.account.take().unwrap_or_else(|| AccountId::new())
    }

    // bytes permission_name = 2;


    pub fn get_permission_name(&self) -> &[u8] {
        &self.permission_name
    }
    pub fn clear_permission_name(&mut self) {
        self.permission_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_permission_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.permission_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.permission_name
    }

    // Take field
    pub fn take_permission_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.permission_name, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for authority {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.permission_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.permission_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.permission_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.permission_name.is_empty() {
            os.write_bytes(2, &self.permission_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> authority {
        authority::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountId>>(
                "account",
                |m: &authority| { &m.account },
                |m: &mut authority| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "permission_name",
                |m: &authority| { &m.permission_name },
                |m: &mut authority| { &mut m.permission_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<authority>(
                "authority",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static authority {
        static instance: ::protobuf::rt::LazyV2<authority> = ::protobuf::rt::LazyV2::INIT;
        instance.get(authority::new)
    }
}

impl ::protobuf::Clear for authority {
    fn clear(&mut self) {
        self.account.clear();
        self.permission_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for authority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for authority {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Permission {
    // message fields
    pub field_type: Permission_PermissionType,
    pub id: i32,
    pub permission_name: ::std::string::String,
    pub threshold: i64,
    pub parent_id: i32,
    pub operations: ::std::vec::Vec<u8>,
    pub keys: ::protobuf::RepeatedField<Key>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Permission {
    fn default() -> &'a Permission {
        <Permission as ::protobuf::Message>::default_instance()
    }
}

impl Permission {
    pub fn new() -> Permission {
        ::std::default::Default::default()
    }

    // .protocol.Permission.PermissionType type = 1;


    pub fn get_field_type(&self) -> Permission_PermissionType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Permission_PermissionType::Owner;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Permission_PermissionType) {
        self.field_type = v;
    }

    // int32 id = 2;


    pub fn get_id(&self) -> i32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    // string permission_name = 3;


    pub fn get_permission_name(&self) -> &str {
        &self.permission_name
    }
    pub fn clear_permission_name(&mut self) {
        self.permission_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_permission_name(&mut self, v: ::std::string::String) {
        self.permission_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission_name(&mut self) -> &mut ::std::string::String {
        &mut self.permission_name
    }

    // Take field
    pub fn take_permission_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.permission_name, ::std::string::String::new())
    }

    // int64 threshold = 4;


    pub fn get_threshold(&self) -> i64 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: i64) {
        self.threshold = v;
    }

    // int32 parent_id = 5;


    pub fn get_parent_id(&self) -> i32 {
        self.parent_id
    }
    pub fn clear_parent_id(&mut self) {
        self.parent_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_parent_id(&mut self, v: i32) {
        self.parent_id = v;
    }

    // bytes operations = 6;


    pub fn get_operations(&self) -> &[u8] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::std::vec::Vec<u8>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operations(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.operations, ::std::vec::Vec::new())
    }

    // repeated .protocol.Key keys = 7;


    pub fn get_keys(&self) -> &[Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Permission {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.permission_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.threshold = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.parent_id = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.operations)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Permission_PermissionType::Owner {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.permission_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.permission_name);
        }
        if self.threshold != 0 {
            my_size += ::protobuf::rt::value_size(4, self.threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.parent_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.parent_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.operations.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.operations);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Permission_PermissionType::Owner {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.id != 0 {
            os.write_int32(2, self.id)?;
        }
        if !self.permission_name.is_empty() {
            os.write_string(3, &self.permission_name)?;
        }
        if self.threshold != 0 {
            os.write_int64(4, self.threshold)?;
        }
        if self.parent_id != 0 {
            os.write_int32(5, self.parent_id)?;
        }
        if !self.operations.is_empty() {
            os.write_bytes(6, &self.operations)?;
        }
        for v in &self.keys {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Permission {
        Permission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Permission_PermissionType>>(
                "type",
                |m: &Permission| { &m.field_type },
                |m: &mut Permission| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "id",
                |m: &Permission| { &m.id },
                |m: &mut Permission| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "permission_name",
                |m: &Permission| { &m.permission_name },
                |m: &mut Permission| { &mut m.permission_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "threshold",
                |m: &Permission| { &m.threshold },
                |m: &mut Permission| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "parent_id",
                |m: &Permission| { &m.parent_id },
                |m: &mut Permission| { &mut m.parent_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "operations",
                |m: &Permission| { &m.operations },
                |m: &mut Permission| { &mut m.operations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "keys",
                |m: &Permission| { &m.keys },
                |m: &mut Permission| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Permission>(
                "Permission",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Permission {
        static instance: ::protobuf::rt::LazyV2<Permission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Permission::new)
    }
}

impl ::protobuf::Clear for Permission {
    fn clear(&mut self) {
        self.field_type = Permission_PermissionType::Owner;
        self.id = 0;
        self.permission_name.clear();
        self.threshold = 0;
        self.parent_id = 0;
        self.operations.clear();
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Permission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Permission_PermissionType {
    Owner = 0,
    Witness = 1,
    Active = 2,
}

impl ::protobuf::ProtobufEnum for Permission_PermissionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Permission_PermissionType> {
        match value {
            0 => ::std::option::Option::Some(Permission_PermissionType::Owner),
            1 => ::std::option::Option::Some(Permission_PermissionType::Witness),
            2 => ::std::option::Option::Some(Permission_PermissionType::Active),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Permission_PermissionType] = &[
            Permission_PermissionType::Owner,
            Permission_PermissionType::Witness,
            Permission_PermissionType::Active,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Permission_PermissionType>("Permission.PermissionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Permission_PermissionType {
}

impl ::std::default::Default for Permission_PermissionType {
    fn default() -> Self {
        Permission_PermissionType::Owner
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission_PermissionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Witness {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub voteCount: i64,
    pub pubKey: ::std::vec::Vec<u8>,
    pub url: ::std::string::String,
    pub totalProduced: i64,
    pub totalMissed: i64,
    pub latestBlockNum: i64,
    pub latestSlotNum: i64,
    pub isJobs: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Witness {
    fn default() -> &'a Witness {
        <Witness as ::protobuf::Message>::default_instance()
    }
}

impl Witness {
    pub fn new() -> Witness {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // int64 voteCount = 2;


    pub fn get_voteCount(&self) -> i64 {
        self.voteCount
    }
    pub fn clear_voteCount(&mut self) {
        self.voteCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_voteCount(&mut self, v: i64) {
        self.voteCount = v;
    }

    // bytes pubKey = 3;


    pub fn get_pubKey(&self) -> &[u8] {
        &self.pubKey
    }
    pub fn clear_pubKey(&mut self) {
        self.pubKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubKey
    }

    // Take field
    pub fn take_pubKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubKey, ::std::vec::Vec::new())
    }

    // string url = 4;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // int64 totalProduced = 5;


    pub fn get_totalProduced(&self) -> i64 {
        self.totalProduced
    }
    pub fn clear_totalProduced(&mut self) {
        self.totalProduced = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalProduced(&mut self, v: i64) {
        self.totalProduced = v;
    }

    // int64 totalMissed = 6;


    pub fn get_totalMissed(&self) -> i64 {
        self.totalMissed
    }
    pub fn clear_totalMissed(&mut self) {
        self.totalMissed = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalMissed(&mut self, v: i64) {
        self.totalMissed = v;
    }

    // int64 latestBlockNum = 7;


    pub fn get_latestBlockNum(&self) -> i64 {
        self.latestBlockNum
    }
    pub fn clear_latestBlockNum(&mut self) {
        self.latestBlockNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_latestBlockNum(&mut self, v: i64) {
        self.latestBlockNum = v;
    }

    // int64 latestSlotNum = 8;


    pub fn get_latestSlotNum(&self) -> i64 {
        self.latestSlotNum
    }
    pub fn clear_latestSlotNum(&mut self) {
        self.latestSlotNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_latestSlotNum(&mut self, v: i64) {
        self.latestSlotNum = v;
    }

    // bool isJobs = 9;


    pub fn get_isJobs(&self) -> bool {
        self.isJobs
    }
    pub fn clear_isJobs(&mut self) {
        self.isJobs = false;
    }

    // Param is passed by value, moved
    pub fn set_isJobs(&mut self, v: bool) {
        self.isJobs = v;
    }
}

impl ::protobuf::Message for Witness {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.voteCount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubKey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalProduced = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalMissed = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latestBlockNum = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latestSlotNum = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isJobs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.voteCount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.voteCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pubKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.pubKey);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.url);
        }
        if self.totalProduced != 0 {
            my_size += ::protobuf::rt::value_size(5, self.totalProduced, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalMissed != 0 {
            my_size += ::protobuf::rt::value_size(6, self.totalMissed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latestBlockNum != 0 {
            my_size += ::protobuf::rt::value_size(7, self.latestBlockNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latestSlotNum != 0 {
            my_size += ::protobuf::rt::value_size(8, self.latestSlotNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.isJobs != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.voteCount != 0 {
            os.write_int64(2, self.voteCount)?;
        }
        if !self.pubKey.is_empty() {
            os.write_bytes(3, &self.pubKey)?;
        }
        if !self.url.is_empty() {
            os.write_string(4, &self.url)?;
        }
        if self.totalProduced != 0 {
            os.write_int64(5, self.totalProduced)?;
        }
        if self.totalMissed != 0 {
            os.write_int64(6, self.totalMissed)?;
        }
        if self.latestBlockNum != 0 {
            os.write_int64(7, self.latestBlockNum)?;
        }
        if self.latestSlotNum != 0 {
            os.write_int64(8, self.latestSlotNum)?;
        }
        if self.isJobs != false {
            os.write_bool(9, self.isJobs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Witness {
        Witness::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &Witness| { &m.address },
                |m: &mut Witness| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "voteCount",
                |m: &Witness| { &m.voteCount },
                |m: &mut Witness| { &mut m.voteCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pubKey",
                |m: &Witness| { &m.pubKey },
                |m: &mut Witness| { &mut m.pubKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Witness| { &m.url },
                |m: &mut Witness| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalProduced",
                |m: &Witness| { &m.totalProduced },
                |m: &mut Witness| { &mut m.totalProduced },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalMissed",
                |m: &Witness| { &m.totalMissed },
                |m: &mut Witness| { &mut m.totalMissed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latestBlockNum",
                |m: &Witness| { &m.latestBlockNum },
                |m: &mut Witness| { &mut m.latestBlockNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latestSlotNum",
                |m: &Witness| { &m.latestSlotNum },
                |m: &mut Witness| { &mut m.latestSlotNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isJobs",
                |m: &Witness| { &m.isJobs },
                |m: &mut Witness| { &mut m.isJobs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Witness>(
                "Witness",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Witness {
        static instance: ::protobuf::rt::LazyV2<Witness> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Witness::new)
    }
}

impl ::protobuf::Clear for Witness {
    fn clear(&mut self) {
        self.address.clear();
        self.voteCount = 0;
        self.pubKey.clear();
        self.url.clear();
        self.totalProduced = 0;
        self.totalMissed = 0;
        self.latestBlockNum = 0;
        self.latestSlotNum = 0;
        self.isJobs = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Witness {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Witness {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Votes {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub old_votes: ::protobuf::RepeatedField<Vote>,
    pub new_votes: ::protobuf::RepeatedField<Vote>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Votes {
    fn default() -> &'a Votes {
        <Votes as ::protobuf::Message>::default_instance()
    }
}

impl Votes {
    pub fn new() -> Votes {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // repeated .protocol.Vote old_votes = 2;


    pub fn get_old_votes(&self) -> &[Vote] {
        &self.old_votes
    }
    pub fn clear_old_votes(&mut self) {
        self.old_votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_old_votes(&mut self, v: ::protobuf::RepeatedField<Vote>) {
        self.old_votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_old_votes(&mut self) -> &mut ::protobuf::RepeatedField<Vote> {
        &mut self.old_votes
    }

    // Take field
    pub fn take_old_votes(&mut self) -> ::protobuf::RepeatedField<Vote> {
        ::std::mem::replace(&mut self.old_votes, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.Vote new_votes = 3;


    pub fn get_new_votes(&self) -> &[Vote] {
        &self.new_votes
    }
    pub fn clear_new_votes(&mut self) {
        self.new_votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_votes(&mut self, v: ::protobuf::RepeatedField<Vote>) {
        self.new_votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_new_votes(&mut self) -> &mut ::protobuf::RepeatedField<Vote> {
        &mut self.new_votes
    }

    // Take field
    pub fn take_new_votes(&mut self) -> ::protobuf::RepeatedField<Vote> {
        ::std::mem::replace(&mut self.new_votes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Votes {
    fn is_initialized(&self) -> bool {
        for v in &self.old_votes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.old_votes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.new_votes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.old_votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.new_votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.old_votes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.new_votes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Votes {
        Votes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &Votes| { &m.address },
                |m: &mut Votes| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vote>>(
                "old_votes",
                |m: &Votes| { &m.old_votes },
                |m: &mut Votes| { &mut m.old_votes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vote>>(
                "new_votes",
                |m: &Votes| { &m.new_votes },
                |m: &mut Votes| { &mut m.new_votes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Votes>(
                "Votes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Votes {
        static instance: ::protobuf::rt::LazyV2<Votes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Votes::new)
    }
}

impl ::protobuf::Clear for Votes {
    fn clear(&mut self) {
        self.address.clear();
        self.old_votes.clear();
        self.new_votes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Votes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Votes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TXOutput {
    // message fields
    pub value: i64,
    pub pubKeyHash: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TXOutput {
    fn default() -> &'a TXOutput {
        <TXOutput as ::protobuf::Message>::default_instance()
    }
}

impl TXOutput {
    pub fn new() -> TXOutput {
        ::std::default::Default::default()
    }

    // int64 value = 1;


    pub fn get_value(&self) -> i64 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = v;
    }

    // bytes pubKeyHash = 2;


    pub fn get_pubKeyHash(&self) -> &[u8] {
        &self.pubKeyHash
    }
    pub fn clear_pubKeyHash(&mut self) {
        self.pubKeyHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubKeyHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubKeyHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubKeyHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubKeyHash
    }

    // Take field
    pub fn take_pubKeyHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubKeyHash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TXOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubKeyHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pubKeyHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pubKeyHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_int64(1, self.value)?;
        }
        if !self.pubKeyHash.is_empty() {
            os.write_bytes(2, &self.pubKeyHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TXOutput {
        TXOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "value",
                |m: &TXOutput| { &m.value },
                |m: &mut TXOutput| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pubKeyHash",
                |m: &TXOutput| { &m.pubKeyHash },
                |m: &mut TXOutput| { &mut m.pubKeyHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TXOutput>(
                "TXOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TXOutput {
        static instance: ::protobuf::rt::LazyV2<TXOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TXOutput::new)
    }
}

impl ::protobuf::Clear for TXOutput {
    fn clear(&mut self) {
        self.value = 0;
        self.pubKeyHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TXOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TXInput {
    // message fields
    pub raw_data: ::protobuf::SingularPtrField<TXInput_raw>,
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TXInput {
    fn default() -> &'a TXInput {
        <TXInput as ::protobuf::Message>::default_instance()
    }
}

impl TXInput {
    pub fn new() -> TXInput {
        ::std::default::Default::default()
    }

    // .protocol.TXInput.raw raw_data = 1;


    pub fn get_raw_data(&self) -> &TXInput_raw {
        self.raw_data.as_ref().unwrap_or_else(|| <TXInput_raw as ::protobuf::Message>::default_instance())
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: TXInput_raw) {
        self.raw_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut TXInput_raw {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> TXInput_raw {
        self.raw_data.take().unwrap_or_else(|| TXInput_raw::new())
    }

    // bytes signature = 4;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TXInput {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(4, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TXInput {
        TXInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TXInput_raw>>(
                "raw_data",
                |m: &TXInput| { &m.raw_data },
                |m: &mut TXInput| { &mut m.raw_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &TXInput| { &m.signature },
                |m: &mut TXInput| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TXInput>(
                "TXInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TXInput {
        static instance: ::protobuf::rt::LazyV2<TXInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TXInput::new)
    }
}

impl ::protobuf::Clear for TXInput {
    fn clear(&mut self) {
        self.raw_data.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TXInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TXInput_raw {
    // message fields
    pub txID: ::std::vec::Vec<u8>,
    pub vout: i64,
    pub pubKey: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TXInput_raw {
    fn default() -> &'a TXInput_raw {
        <TXInput_raw as ::protobuf::Message>::default_instance()
    }
}

impl TXInput_raw {
    pub fn new() -> TXInput_raw {
        ::std::default::Default::default()
    }

    // bytes txID = 1;


    pub fn get_txID(&self) -> &[u8] {
        &self.txID
    }
    pub fn clear_txID(&mut self) {
        self.txID.clear();
    }

    // Param is passed by value, moved
    pub fn set_txID(&mut self, v: ::std::vec::Vec<u8>) {
        self.txID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txID(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txID
    }

    // Take field
    pub fn take_txID(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txID, ::std::vec::Vec::new())
    }

    // int64 vout = 2;


    pub fn get_vout(&self) -> i64 {
        self.vout
    }
    pub fn clear_vout(&mut self) {
        self.vout = 0;
    }

    // Param is passed by value, moved
    pub fn set_vout(&mut self, v: i64) {
        self.vout = v;
    }

    // bytes pubKey = 3;


    pub fn get_pubKey(&self) -> &[u8] {
        &self.pubKey
    }
    pub fn clear_pubKey(&mut self) {
        self.pubKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubKey
    }

    // Take field
    pub fn take_pubKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TXInput_raw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txID)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vout = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txID.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txID);
        }
        if self.vout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.vout, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pubKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.pubKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txID.is_empty() {
            os.write_bytes(1, &self.txID)?;
        }
        if self.vout != 0 {
            os.write_int64(2, self.vout)?;
        }
        if !self.pubKey.is_empty() {
            os.write_bytes(3, &self.pubKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TXInput_raw {
        TXInput_raw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txID",
                |m: &TXInput_raw| { &m.txID },
                |m: &mut TXInput_raw| { &mut m.txID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "vout",
                |m: &TXInput_raw| { &m.vout },
                |m: &mut TXInput_raw| { &mut m.vout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pubKey",
                |m: &TXInput_raw| { &m.pubKey },
                |m: &mut TXInput_raw| { &mut m.pubKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TXInput_raw>(
                "TXInput.raw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TXInput_raw {
        static instance: ::protobuf::rt::LazyV2<TXInput_raw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TXInput_raw::new)
    }
}

impl ::protobuf::Clear for TXInput_raw {
    fn clear(&mut self) {
        self.txID.clear();
        self.vout = 0;
        self.pubKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TXInput_raw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXInput_raw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TXOutputs {
    // message fields
    pub outputs: ::protobuf::RepeatedField<TXOutput>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TXOutputs {
    fn default() -> &'a TXOutputs {
        <TXOutputs as ::protobuf::Message>::default_instance()
    }
}

impl TXOutputs {
    pub fn new() -> TXOutputs {
        ::std::default::Default::default()
    }

    // repeated .protocol.TXOutput outputs = 1;


    pub fn get_outputs(&self) -> &[TXOutput] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<TXOutput>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<TXOutput> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<TXOutput> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TXOutputs {
    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.outputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TXOutputs {
        TXOutputs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TXOutput>>(
                "outputs",
                |m: &TXOutputs| { &m.outputs },
                |m: &mut TXOutputs| { &mut m.outputs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TXOutputs>(
                "TXOutputs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TXOutputs {
        static instance: ::protobuf::rt::LazyV2<TXOutputs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TXOutputs::new)
    }
}

impl ::protobuf::Clear for TXOutputs {
    fn clear(&mut self) {
        self.outputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TXOutputs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TXOutputs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ResourceReceipt {
    // message fields
    pub energy_usage: i64,
    pub energy_fee: i64,
    pub origin_energy_usage: i64,
    pub energy_usage_total: i64,
    pub net_usage: i64,
    pub net_fee: i64,
    pub result: Transaction_Result_contractResult,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceReceipt {
    fn default() -> &'a ResourceReceipt {
        <ResourceReceipt as ::protobuf::Message>::default_instance()
    }
}

impl ResourceReceipt {
    pub fn new() -> ResourceReceipt {
        ::std::default::Default::default()
    }

    // int64 energy_usage = 1;


    pub fn get_energy_usage(&self) -> i64 {
        self.energy_usage
    }
    pub fn clear_energy_usage(&mut self) {
        self.energy_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy_usage(&mut self, v: i64) {
        self.energy_usage = v;
    }

    // int64 energy_fee = 2;


    pub fn get_energy_fee(&self) -> i64 {
        self.energy_fee
    }
    pub fn clear_energy_fee(&mut self) {
        self.energy_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy_fee(&mut self, v: i64) {
        self.energy_fee = v;
    }

    // int64 origin_energy_usage = 3;


    pub fn get_origin_energy_usage(&self) -> i64 {
        self.origin_energy_usage
    }
    pub fn clear_origin_energy_usage(&mut self) {
        self.origin_energy_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin_energy_usage(&mut self, v: i64) {
        self.origin_energy_usage = v;
    }

    // int64 energy_usage_total = 4;


    pub fn get_energy_usage_total(&self) -> i64 {
        self.energy_usage_total
    }
    pub fn clear_energy_usage_total(&mut self) {
        self.energy_usage_total = 0;
    }

    // Param is passed by value, moved
    pub fn set_energy_usage_total(&mut self, v: i64) {
        self.energy_usage_total = v;
    }

    // int64 net_usage = 5;


    pub fn get_net_usage(&self) -> i64 {
        self.net_usage
    }
    pub fn clear_net_usage(&mut self) {
        self.net_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_net_usage(&mut self, v: i64) {
        self.net_usage = v;
    }

    // int64 net_fee = 6;


    pub fn get_net_fee(&self) -> i64 {
        self.net_fee
    }
    pub fn clear_net_fee(&mut self) {
        self.net_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_net_fee(&mut self, v: i64) {
        self.net_fee = v;
    }

    // .protocol.Transaction.Result.contractResult result = 7;


    pub fn get_result(&self) -> Transaction_Result_contractResult {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = Transaction_Result_contractResult::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Transaction_Result_contractResult) {
        self.result = v;
    }
}

impl ::protobuf::Message for ResourceReceipt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.energy_usage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.energy_fee = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.origin_energy_usage = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.energy_usage_total = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.net_usage = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.net_fee = tmp;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.energy_usage != 0 {
            my_size += ::protobuf::rt::value_size(1, self.energy_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.energy_fee != 0 {
            my_size += ::protobuf::rt::value_size(2, self.energy_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.origin_energy_usage != 0 {
            my_size += ::protobuf::rt::value_size(3, self.origin_energy_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.energy_usage_total != 0 {
            my_size += ::protobuf::rt::value_size(4, self.energy_usage_total, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.net_usage != 0 {
            my_size += ::protobuf::rt::value_size(5, self.net_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.net_fee != 0 {
            my_size += ::protobuf::rt::value_size(6, self.net_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.result != Transaction_Result_contractResult::DEFAULT {
            my_size += ::protobuf::rt::enum_size(7, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.energy_usage != 0 {
            os.write_int64(1, self.energy_usage)?;
        }
        if self.energy_fee != 0 {
            os.write_int64(2, self.energy_fee)?;
        }
        if self.origin_energy_usage != 0 {
            os.write_int64(3, self.origin_energy_usage)?;
        }
        if self.energy_usage_total != 0 {
            os.write_int64(4, self.energy_usage_total)?;
        }
        if self.net_usage != 0 {
            os.write_int64(5, self.net_usage)?;
        }
        if self.net_fee != 0 {
            os.write_int64(6, self.net_fee)?;
        }
        if self.result != Transaction_Result_contractResult::DEFAULT {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceReceipt {
        ResourceReceipt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "energy_usage",
                |m: &ResourceReceipt| { &m.energy_usage },
                |m: &mut ResourceReceipt| { &mut m.energy_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "energy_fee",
                |m: &ResourceReceipt| { &m.energy_fee },
                |m: &mut ResourceReceipt| { &mut m.energy_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "origin_energy_usage",
                |m: &ResourceReceipt| { &m.origin_energy_usage },
                |m: &mut ResourceReceipt| { &mut m.origin_energy_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "energy_usage_total",
                |m: &ResourceReceipt| { &m.energy_usage_total },
                |m: &mut ResourceReceipt| { &mut m.energy_usage_total },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "net_usage",
                |m: &ResourceReceipt| { &m.net_usage },
                |m: &mut ResourceReceipt| { &mut m.net_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "net_fee",
                |m: &ResourceReceipt| { &m.net_fee },
                |m: &mut ResourceReceipt| { &mut m.net_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Result_contractResult>>(
                "result",
                |m: &ResourceReceipt| { &m.result },
                |m: &mut ResourceReceipt| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceReceipt>(
                "ResourceReceipt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceReceipt {
        static instance: ::protobuf::rt::LazyV2<ResourceReceipt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceReceipt::new)
    }
}

impl ::protobuf::Clear for ResourceReceipt {
    fn clear(&mut self) {
        self.energy_usage = 0;
        self.energy_fee = 0;
        self.origin_energy_usage = 0;
        self.energy_usage_total = 0;
        self.net_usage = 0;
        self.net_fee = 0;
        self.result = Transaction_Result_contractResult::DEFAULT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceReceipt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Transaction {
    // message fields
    pub raw_data: ::protobuf::SingularPtrField<Transaction_raw>,
    pub signature: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub ret: ::protobuf::RepeatedField<Transaction_Result>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // .protocol.Transaction.raw raw_data = 1;


    pub fn get_raw_data(&self) -> &Transaction_raw {
        self.raw_data.as_ref().unwrap_or_else(|| <Transaction_raw as ::protobuf::Message>::default_instance())
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: Transaction_raw) {
        self.raw_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut Transaction_raw {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> Transaction_raw {
        self.raw_data.take().unwrap_or_else(|| Transaction_raw::new())
    }

    // repeated bytes signature = 2;


    pub fn get_signature(&self) -> &[::std::vec::Vec<u8>] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    pub fn mut_signature(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.signature, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.Transaction.Result ret = 5;


    pub fn get_ret(&self) -> &[Transaction_Result] {
        &self.ret
    }
    pub fn clear_ret(&mut self) {
        self.ret.clear();
    }

    // Param is passed by value, moved
    pub fn set_ret(&mut self, v: ::protobuf::RepeatedField<Transaction_Result>) {
        self.ret = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ret(&mut self) -> &mut ::protobuf::RepeatedField<Transaction_Result> {
        &mut self.ret
    }

    // Take field
    pub fn take_ret(&mut self) -> ::protobuf::RepeatedField<Transaction_Result> {
        ::std::mem::replace(&mut self.ret, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_data)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.signature)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.signature {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.ret {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.signature {
            os.write_bytes(2, &v)?;
        };
        for v in &self.ret {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction_raw>>(
                "raw_data",
                |m: &Transaction| { &m.raw_data },
                |m: &mut Transaction| { &mut m.raw_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &Transaction| { &m.signature },
                |m: &mut Transaction| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction_Result>>(
                "ret",
                |m: &Transaction| { &m.ret },
                |m: &mut Transaction| { &mut m.ret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction>(
                "Transaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction {
        static instance: ::protobuf::rt::LazyV2<Transaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction::new)
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.raw_data.clear();
        self.signature.clear();
        self.ret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Transaction_Contract {
    // message fields
    pub field_type: Transaction_Contract_ContractType,
    pub parameter: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub provider: ::std::vec::Vec<u8>,
    pub ContractName: ::std::vec::Vec<u8>,
    pub Permission_id: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Contract {
    fn default() -> &'a Transaction_Contract {
        <Transaction_Contract as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Contract {
    pub fn new() -> Transaction_Contract {
        ::std::default::Default::default()
    }

    // .protocol.Transaction.Contract.ContractType type = 1;


    pub fn get_field_type(&self) -> Transaction_Contract_ContractType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Transaction_Contract_ContractType::AccountCreateContract;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Transaction_Contract_ContractType) {
        self.field_type = v;
    }

    // .google.protobuf.Any parameter = 2;


    pub fn get_parameter(&self) -> &::protobuf::well_known_types::Any {
        self.parameter.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parameter(&mut self) {
        self.parameter.clear();
    }

    pub fn has_parameter(&self) -> bool {
        self.parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: ::protobuf::well_known_types::Any) {
        self.parameter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameter(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.parameter.is_none() {
            self.parameter.set_default();
        }
        self.parameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameter(&mut self) -> ::protobuf::well_known_types::Any {
        self.parameter.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // bytes provider = 3;


    pub fn get_provider(&self) -> &[u8] {
        &self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider.clear();
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: ::std::vec::Vec<u8>) {
        self.provider = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provider(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.provider
    }

    // Take field
    pub fn take_provider(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.provider, ::std::vec::Vec::new())
    }

    // bytes ContractName = 4;


    pub fn get_ContractName(&self) -> &[u8] {
        &self.ContractName
    }
    pub fn clear_ContractName(&mut self) {
        self.ContractName.clear();
    }

    // Param is passed by value, moved
    pub fn set_ContractName(&mut self, v: ::std::vec::Vec<u8>) {
        self.ContractName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ContractName(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ContractName
    }

    // Take field
    pub fn take_ContractName(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ContractName, ::std::vec::Vec::new())
    }

    // int32 Permission_id = 5;


    pub fn get_Permission_id(&self) -> i32 {
        self.Permission_id
    }
    pub fn clear_Permission_id(&mut self) {
        self.Permission_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Permission_id(&mut self, v: i32) {
        self.Permission_id = v;
    }
}

impl ::protobuf::Message for Transaction_Contract {
    fn is_initialized(&self) -> bool {
        for v in &self.parameter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parameter)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.provider)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ContractName)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Permission_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Transaction_Contract_ContractType::AccountCreateContract {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.parameter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.provider.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.provider);
        }
        if !self.ContractName.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.ContractName);
        }
        if self.Permission_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.Permission_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Transaction_Contract_ContractType::AccountCreateContract {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.parameter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.provider.is_empty() {
            os.write_bytes(3, &self.provider)?;
        }
        if !self.ContractName.is_empty() {
            os.write_bytes(4, &self.ContractName)?;
        }
        if self.Permission_id != 0 {
            os.write_int32(5, self.Permission_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Contract {
        Transaction_Contract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Contract_ContractType>>(
                "type",
                |m: &Transaction_Contract| { &m.field_type },
                |m: &mut Transaction_Contract| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "parameter",
                |m: &Transaction_Contract| { &m.parameter },
                |m: &mut Transaction_Contract| { &mut m.parameter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "provider",
                |m: &Transaction_Contract| { &m.provider },
                |m: &mut Transaction_Contract| { &mut m.provider },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ContractName",
                |m: &Transaction_Contract| { &m.ContractName },
                |m: &mut Transaction_Contract| { &mut m.ContractName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "Permission_id",
                |m: &Transaction_Contract| { &m.Permission_id },
                |m: &mut Transaction_Contract| { &mut m.Permission_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Contract>(
                "Transaction.Contract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Contract {
        static instance: ::protobuf::rt::LazyV2<Transaction_Contract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Contract::new)
    }
}

impl ::protobuf::Clear for Transaction_Contract {
    fn clear(&mut self) {
        self.field_type = Transaction_Contract_ContractType::AccountCreateContract;
        self.parameter.clear();
        self.provider.clear();
        self.ContractName.clear();
        self.Permission_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Contract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Contract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Transaction_Contract_ContractType {
    AccountCreateContract = 0,
    TransferContract = 1,
    TransferAssetContract = 2,
    VoteAssetContract = 3,
    VoteWitnessContract = 4,
    WitnessCreateContract = 5,
    AssetIssueContract = 6,
    WitnessUpdateContract = 8,
    ParticipateAssetIssueContract = 9,
    AccountUpdateContract = 10,
    FreezeBalanceContract = 11,
    UnfreezeBalanceContract = 12,
    WithdrawBalanceContract = 13,
    UnfreezeAssetContract = 14,
    UpdateAssetContract = 15,
    ProposalCreateContract = 16,
    ProposalApproveContract = 17,
    ProposalDeleteContract = 18,
    SetAccountIdContract = 19,
    CustomContract = 20,
    CreateSmartContract = 30,
    TriggerSmartContract = 31,
    GetContract = 32,
    UpdateSettingContract = 33,
    ExchangeCreateContract = 41,
    ExchangeInjectContract = 42,
    ExchangeWithdrawContract = 43,
    ExchangeTransactionContract = 44,
    UpdateEnergyLimitContract = 45,
    AccountPermissionUpdateContract = 46,
    ClearABIContract = 48,
    UpdateBrokerageContract = 49,
    ShieldedTransferContract = 51,
}

impl ::protobuf::ProtobufEnum for Transaction_Contract_ContractType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Transaction_Contract_ContractType> {
        match value {
            0 => ::std::option::Option::Some(Transaction_Contract_ContractType::AccountCreateContract),
            1 => ::std::option::Option::Some(Transaction_Contract_ContractType::TransferContract),
            2 => ::std::option::Option::Some(Transaction_Contract_ContractType::TransferAssetContract),
            3 => ::std::option::Option::Some(Transaction_Contract_ContractType::VoteAssetContract),
            4 => ::std::option::Option::Some(Transaction_Contract_ContractType::VoteWitnessContract),
            5 => ::std::option::Option::Some(Transaction_Contract_ContractType::WitnessCreateContract),
            6 => ::std::option::Option::Some(Transaction_Contract_ContractType::AssetIssueContract),
            8 => ::std::option::Option::Some(Transaction_Contract_ContractType::WitnessUpdateContract),
            9 => ::std::option::Option::Some(Transaction_Contract_ContractType::ParticipateAssetIssueContract),
            10 => ::std::option::Option::Some(Transaction_Contract_ContractType::AccountUpdateContract),
            11 => ::std::option::Option::Some(Transaction_Contract_ContractType::FreezeBalanceContract),
            12 => ::std::option::Option::Some(Transaction_Contract_ContractType::UnfreezeBalanceContract),
            13 => ::std::option::Option::Some(Transaction_Contract_ContractType::WithdrawBalanceContract),
            14 => ::std::option::Option::Some(Transaction_Contract_ContractType::UnfreezeAssetContract),
            15 => ::std::option::Option::Some(Transaction_Contract_ContractType::UpdateAssetContract),
            16 => ::std::option::Option::Some(Transaction_Contract_ContractType::ProposalCreateContract),
            17 => ::std::option::Option::Some(Transaction_Contract_ContractType::ProposalApproveContract),
            18 => ::std::option::Option::Some(Transaction_Contract_ContractType::ProposalDeleteContract),
            19 => ::std::option::Option::Some(Transaction_Contract_ContractType::SetAccountIdContract),
            20 => ::std::option::Option::Some(Transaction_Contract_ContractType::CustomContract),
            30 => ::std::option::Option::Some(Transaction_Contract_ContractType::CreateSmartContract),
            31 => ::std::option::Option::Some(Transaction_Contract_ContractType::TriggerSmartContract),
            32 => ::std::option::Option::Some(Transaction_Contract_ContractType::GetContract),
            33 => ::std::option::Option::Some(Transaction_Contract_ContractType::UpdateSettingContract),
            41 => ::std::option::Option::Some(Transaction_Contract_ContractType::ExchangeCreateContract),
            42 => ::std::option::Option::Some(Transaction_Contract_ContractType::ExchangeInjectContract),
            43 => ::std::option::Option::Some(Transaction_Contract_ContractType::ExchangeWithdrawContract),
            44 => ::std::option::Option::Some(Transaction_Contract_ContractType::ExchangeTransactionContract),
            45 => ::std::option::Option::Some(Transaction_Contract_ContractType::UpdateEnergyLimitContract),
            46 => ::std::option::Option::Some(Transaction_Contract_ContractType::AccountPermissionUpdateContract),
            48 => ::std::option::Option::Some(Transaction_Contract_ContractType::ClearABIContract),
            49 => ::std::option::Option::Some(Transaction_Contract_ContractType::UpdateBrokerageContract),
            51 => ::std::option::Option::Some(Transaction_Contract_ContractType::ShieldedTransferContract),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Transaction_Contract_ContractType] = &[
            Transaction_Contract_ContractType::AccountCreateContract,
            Transaction_Contract_ContractType::TransferContract,
            Transaction_Contract_ContractType::TransferAssetContract,
            Transaction_Contract_ContractType::VoteAssetContract,
            Transaction_Contract_ContractType::VoteWitnessContract,
            Transaction_Contract_ContractType::WitnessCreateContract,
            Transaction_Contract_ContractType::AssetIssueContract,
            Transaction_Contract_ContractType::WitnessUpdateContract,
            Transaction_Contract_ContractType::ParticipateAssetIssueContract,
            Transaction_Contract_ContractType::AccountUpdateContract,
            Transaction_Contract_ContractType::FreezeBalanceContract,
            Transaction_Contract_ContractType::UnfreezeBalanceContract,
            Transaction_Contract_ContractType::WithdrawBalanceContract,
            Transaction_Contract_ContractType::UnfreezeAssetContract,
            Transaction_Contract_ContractType::UpdateAssetContract,
            Transaction_Contract_ContractType::ProposalCreateContract,
            Transaction_Contract_ContractType::ProposalApproveContract,
            Transaction_Contract_ContractType::ProposalDeleteContract,
            Transaction_Contract_ContractType::SetAccountIdContract,
            Transaction_Contract_ContractType::CustomContract,
            Transaction_Contract_ContractType::CreateSmartContract,
            Transaction_Contract_ContractType::TriggerSmartContract,
            Transaction_Contract_ContractType::GetContract,
            Transaction_Contract_ContractType::UpdateSettingContract,
            Transaction_Contract_ContractType::ExchangeCreateContract,
            Transaction_Contract_ContractType::ExchangeInjectContract,
            Transaction_Contract_ContractType::ExchangeWithdrawContract,
            Transaction_Contract_ContractType::ExchangeTransactionContract,
            Transaction_Contract_ContractType::UpdateEnergyLimitContract,
            Transaction_Contract_ContractType::AccountPermissionUpdateContract,
            Transaction_Contract_ContractType::ClearABIContract,
            Transaction_Contract_ContractType::UpdateBrokerageContract,
            Transaction_Contract_ContractType::ShieldedTransferContract,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Transaction_Contract_ContractType>("Transaction.Contract.ContractType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Transaction_Contract_ContractType {
}

impl ::std::default::Default for Transaction_Contract_ContractType {
    fn default() -> Self {
        Transaction_Contract_ContractType::AccountCreateContract
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Contract_ContractType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Transaction_Result {
    // message fields
    pub fee: i64,
    pub ret: Transaction_Result_code,
    pub contractRet: Transaction_Result_contractResult,
    pub assetIssueID: ::std::string::String,
    pub withdraw_amount: i64,
    pub unfreeze_amount: i64,
    pub exchange_received_amount: i64,
    pub exchange_inject_another_amount: i64,
    pub exchange_withdraw_another_amount: i64,
    pub exchange_id: i64,
    pub shielded_transaction_fee: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_Result {
    fn default() -> &'a Transaction_Result {
        <Transaction_Result as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_Result {
    pub fn new() -> Transaction_Result {
        ::std::default::Default::default()
    }

    // int64 fee = 1;


    pub fn get_fee(&self) -> i64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    // .protocol.Transaction.Result.code ret = 2;


    pub fn get_ret(&self) -> Transaction_Result_code {
        self.ret
    }
    pub fn clear_ret(&mut self) {
        self.ret = Transaction_Result_code::SUCESS;
    }

    // Param is passed by value, moved
    pub fn set_ret(&mut self, v: Transaction_Result_code) {
        self.ret = v;
    }

    // .protocol.Transaction.Result.contractResult contractRet = 3;


    pub fn get_contractRet(&self) -> Transaction_Result_contractResult {
        self.contractRet
    }
    pub fn clear_contractRet(&mut self) {
        self.contractRet = Transaction_Result_contractResult::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_contractRet(&mut self, v: Transaction_Result_contractResult) {
        self.contractRet = v;
    }

    // string assetIssueID = 14;


    pub fn get_assetIssueID(&self) -> &str {
        &self.assetIssueID
    }
    pub fn clear_assetIssueID(&mut self) {
        self.assetIssueID.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetIssueID(&mut self, v: ::std::string::String) {
        self.assetIssueID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assetIssueID(&mut self) -> &mut ::std::string::String {
        &mut self.assetIssueID
    }

    // Take field
    pub fn take_assetIssueID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.assetIssueID, ::std::string::String::new())
    }

    // int64 withdraw_amount = 15;


    pub fn get_withdraw_amount(&self) -> i64 {
        self.withdraw_amount
    }
    pub fn clear_withdraw_amount(&mut self) {
        self.withdraw_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_withdraw_amount(&mut self, v: i64) {
        self.withdraw_amount = v;
    }

    // int64 unfreeze_amount = 16;


    pub fn get_unfreeze_amount(&self) -> i64 {
        self.unfreeze_amount
    }
    pub fn clear_unfreeze_amount(&mut self) {
        self.unfreeze_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_unfreeze_amount(&mut self, v: i64) {
        self.unfreeze_amount = v;
    }

    // int64 exchange_received_amount = 18;


    pub fn get_exchange_received_amount(&self) -> i64 {
        self.exchange_received_amount
    }
    pub fn clear_exchange_received_amount(&mut self) {
        self.exchange_received_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_received_amount(&mut self, v: i64) {
        self.exchange_received_amount = v;
    }

    // int64 exchange_inject_another_amount = 19;


    pub fn get_exchange_inject_another_amount(&self) -> i64 {
        self.exchange_inject_another_amount
    }
    pub fn clear_exchange_inject_another_amount(&mut self) {
        self.exchange_inject_another_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_inject_another_amount(&mut self, v: i64) {
        self.exchange_inject_another_amount = v;
    }

    // int64 exchange_withdraw_another_amount = 20;


    pub fn get_exchange_withdraw_another_amount(&self) -> i64 {
        self.exchange_withdraw_another_amount
    }
    pub fn clear_exchange_withdraw_another_amount(&mut self) {
        self.exchange_withdraw_another_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_withdraw_another_amount(&mut self, v: i64) {
        self.exchange_withdraw_another_amount = v;
    }

    // int64 exchange_id = 21;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // int64 shielded_transaction_fee = 22;


    pub fn get_shielded_transaction_fee(&self) -> i64 {
        self.shielded_transaction_fee
    }
    pub fn clear_shielded_transaction_fee(&mut self) {
        self.shielded_transaction_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_shielded_transaction_fee(&mut self, v: i64) {
        self.shielded_transaction_fee = v;
    }
}

impl ::protobuf::Message for Transaction_Result {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.ret, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.contractRet, 3, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.assetIssueID)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.withdraw_amount = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unfreeze_amount = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_received_amount = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_inject_another_amount = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_withdraw_another_amount = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.shielded_transaction_fee = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ret != Transaction_Result_code::SUCESS {
            my_size += ::protobuf::rt::enum_size(2, self.ret);
        }
        if self.contractRet != Transaction_Result_contractResult::DEFAULT {
            my_size += ::protobuf::rt::enum_size(3, self.contractRet);
        }
        if !self.assetIssueID.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.assetIssueID);
        }
        if self.withdraw_amount != 0 {
            my_size += ::protobuf::rt::value_size(15, self.withdraw_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unfreeze_amount != 0 {
            my_size += ::protobuf::rt::value_size(16, self.unfreeze_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_received_amount != 0 {
            my_size += ::protobuf::rt::value_size(18, self.exchange_received_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_inject_another_amount != 0 {
            my_size += ::protobuf::rt::value_size(19, self.exchange_inject_another_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_withdraw_another_amount != 0 {
            my_size += ::protobuf::rt::value_size(20, self.exchange_withdraw_another_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(21, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shielded_transaction_fee != 0 {
            my_size += ::protobuf::rt::value_size(22, self.shielded_transaction_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fee != 0 {
            os.write_int64(1, self.fee)?;
        }
        if self.ret != Transaction_Result_code::SUCESS {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.ret))?;
        }
        if self.contractRet != Transaction_Result_contractResult::DEFAULT {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.contractRet))?;
        }
        if !self.assetIssueID.is_empty() {
            os.write_string(14, &self.assetIssueID)?;
        }
        if self.withdraw_amount != 0 {
            os.write_int64(15, self.withdraw_amount)?;
        }
        if self.unfreeze_amount != 0 {
            os.write_int64(16, self.unfreeze_amount)?;
        }
        if self.exchange_received_amount != 0 {
            os.write_int64(18, self.exchange_received_amount)?;
        }
        if self.exchange_inject_another_amount != 0 {
            os.write_int64(19, self.exchange_inject_another_amount)?;
        }
        if self.exchange_withdraw_another_amount != 0 {
            os.write_int64(20, self.exchange_withdraw_another_amount)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(21, self.exchange_id)?;
        }
        if self.shielded_transaction_fee != 0 {
            os.write_int64(22, self.shielded_transaction_fee)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_Result {
        Transaction_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee",
                |m: &Transaction_Result| { &m.fee },
                |m: &mut Transaction_Result| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Result_code>>(
                "ret",
                |m: &Transaction_Result| { &m.ret },
                |m: &mut Transaction_Result| { &mut m.ret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Transaction_Result_contractResult>>(
                "contractRet",
                |m: &Transaction_Result| { &m.contractRet },
                |m: &mut Transaction_Result| { &mut m.contractRet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetIssueID",
                |m: &Transaction_Result| { &m.assetIssueID },
                |m: &mut Transaction_Result| { &mut m.assetIssueID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "withdraw_amount",
                |m: &Transaction_Result| { &m.withdraw_amount },
                |m: &mut Transaction_Result| { &mut m.withdraw_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unfreeze_amount",
                |m: &Transaction_Result| { &m.unfreeze_amount },
                |m: &mut Transaction_Result| { &mut m.unfreeze_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_received_amount",
                |m: &Transaction_Result| { &m.exchange_received_amount },
                |m: &mut Transaction_Result| { &mut m.exchange_received_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_inject_another_amount",
                |m: &Transaction_Result| { &m.exchange_inject_another_amount },
                |m: &mut Transaction_Result| { &mut m.exchange_inject_another_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_withdraw_another_amount",
                |m: &Transaction_Result| { &m.exchange_withdraw_another_amount },
                |m: &mut Transaction_Result| { &mut m.exchange_withdraw_another_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_id",
                |m: &Transaction_Result| { &m.exchange_id },
                |m: &mut Transaction_Result| { &mut m.exchange_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "shielded_transaction_fee",
                |m: &Transaction_Result| { &m.shielded_transaction_fee },
                |m: &mut Transaction_Result| { &mut m.shielded_transaction_fee },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_Result>(
                "Transaction.Result",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_Result {
        static instance: ::protobuf::rt::LazyV2<Transaction_Result> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_Result::new)
    }
}

impl ::protobuf::Clear for Transaction_Result {
    fn clear(&mut self) {
        self.fee = 0;
        self.ret = Transaction_Result_code::SUCESS;
        self.contractRet = Transaction_Result_contractResult::DEFAULT;
        self.assetIssueID.clear();
        self.withdraw_amount = 0;
        self.unfreeze_amount = 0;
        self.exchange_received_amount = 0;
        self.exchange_inject_another_amount = 0;
        self.exchange_withdraw_another_amount = 0;
        self.exchange_id = 0;
        self.shielded_transaction_fee = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Transaction_Result_code {
    SUCESS = 0,
    FAILED = 1,
}

impl ::protobuf::ProtobufEnum for Transaction_Result_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Transaction_Result_code> {
        match value {
            0 => ::std::option::Option::Some(Transaction_Result_code::SUCESS),
            1 => ::std::option::Option::Some(Transaction_Result_code::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Transaction_Result_code] = &[
            Transaction_Result_code::SUCESS,
            Transaction_Result_code::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Transaction_Result_code>("Transaction.Result.code", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Transaction_Result_code {
}

impl ::std::default::Default for Transaction_Result_code {
    fn default() -> Self {
        Transaction_Result_code::SUCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Result_code {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Transaction_Result_contractResult {
    DEFAULT = 0,
    SUCCESS = 1,
    REVERT = 2,
    BAD_JUMP_DESTINATION = 3,
    OUT_OF_MEMORY = 4,
    PRECOMPILED_CONTRACT = 5,
    STACK_TOO_SMALL = 6,
    STACK_TOO_LARGE = 7,
    ILLEGAL_OPERATION = 8,
    STACK_OVERFLOW = 9,
    OUT_OF_ENERGY = 10,
    OUT_OF_TIME = 11,
    JVM_STACK_OVER_FLOW = 12,
    UNKNOWN = 13,
    TRANSFER_FAILED = 14,
}

impl ::protobuf::ProtobufEnum for Transaction_Result_contractResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Transaction_Result_contractResult> {
        match value {
            0 => ::std::option::Option::Some(Transaction_Result_contractResult::DEFAULT),
            1 => ::std::option::Option::Some(Transaction_Result_contractResult::SUCCESS),
            2 => ::std::option::Option::Some(Transaction_Result_contractResult::REVERT),
            3 => ::std::option::Option::Some(Transaction_Result_contractResult::BAD_JUMP_DESTINATION),
            4 => ::std::option::Option::Some(Transaction_Result_contractResult::OUT_OF_MEMORY),
            5 => ::std::option::Option::Some(Transaction_Result_contractResult::PRECOMPILED_CONTRACT),
            6 => ::std::option::Option::Some(Transaction_Result_contractResult::STACK_TOO_SMALL),
            7 => ::std::option::Option::Some(Transaction_Result_contractResult::STACK_TOO_LARGE),
            8 => ::std::option::Option::Some(Transaction_Result_contractResult::ILLEGAL_OPERATION),
            9 => ::std::option::Option::Some(Transaction_Result_contractResult::STACK_OVERFLOW),
            10 => ::std::option::Option::Some(Transaction_Result_contractResult::OUT_OF_ENERGY),
            11 => ::std::option::Option::Some(Transaction_Result_contractResult::OUT_OF_TIME),
            12 => ::std::option::Option::Some(Transaction_Result_contractResult::JVM_STACK_OVER_FLOW),
            13 => ::std::option::Option::Some(Transaction_Result_contractResult::UNKNOWN),
            14 => ::std::option::Option::Some(Transaction_Result_contractResult::TRANSFER_FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Transaction_Result_contractResult] = &[
            Transaction_Result_contractResult::DEFAULT,
            Transaction_Result_contractResult::SUCCESS,
            Transaction_Result_contractResult::REVERT,
            Transaction_Result_contractResult::BAD_JUMP_DESTINATION,
            Transaction_Result_contractResult::OUT_OF_MEMORY,
            Transaction_Result_contractResult::PRECOMPILED_CONTRACT,
            Transaction_Result_contractResult::STACK_TOO_SMALL,
            Transaction_Result_contractResult::STACK_TOO_LARGE,
            Transaction_Result_contractResult::ILLEGAL_OPERATION,
            Transaction_Result_contractResult::STACK_OVERFLOW,
            Transaction_Result_contractResult::OUT_OF_ENERGY,
            Transaction_Result_contractResult::OUT_OF_TIME,
            Transaction_Result_contractResult::JVM_STACK_OVER_FLOW,
            Transaction_Result_contractResult::UNKNOWN,
            Transaction_Result_contractResult::TRANSFER_FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Transaction_Result_contractResult>("Transaction.Result.contractResult", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Transaction_Result_contractResult {
}

impl ::std::default::Default for Transaction_Result_contractResult {
    fn default() -> Self {
        Transaction_Result_contractResult::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_Result_contractResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Transaction_raw {
    // message fields
    pub ref_block_bytes: ::std::vec::Vec<u8>,
    pub ref_block_num: i64,
    pub ref_block_hash: ::std::vec::Vec<u8>,
    pub expiration: i64,
    pub auths: ::protobuf::RepeatedField<authority>,
    pub data: ::std::vec::Vec<u8>,
    pub contract: ::protobuf::RepeatedField<Transaction_Contract>,
    pub scripts: ::std::vec::Vec<u8>,
    pub timestamp: i64,
    pub fee_limit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction_raw {
    fn default() -> &'a Transaction_raw {
        <Transaction_raw as ::protobuf::Message>::default_instance()
    }
}

impl Transaction_raw {
    pub fn new() -> Transaction_raw {
        ::std::default::Default::default()
    }

    // bytes ref_block_bytes = 1;


    pub fn get_ref_block_bytes(&self) -> &[u8] {
        &self.ref_block_bytes
    }
    pub fn clear_ref_block_bytes(&mut self) {
        self.ref_block_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_ref_block_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.ref_block_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_block_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ref_block_bytes
    }

    // Take field
    pub fn take_ref_block_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ref_block_bytes, ::std::vec::Vec::new())
    }

    // int64 ref_block_num = 3;


    pub fn get_ref_block_num(&self) -> i64 {
        self.ref_block_num
    }
    pub fn clear_ref_block_num(&mut self) {
        self.ref_block_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_ref_block_num(&mut self, v: i64) {
        self.ref_block_num = v;
    }

    // bytes ref_block_hash = 4;


    pub fn get_ref_block_hash(&self) -> &[u8] {
        &self.ref_block_hash
    }
    pub fn clear_ref_block_hash(&mut self) {
        self.ref_block_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_ref_block_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.ref_block_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_block_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ref_block_hash
    }

    // Take field
    pub fn take_ref_block_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ref_block_hash, ::std::vec::Vec::new())
    }

    // int64 expiration = 8;


    pub fn get_expiration(&self) -> i64 {
        self.expiration
    }
    pub fn clear_expiration(&mut self) {
        self.expiration = 0;
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i64) {
        self.expiration = v;
    }

    // repeated .protocol.authority auths = 9;


    pub fn get_auths(&self) -> &[authority] {
        &self.auths
    }
    pub fn clear_auths(&mut self) {
        self.auths.clear();
    }

    // Param is passed by value, moved
    pub fn set_auths(&mut self, v: ::protobuf::RepeatedField<authority>) {
        self.auths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auths(&mut self) -> &mut ::protobuf::RepeatedField<authority> {
        &mut self.auths
    }

    // Take field
    pub fn take_auths(&mut self) -> ::protobuf::RepeatedField<authority> {
        ::std::mem::replace(&mut self.auths, ::protobuf::RepeatedField::new())
    }

    // bytes data = 10;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // repeated .protocol.Transaction.Contract contract = 11;


    pub fn get_contract(&self) -> &[Transaction_Contract] {
        &self.contract
    }
    pub fn clear_contract(&mut self) {
        self.contract.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract(&mut self, v: ::protobuf::RepeatedField<Transaction_Contract>) {
        self.contract = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contract(&mut self) -> &mut ::protobuf::RepeatedField<Transaction_Contract> {
        &mut self.contract
    }

    // Take field
    pub fn take_contract(&mut self) -> ::protobuf::RepeatedField<Transaction_Contract> {
        ::std::mem::replace(&mut self.contract, ::protobuf::RepeatedField::new())
    }

    // bytes scripts = 12;


    pub fn get_scripts(&self) -> &[u8] {
        &self.scripts
    }
    pub fn clear_scripts(&mut self) {
        self.scripts.clear();
    }

    // Param is passed by value, moved
    pub fn set_scripts(&mut self, v: ::std::vec::Vec<u8>) {
        self.scripts = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scripts(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.scripts
    }

    // Take field
    pub fn take_scripts(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.scripts, ::std::vec::Vec::new())
    }

    // int64 timestamp = 14;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // int64 fee_limit = 18;


    pub fn get_fee_limit(&self) -> i64 {
        self.fee_limit
    }
    pub fn clear_fee_limit(&mut self) {
        self.fee_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee_limit(&mut self, v: i64) {
        self.fee_limit = v;
    }
}

impl ::protobuf::Message for Transaction_raw {
    fn is_initialized(&self) -> bool {
        for v in &self.auths {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contract {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ref_block_bytes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ref_block_num = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ref_block_hash)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expiration = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.auths)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contract)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.scripts)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ref_block_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ref_block_bytes);
        }
        if self.ref_block_num != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ref_block_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ref_block_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.ref_block_hash);
        }
        if self.expiration != 0 {
            my_size += ::protobuf::rt::value_size(8, self.expiration, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.auths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.data);
        }
        for value in &self.contract {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.scripts.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.scripts);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(14, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fee_limit != 0 {
            my_size += ::protobuf::rt::value_size(18, self.fee_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ref_block_bytes.is_empty() {
            os.write_bytes(1, &self.ref_block_bytes)?;
        }
        if self.ref_block_num != 0 {
            os.write_int64(3, self.ref_block_num)?;
        }
        if !self.ref_block_hash.is_empty() {
            os.write_bytes(4, &self.ref_block_hash)?;
        }
        if self.expiration != 0 {
            os.write_int64(8, self.expiration)?;
        }
        for v in &self.auths {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(10, &self.data)?;
        }
        for v in &self.contract {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.scripts.is_empty() {
            os.write_bytes(12, &self.scripts)?;
        }
        if self.timestamp != 0 {
            os.write_int64(14, self.timestamp)?;
        }
        if self.fee_limit != 0 {
            os.write_int64(18, self.fee_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction_raw {
        Transaction_raw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ref_block_bytes",
                |m: &Transaction_raw| { &m.ref_block_bytes },
                |m: &mut Transaction_raw| { &mut m.ref_block_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ref_block_num",
                |m: &Transaction_raw| { &m.ref_block_num },
                |m: &mut Transaction_raw| { &mut m.ref_block_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ref_block_hash",
                |m: &Transaction_raw| { &m.ref_block_hash },
                |m: &mut Transaction_raw| { &mut m.ref_block_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expiration",
                |m: &Transaction_raw| { &m.expiration },
                |m: &mut Transaction_raw| { &mut m.expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<authority>>(
                "auths",
                |m: &Transaction_raw| { &m.auths },
                |m: &mut Transaction_raw| { &mut m.auths },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &Transaction_raw| { &m.data },
                |m: &mut Transaction_raw| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction_Contract>>(
                "contract",
                |m: &Transaction_raw| { &m.contract },
                |m: &mut Transaction_raw| { &mut m.contract },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "scripts",
                |m: &Transaction_raw| { &m.scripts },
                |m: &mut Transaction_raw| { &mut m.scripts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &Transaction_raw| { &m.timestamp },
                |m: &mut Transaction_raw| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee_limit",
                |m: &Transaction_raw| { &m.fee_limit },
                |m: &mut Transaction_raw| { &mut m.fee_limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction_raw>(
                "Transaction.raw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transaction_raw {
        static instance: ::protobuf::rt::LazyV2<Transaction_raw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transaction_raw::new)
    }
}

impl ::protobuf::Clear for Transaction_raw {
    fn clear(&mut self) {
        self.ref_block_bytes.clear();
        self.ref_block_num = 0;
        self.ref_block_hash.clear();
        self.expiration = 0;
        self.auths.clear();
        self.data.clear();
        self.contract.clear();
        self.scripts.clear();
        self.timestamp = 0;
        self.fee_limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction_raw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction_raw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionInfo {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub fee: i64,
    pub blockNumber: i64,
    pub blockTimeStamp: i64,
    pub contractResult: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub receipt: ::protobuf::SingularPtrField<ResourceReceipt>,
    pub log: ::protobuf::RepeatedField<TransactionInfo_Log>,
    pub result: TransactionInfo_code,
    pub resMessage: ::std::vec::Vec<u8>,
    pub assetIssueID: ::std::string::String,
    pub withdraw_amount: i64,
    pub unfreeze_amount: i64,
    pub internal_transactions: ::protobuf::RepeatedField<InternalTransaction>,
    pub exchange_received_amount: i64,
    pub exchange_inject_another_amount: i64,
    pub exchange_withdraw_another_amount: i64,
    pub exchange_id: i64,
    pub shielded_transaction_fee: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionInfo {
    fn default() -> &'a TransactionInfo {
        <TransactionInfo as ::protobuf::Message>::default_instance()
    }
}

impl TransactionInfo {
    pub fn new() -> TransactionInfo {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // int64 fee = 2;


    pub fn get_fee(&self) -> i64 {
        self.fee
    }
    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    // int64 blockNumber = 3;


    pub fn get_blockNumber(&self) -> i64 {
        self.blockNumber
    }
    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: i64) {
        self.blockNumber = v;
    }

    // int64 blockTimeStamp = 4;


    pub fn get_blockTimeStamp(&self) -> i64 {
        self.blockTimeStamp
    }
    pub fn clear_blockTimeStamp(&mut self) {
        self.blockTimeStamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockTimeStamp(&mut self, v: i64) {
        self.blockTimeStamp = v;
    }

    // repeated bytes contractResult = 5;


    pub fn get_contractResult(&self) -> &[::std::vec::Vec<u8>] {
        &self.contractResult
    }
    pub fn clear_contractResult(&mut self) {
        self.contractResult.clear();
    }

    // Param is passed by value, moved
    pub fn set_contractResult(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.contractResult = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contractResult(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.contractResult
    }

    // Take field
    pub fn take_contractResult(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.contractResult, ::protobuf::RepeatedField::new())
    }

    // bytes contract_address = 6;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // .protocol.ResourceReceipt receipt = 7;


    pub fn get_receipt(&self) -> &ResourceReceipt {
        self.receipt.as_ref().unwrap_or_else(|| <ResourceReceipt as ::protobuf::Message>::default_instance())
    }
    pub fn clear_receipt(&mut self) {
        self.receipt.clear();
    }

    pub fn has_receipt(&self) -> bool {
        self.receipt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receipt(&mut self, v: ResourceReceipt) {
        self.receipt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receipt(&mut self) -> &mut ResourceReceipt {
        if self.receipt.is_none() {
            self.receipt.set_default();
        }
        self.receipt.as_mut().unwrap()
    }

    // Take field
    pub fn take_receipt(&mut self) -> ResourceReceipt {
        self.receipt.take().unwrap_or_else(|| ResourceReceipt::new())
    }

    // repeated .protocol.TransactionInfo.Log log = 8;


    pub fn get_log(&self) -> &[TransactionInfo_Log] {
        &self.log
    }
    pub fn clear_log(&mut self) {
        self.log.clear();
    }

    // Param is passed by value, moved
    pub fn set_log(&mut self, v: ::protobuf::RepeatedField<TransactionInfo_Log>) {
        self.log = v;
    }

    // Mutable pointer to the field.
    pub fn mut_log(&mut self) -> &mut ::protobuf::RepeatedField<TransactionInfo_Log> {
        &mut self.log
    }

    // Take field
    pub fn take_log(&mut self) -> ::protobuf::RepeatedField<TransactionInfo_Log> {
        ::std::mem::replace(&mut self.log, ::protobuf::RepeatedField::new())
    }

    // .protocol.TransactionInfo.code result = 9;


    pub fn get_result(&self) -> TransactionInfo_code {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = TransactionInfo_code::SUCESS;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: TransactionInfo_code) {
        self.result = v;
    }

    // bytes resMessage = 10;


    pub fn get_resMessage(&self) -> &[u8] {
        &self.resMessage
    }
    pub fn clear_resMessage(&mut self) {
        self.resMessage.clear();
    }

    // Param is passed by value, moved
    pub fn set_resMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.resMessage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.resMessage
    }

    // Take field
    pub fn take_resMessage(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.resMessage, ::std::vec::Vec::new())
    }

    // string assetIssueID = 14;


    pub fn get_assetIssueID(&self) -> &str {
        &self.assetIssueID
    }
    pub fn clear_assetIssueID(&mut self) {
        self.assetIssueID.clear();
    }

    // Param is passed by value, moved
    pub fn set_assetIssueID(&mut self, v: ::std::string::String) {
        self.assetIssueID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assetIssueID(&mut self) -> &mut ::std::string::String {
        &mut self.assetIssueID
    }

    // Take field
    pub fn take_assetIssueID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.assetIssueID, ::std::string::String::new())
    }

    // int64 withdraw_amount = 15;


    pub fn get_withdraw_amount(&self) -> i64 {
        self.withdraw_amount
    }
    pub fn clear_withdraw_amount(&mut self) {
        self.withdraw_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_withdraw_amount(&mut self, v: i64) {
        self.withdraw_amount = v;
    }

    // int64 unfreeze_amount = 16;


    pub fn get_unfreeze_amount(&self) -> i64 {
        self.unfreeze_amount
    }
    pub fn clear_unfreeze_amount(&mut self) {
        self.unfreeze_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_unfreeze_amount(&mut self, v: i64) {
        self.unfreeze_amount = v;
    }

    // repeated .protocol.InternalTransaction internal_transactions = 17;


    pub fn get_internal_transactions(&self) -> &[InternalTransaction] {
        &self.internal_transactions
    }
    pub fn clear_internal_transactions(&mut self) {
        self.internal_transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_internal_transactions(&mut self, v: ::protobuf::RepeatedField<InternalTransaction>) {
        self.internal_transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_internal_transactions(&mut self) -> &mut ::protobuf::RepeatedField<InternalTransaction> {
        &mut self.internal_transactions
    }

    // Take field
    pub fn take_internal_transactions(&mut self) -> ::protobuf::RepeatedField<InternalTransaction> {
        ::std::mem::replace(&mut self.internal_transactions, ::protobuf::RepeatedField::new())
    }

    // int64 exchange_received_amount = 18;


    pub fn get_exchange_received_amount(&self) -> i64 {
        self.exchange_received_amount
    }
    pub fn clear_exchange_received_amount(&mut self) {
        self.exchange_received_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_received_amount(&mut self, v: i64) {
        self.exchange_received_amount = v;
    }

    // int64 exchange_inject_another_amount = 19;


    pub fn get_exchange_inject_another_amount(&self) -> i64 {
        self.exchange_inject_another_amount
    }
    pub fn clear_exchange_inject_another_amount(&mut self) {
        self.exchange_inject_another_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_inject_another_amount(&mut self, v: i64) {
        self.exchange_inject_another_amount = v;
    }

    // int64 exchange_withdraw_another_amount = 20;


    pub fn get_exchange_withdraw_another_amount(&self) -> i64 {
        self.exchange_withdraw_another_amount
    }
    pub fn clear_exchange_withdraw_another_amount(&mut self) {
        self.exchange_withdraw_another_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_withdraw_another_amount(&mut self, v: i64) {
        self.exchange_withdraw_another_amount = v;
    }

    // int64 exchange_id = 21;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // int64 shielded_transaction_fee = 22;


    pub fn get_shielded_transaction_fee(&self) -> i64 {
        self.shielded_transaction_fee
    }
    pub fn clear_shielded_transaction_fee(&mut self) {
        self.shielded_transaction_fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_shielded_transaction_fee(&mut self, v: i64) {
        self.shielded_transaction_fee = v;
    }
}

impl ::protobuf::Message for TransactionInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.receipt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.log {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.internal_transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockNumber = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockTimeStamp = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.contractResult)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.receipt)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.log)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.resMessage)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.assetIssueID)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.withdraw_amount = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unfreeze_amount = tmp;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.internal_transactions)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_received_amount = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_inject_another_amount = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_withdraw_another_amount = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.shielded_transaction_fee = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(2, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(3, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockTimeStamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.blockTimeStamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.contractResult {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.contract_address);
        }
        if let Some(ref v) = self.receipt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.log {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.result != TransactionInfo_code::SUCESS {
            my_size += ::protobuf::rt::enum_size(9, self.result);
        }
        if !self.resMessage.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.resMessage);
        }
        if !self.assetIssueID.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.assetIssueID);
        }
        if self.withdraw_amount != 0 {
            my_size += ::protobuf::rt::value_size(15, self.withdraw_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unfreeze_amount != 0 {
            my_size += ::protobuf::rt::value_size(16, self.unfreeze_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.internal_transactions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.exchange_received_amount != 0 {
            my_size += ::protobuf::rt::value_size(18, self.exchange_received_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_inject_another_amount != 0 {
            my_size += ::protobuf::rt::value_size(19, self.exchange_inject_another_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_withdraw_another_amount != 0 {
            my_size += ::protobuf::rt::value_size(20, self.exchange_withdraw_another_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(21, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shielded_transaction_fee != 0 {
            my_size += ::protobuf::rt::value_size(22, self.shielded_transaction_fee, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if self.fee != 0 {
            os.write_int64(2, self.fee)?;
        }
        if self.blockNumber != 0 {
            os.write_int64(3, self.blockNumber)?;
        }
        if self.blockTimeStamp != 0 {
            os.write_int64(4, self.blockTimeStamp)?;
        }
        for v in &self.contractResult {
            os.write_bytes(5, &v)?;
        };
        if !self.contract_address.is_empty() {
            os.write_bytes(6, &self.contract_address)?;
        }
        if let Some(ref v) = self.receipt.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.log {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.result != TransactionInfo_code::SUCESS {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        if !self.resMessage.is_empty() {
            os.write_bytes(10, &self.resMessage)?;
        }
        if !self.assetIssueID.is_empty() {
            os.write_string(14, &self.assetIssueID)?;
        }
        if self.withdraw_amount != 0 {
            os.write_int64(15, self.withdraw_amount)?;
        }
        if self.unfreeze_amount != 0 {
            os.write_int64(16, self.unfreeze_amount)?;
        }
        for v in &self.internal_transactions {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.exchange_received_amount != 0 {
            os.write_int64(18, self.exchange_received_amount)?;
        }
        if self.exchange_inject_another_amount != 0 {
            os.write_int64(19, self.exchange_inject_another_amount)?;
        }
        if self.exchange_withdraw_another_amount != 0 {
            os.write_int64(20, self.exchange_withdraw_another_amount)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(21, self.exchange_id)?;
        }
        if self.shielded_transaction_fee != 0 {
            os.write_int64(22, self.shielded_transaction_fee)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionInfo {
        TransactionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "id",
                |m: &TransactionInfo| { &m.id },
                |m: &mut TransactionInfo| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fee",
                |m: &TransactionInfo| { &m.fee },
                |m: &mut TransactionInfo| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "blockNumber",
                |m: &TransactionInfo| { &m.blockNumber },
                |m: &mut TransactionInfo| { &mut m.blockNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "blockTimeStamp",
                |m: &TransactionInfo| { &m.blockTimeStamp },
                |m: &mut TransactionInfo| { &mut m.blockTimeStamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contractResult",
                |m: &TransactionInfo| { &m.contractResult },
                |m: &mut TransactionInfo| { &mut m.contractResult },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contract_address",
                |m: &TransactionInfo| { &m.contract_address },
                |m: &mut TransactionInfo| { &mut m.contract_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReceipt>>(
                "receipt",
                |m: &TransactionInfo| { &m.receipt },
                |m: &mut TransactionInfo| { &mut m.receipt },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionInfo_Log>>(
                "log",
                |m: &TransactionInfo| { &m.log },
                |m: &mut TransactionInfo| { &mut m.log },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionInfo_code>>(
                "result",
                |m: &TransactionInfo| { &m.result },
                |m: &mut TransactionInfo| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "resMessage",
                |m: &TransactionInfo| { &m.resMessage },
                |m: &mut TransactionInfo| { &mut m.resMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "assetIssueID",
                |m: &TransactionInfo| { &m.assetIssueID },
                |m: &mut TransactionInfo| { &mut m.assetIssueID },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "withdraw_amount",
                |m: &TransactionInfo| { &m.withdraw_amount },
                |m: &mut TransactionInfo| { &mut m.withdraw_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unfreeze_amount",
                |m: &TransactionInfo| { &m.unfreeze_amount },
                |m: &mut TransactionInfo| { &mut m.unfreeze_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InternalTransaction>>(
                "internal_transactions",
                |m: &TransactionInfo| { &m.internal_transactions },
                |m: &mut TransactionInfo| { &mut m.internal_transactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_received_amount",
                |m: &TransactionInfo| { &m.exchange_received_amount },
                |m: &mut TransactionInfo| { &mut m.exchange_received_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_inject_another_amount",
                |m: &TransactionInfo| { &m.exchange_inject_another_amount },
                |m: &mut TransactionInfo| { &mut m.exchange_inject_another_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_withdraw_another_amount",
                |m: &TransactionInfo| { &m.exchange_withdraw_another_amount },
                |m: &mut TransactionInfo| { &mut m.exchange_withdraw_another_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_id",
                |m: &TransactionInfo| { &m.exchange_id },
                |m: &mut TransactionInfo| { &mut m.exchange_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "shielded_transaction_fee",
                |m: &TransactionInfo| { &m.shielded_transaction_fee },
                |m: &mut TransactionInfo| { &mut m.shielded_transaction_fee },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionInfo>(
                "TransactionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionInfo {
        static instance: ::protobuf::rt::LazyV2<TransactionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionInfo::new)
    }
}

impl ::protobuf::Clear for TransactionInfo {
    fn clear(&mut self) {
        self.id.clear();
        self.fee = 0;
        self.blockNumber = 0;
        self.blockTimeStamp = 0;
        self.contractResult.clear();
        self.contract_address.clear();
        self.receipt.clear();
        self.log.clear();
        self.result = TransactionInfo_code::SUCESS;
        self.resMessage.clear();
        self.assetIssueID.clear();
        self.withdraw_amount = 0;
        self.unfreeze_amount = 0;
        self.internal_transactions.clear();
        self.exchange_received_amount = 0;
        self.exchange_inject_another_amount = 0;
        self.exchange_withdraw_another_amount = 0;
        self.exchange_id = 0;
        self.shielded_transaction_fee = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionInfo_Log {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub topics: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionInfo_Log {
    fn default() -> &'a TransactionInfo_Log {
        <TransactionInfo_Log as ::protobuf::Message>::default_instance()
    }
}

impl TransactionInfo_Log {
    pub fn new() -> TransactionInfo_Log {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    // repeated bytes topics = 2;


    pub fn get_topics(&self) -> &[::std::vec::Vec<u8>] {
        &self.topics
    }
    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    // bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TransactionInfo_Log {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.topics)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        for value in &self.topics {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        for v in &self.topics {
            os.write_bytes(2, &v)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionInfo_Log {
        TransactionInfo_Log::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &TransactionInfo_Log| { &m.address },
                |m: &mut TransactionInfo_Log| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "topics",
                |m: &TransactionInfo_Log| { &m.topics },
                |m: &mut TransactionInfo_Log| { &mut m.topics },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &TransactionInfo_Log| { &m.data },
                |m: &mut TransactionInfo_Log| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionInfo_Log>(
                "TransactionInfo.Log",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionInfo_Log {
        static instance: ::protobuf::rt::LazyV2<TransactionInfo_Log> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionInfo_Log::new)
    }
}

impl ::protobuf::Clear for TransactionInfo_Log {
    fn clear(&mut self) {
        self.address.clear();
        self.topics.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionInfo_Log {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo_Log {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum TransactionInfo_code {
    SUCESS = 0,
    FAILED = 1,
}

impl ::protobuf::ProtobufEnum for TransactionInfo_code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionInfo_code> {
        match value {
            0 => ::std::option::Option::Some(TransactionInfo_code::SUCESS),
            1 => ::std::option::Option::Some(TransactionInfo_code::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionInfo_code] = &[
            TransactionInfo_code::SUCESS,
            TransactionInfo_code::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TransactionInfo_code>("TransactionInfo.code", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TransactionInfo_code {
}

impl ::std::default::Default for TransactionInfo_code {
    fn default() -> Self {
        TransactionInfo_code::SUCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo_code {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionRet {
    // message fields
    pub blockNumber: i64,
    pub blockTimeStamp: i64,
    pub transactioninfo: ::protobuf::RepeatedField<TransactionInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionRet {
    fn default() -> &'a TransactionRet {
        <TransactionRet as ::protobuf::Message>::default_instance()
    }
}

impl TransactionRet {
    pub fn new() -> TransactionRet {
        ::std::default::Default::default()
    }

    // int64 blockNumber = 1;


    pub fn get_blockNumber(&self) -> i64 {
        self.blockNumber
    }
    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: i64) {
        self.blockNumber = v;
    }

    // int64 blockTimeStamp = 2;


    pub fn get_blockTimeStamp(&self) -> i64 {
        self.blockTimeStamp
    }
    pub fn clear_blockTimeStamp(&mut self) {
        self.blockTimeStamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockTimeStamp(&mut self, v: i64) {
        self.blockTimeStamp = v;
    }

    // repeated .protocol.TransactionInfo transactioninfo = 3;


    pub fn get_transactioninfo(&self) -> &[TransactionInfo] {
        &self.transactioninfo
    }
    pub fn clear_transactioninfo(&mut self) {
        self.transactioninfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactioninfo(&mut self, v: ::protobuf::RepeatedField<TransactionInfo>) {
        self.transactioninfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactioninfo(&mut self) -> &mut ::protobuf::RepeatedField<TransactionInfo> {
        &mut self.transactioninfo
    }

    // Take field
    pub fn take_transactioninfo(&mut self) -> ::protobuf::RepeatedField<TransactionInfo> {
        ::std::mem::replace(&mut self.transactioninfo, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TransactionRet {
    fn is_initialized(&self) -> bool {
        for v in &self.transactioninfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockTimeStamp = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactioninfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockTimeStamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blockTimeStamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.transactioninfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_int64(1, self.blockNumber)?;
        }
        if self.blockTimeStamp != 0 {
            os.write_int64(2, self.blockTimeStamp)?;
        }
        for v in &self.transactioninfo {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionRet {
        TransactionRet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "blockNumber",
                |m: &TransactionRet| { &m.blockNumber },
                |m: &mut TransactionRet| { &mut m.blockNumber },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "blockTimeStamp",
                |m: &TransactionRet| { &m.blockTimeStamp },
                |m: &mut TransactionRet| { &mut m.blockTimeStamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionInfo>>(
                "transactioninfo",
                |m: &TransactionRet| { &m.transactioninfo },
                |m: &mut TransactionRet| { &mut m.transactioninfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionRet>(
                "TransactionRet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionRet {
        static instance: ::protobuf::rt::LazyV2<TransactionRet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionRet::new)
    }
}

impl ::protobuf::Clear for TransactionRet {
    fn clear(&mut self) {
        self.blockNumber = 0;
        self.blockTimeStamp = 0;
        self.transactioninfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionRet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionRet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Transactions {
    // message fields
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transactions {
    fn default() -> &'a Transactions {
        <Transactions as ::protobuf::Message>::default_instance()
    }
}

impl Transactions {
    pub fn new() -> Transactions {
        ::std::default::Default::default()
    }

    // repeated .protocol.Transaction transactions = 1;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Transactions {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transactions {
        Transactions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                "transactions",
                |m: &Transactions| { &m.transactions },
                |m: &mut Transactions| { &mut m.transactions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transactions>(
                "Transactions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Transactions {
        static instance: ::protobuf::rt::LazyV2<Transactions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Transactions::new)
    }
}

impl ::protobuf::Clear for Transactions {
    fn clear(&mut self) {
        self.transactions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transactions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transactions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransactionSign {
    // message fields
    pub transaction: ::protobuf::SingularPtrField<Transaction>,
    pub privateKey: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransactionSign {
    fn default() -> &'a TransactionSign {
        <TransactionSign as ::protobuf::Message>::default_instance()
    }
}

impl TransactionSign {
    pub fn new() -> TransactionSign {
        ::std::default::Default::default()
    }

    // .protocol.Transaction transaction = 1;


    pub fn get_transaction(&self) -> &Transaction {
        self.transaction.as_ref().unwrap_or_else(|| <Transaction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: Transaction) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut Transaction {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> Transaction {
        self.transaction.take().unwrap_or_else(|| Transaction::new())
    }

    // bytes privateKey = 2;


    pub fn get_privateKey(&self) -> &[u8] {
        &self.privateKey
    }
    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.privateKey, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TransactionSign {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.privateKey);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.privateKey.is_empty() {
            os.write_bytes(2, &self.privateKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionSign {
        TransactionSign::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                "transaction",
                |m: &TransactionSign| { &m.transaction },
                |m: &mut TransactionSign| { &mut m.transaction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "privateKey",
                |m: &TransactionSign| { &m.privateKey },
                |m: &mut TransactionSign| { &mut m.privateKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransactionSign>(
                "TransactionSign",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransactionSign {
        static instance: ::protobuf::rt::LazyV2<TransactionSign> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransactionSign::new)
    }
}

impl ::protobuf::Clear for TransactionSign {
    fn clear(&mut self) {
        self.transaction.clear();
        self.privateKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionSign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionSign {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockHeader {
    // message fields
    pub raw_data: ::protobuf::SingularPtrField<BlockHeader_raw>,
    pub witness_signature: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockHeader {
    fn default() -> &'a BlockHeader {
        <BlockHeader as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader {
    pub fn new() -> BlockHeader {
        ::std::default::Default::default()
    }

    // .protocol.BlockHeader.raw raw_data = 1;


    pub fn get_raw_data(&self) -> &BlockHeader_raw {
        self.raw_data.as_ref().unwrap_or_else(|| <BlockHeader_raw as ::protobuf::Message>::default_instance())
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: BlockHeader_raw) {
        self.raw_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut BlockHeader_raw {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> BlockHeader_raw {
        self.raw_data.take().unwrap_or_else(|| BlockHeader_raw::new())
    }

    // bytes witness_signature = 2;


    pub fn get_witness_signature(&self) -> &[u8] {
        &self.witness_signature
    }
    pub fn clear_witness_signature(&mut self) {
        self.witness_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_witness_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.witness_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.witness_signature
    }

    // Take field
    pub fn take_witness_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.witness_signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockHeader {
    fn is_initialized(&self) -> bool {
        for v in &self.raw_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.raw_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.witness_signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.witness_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.witness_signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.witness_signature.is_empty() {
            os.write_bytes(2, &self.witness_signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockHeader {
        BlockHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockHeader_raw>>(
                "raw_data",
                |m: &BlockHeader| { &m.raw_data },
                |m: &mut BlockHeader| { &mut m.raw_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "witness_signature",
                |m: &BlockHeader| { &m.witness_signature },
                |m: &mut BlockHeader| { &mut m.witness_signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockHeader>(
                "BlockHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockHeader {
        static instance: ::protobuf::rt::LazyV2<BlockHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockHeader::new)
    }
}

impl ::protobuf::Clear for BlockHeader {
    fn clear(&mut self) {
        self.raw_data.clear();
        self.witness_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockHeader_raw {
    // message fields
    pub timestamp: i64,
    pub txTrieRoot: ::std::vec::Vec<u8>,
    pub parentHash: ::std::vec::Vec<u8>,
    pub number: i64,
    pub witness_id: i64,
    pub witness_address: ::std::vec::Vec<u8>,
    pub version: i32,
    pub accountStateRoot: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockHeader_raw {
    fn default() -> &'a BlockHeader_raw {
        <BlockHeader_raw as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeader_raw {
    pub fn new() -> BlockHeader_raw {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // bytes txTrieRoot = 2;


    pub fn get_txTrieRoot(&self) -> &[u8] {
        &self.txTrieRoot
    }
    pub fn clear_txTrieRoot(&mut self) {
        self.txTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_txTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.txTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txTrieRoot
    }

    // Take field
    pub fn take_txTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txTrieRoot, ::std::vec::Vec::new())
    }

    // bytes parentHash = 3;


    pub fn get_parentHash(&self) -> &[u8] {
        &self.parentHash
    }
    pub fn clear_parentHash(&mut self) {
        self.parentHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.parentHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parentHash
    }

    // Take field
    pub fn take_parentHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parentHash, ::std::vec::Vec::new())
    }

    // int64 number = 7;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }

    // int64 witness_id = 8;


    pub fn get_witness_id(&self) -> i64 {
        self.witness_id
    }
    pub fn clear_witness_id(&mut self) {
        self.witness_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_witness_id(&mut self, v: i64) {
        self.witness_id = v;
    }

    // bytes witness_address = 9;


    pub fn get_witness_address(&self) -> &[u8] {
        &self.witness_address
    }
    pub fn clear_witness_address(&mut self) {
        self.witness_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_witness_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.witness_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.witness_address
    }

    // Take field
    pub fn take_witness_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.witness_address, ::std::vec::Vec::new())
    }

    // int32 version = 10;


    pub fn get_version(&self) -> i32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = v;
    }

    // bytes accountStateRoot = 11;


    pub fn get_accountStateRoot(&self) -> &[u8] {
        &self.accountStateRoot
    }
    pub fn clear_accountStateRoot(&mut self) {
        self.accountStateRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountStateRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.accountStateRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountStateRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.accountStateRoot
    }

    // Take field
    pub fn take_accountStateRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.accountStateRoot, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockHeader_raw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txTrieRoot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parentHash)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.witness_id = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.witness_address)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.accountStateRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.txTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.txTrieRoot);
        }
        if !self.parentHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.parentHash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(7, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.witness_id != 0 {
            my_size += ::protobuf::rt::value_size(8, self.witness_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.witness_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.witness_address);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(10, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.accountStateRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.accountStateRoot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        if !self.txTrieRoot.is_empty() {
            os.write_bytes(2, &self.txTrieRoot)?;
        }
        if !self.parentHash.is_empty() {
            os.write_bytes(3, &self.parentHash)?;
        }
        if self.number != 0 {
            os.write_int64(7, self.number)?;
        }
        if self.witness_id != 0 {
            os.write_int64(8, self.witness_id)?;
        }
        if !self.witness_address.is_empty() {
            os.write_bytes(9, &self.witness_address)?;
        }
        if self.version != 0 {
            os.write_int32(10, self.version)?;
        }
        if !self.accountStateRoot.is_empty() {
            os.write_bytes(11, &self.accountStateRoot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockHeader_raw {
        BlockHeader_raw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &BlockHeader_raw| { &m.timestamp },
                |m: &mut BlockHeader_raw| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "txTrieRoot",
                |m: &BlockHeader_raw| { &m.txTrieRoot },
                |m: &mut BlockHeader_raw| { &mut m.txTrieRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parentHash",
                |m: &BlockHeader_raw| { &m.parentHash },
                |m: &mut BlockHeader_raw| { &mut m.parentHash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "number",
                |m: &BlockHeader_raw| { &m.number },
                |m: &mut BlockHeader_raw| { &mut m.number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "witness_id",
                |m: &BlockHeader_raw| { &m.witness_id },
                |m: &mut BlockHeader_raw| { &mut m.witness_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "witness_address",
                |m: &BlockHeader_raw| { &m.witness_address },
                |m: &mut BlockHeader_raw| { &mut m.witness_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &BlockHeader_raw| { &m.version },
                |m: &mut BlockHeader_raw| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "accountStateRoot",
                |m: &BlockHeader_raw| { &m.accountStateRoot },
                |m: &mut BlockHeader_raw| { &mut m.accountStateRoot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockHeader_raw>(
                "BlockHeader.raw",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockHeader_raw {
        static instance: ::protobuf::rt::LazyV2<BlockHeader_raw> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockHeader_raw::new)
    }
}

impl ::protobuf::Clear for BlockHeader_raw {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.txTrieRoot.clear();
        self.parentHash.clear();
        self.number = 0;
        self.witness_id = 0;
        self.witness_address.clear();
        self.version = 0;
        self.accountStateRoot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockHeader_raw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeader_raw {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Block {
    // message fields
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    pub block_header: ::protobuf::SingularPtrField<BlockHeader>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // repeated .protocol.Transaction transactions = 1;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    // .protocol.BlockHeader block_header = 2;


    pub fn get_block_header(&self) -> &BlockHeader {
        self.block_header.as_ref().unwrap_or_else(|| <BlockHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block_header(&mut self) {
        self.block_header.clear();
    }

    pub fn has_block_header(&self) -> bool {
        self.block_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_header(&mut self, v: BlockHeader) {
        self.block_header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_header(&mut self) -> &mut BlockHeader {
        if self.block_header.is_none() {
            self.block_header.set_default();
        }
        self.block_header.as_mut().unwrap()
    }

    // Take field
    pub fn take_block_header(&mut self) -> BlockHeader {
        self.block_header.take().unwrap_or_else(|| BlockHeader::new())
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block_header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block_header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.block_header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.block_header.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                "transactions",
                |m: &Block| { &m.transactions },
                |m: &mut Block| { &mut m.transactions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockHeader>>(
                "block_header",
                |m: &Block| { &m.block_header },
                |m: &mut Block| { &mut m.block_header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Block>(
                "Block",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Block {
        static instance: ::protobuf::rt::LazyV2<Block> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Block::new)
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.transactions.clear();
        self.block_header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ChainInventory {
    // message fields
    pub ids: ::protobuf::RepeatedField<ChainInventory_BlockId>,
    pub remain_num: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainInventory {
    fn default() -> &'a ChainInventory {
        <ChainInventory as ::protobuf::Message>::default_instance()
    }
}

impl ChainInventory {
    pub fn new() -> ChainInventory {
        ::std::default::Default::default()
    }

    // repeated .protocol.ChainInventory.BlockId ids = 1;


    pub fn get_ids(&self) -> &[ChainInventory_BlockId] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<ChainInventory_BlockId>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<ChainInventory_BlockId> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<ChainInventory_BlockId> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // int64 remain_num = 2;


    pub fn get_remain_num(&self) -> i64 {
        self.remain_num
    }
    pub fn clear_remain_num(&mut self) {
        self.remain_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_remain_num(&mut self, v: i64) {
        self.remain_num = v;
    }
}

impl ::protobuf::Message for ChainInventory {
    fn is_initialized(&self) -> bool {
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remain_num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.remain_num != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remain_num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.remain_num != 0 {
            os.write_int64(2, self.remain_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainInventory {
        ChainInventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChainInventory_BlockId>>(
                "ids",
                |m: &ChainInventory| { &m.ids },
                |m: &mut ChainInventory| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "remain_num",
                |m: &ChainInventory| { &m.remain_num },
                |m: &mut ChainInventory| { &mut m.remain_num },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainInventory>(
                "ChainInventory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainInventory {
        static instance: ::protobuf::rt::LazyV2<ChainInventory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainInventory::new)
    }
}

impl ::protobuf::Clear for ChainInventory {
    fn clear(&mut self) {
        self.ids.clear();
        self.remain_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainInventory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ChainInventory_BlockId {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub number: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChainInventory_BlockId {
    fn default() -> &'a ChainInventory_BlockId {
        <ChainInventory_BlockId as ::protobuf::Message>::default_instance()
    }
}

impl ChainInventory_BlockId {
    pub fn new() -> ChainInventory_BlockId {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // int64 number = 2;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }
}

impl ::protobuf::Message for ChainInventory_BlockId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.number != 0 {
            os.write_int64(2, self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChainInventory_BlockId {
        ChainInventory_BlockId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &ChainInventory_BlockId| { &m.hash },
                |m: &mut ChainInventory_BlockId| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "number",
                |m: &ChainInventory_BlockId| { &m.number },
                |m: &mut ChainInventory_BlockId| { &mut m.number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChainInventory_BlockId>(
                "ChainInventory.BlockId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChainInventory_BlockId {
        static instance: ::protobuf::rt::LazyV2<ChainInventory_BlockId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChainInventory_BlockId::new)
    }
}

impl ::protobuf::Clear for ChainInventory_BlockId {
    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChainInventory_BlockId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChainInventory_BlockId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockInventory {
    // message fields
    pub ids: ::protobuf::RepeatedField<BlockInventory_BlockId>,
    pub field_type: BlockInventory_Type,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockInventory {
    fn default() -> &'a BlockInventory {
        <BlockInventory as ::protobuf::Message>::default_instance()
    }
}

impl BlockInventory {
    pub fn new() -> BlockInventory {
        ::std::default::Default::default()
    }

    // repeated .protocol.BlockInventory.BlockId ids = 1;


    pub fn get_ids(&self) -> &[BlockInventory_BlockId] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<BlockInventory_BlockId>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<BlockInventory_BlockId> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<BlockInventory_BlockId> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    // .protocol.BlockInventory.Type type = 2;


    pub fn get_field_type(&self) -> BlockInventory_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = BlockInventory_Type::SYNC;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: BlockInventory_Type) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for BlockInventory {
    fn is_initialized(&self) -> bool {
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.field_type != BlockInventory_Type::SYNC {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.field_type != BlockInventory_Type::SYNC {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockInventory {
        BlockInventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockInventory_BlockId>>(
                "ids",
                |m: &BlockInventory| { &m.ids },
                |m: &mut BlockInventory| { &mut m.ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BlockInventory_Type>>(
                "type",
                |m: &BlockInventory| { &m.field_type },
                |m: &mut BlockInventory| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockInventory>(
                "BlockInventory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockInventory {
        static instance: ::protobuf::rt::LazyV2<BlockInventory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockInventory::new)
    }
}

impl ::protobuf::Clear for BlockInventory {
    fn clear(&mut self) {
        self.ids.clear();
        self.field_type = BlockInventory_Type::SYNC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockInventory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockInventory_BlockId {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub number: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockInventory_BlockId {
    fn default() -> &'a BlockInventory_BlockId {
        <BlockInventory_BlockId as ::protobuf::Message>::default_instance()
    }
}

impl BlockInventory_BlockId {
    pub fn new() -> BlockInventory_BlockId {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // int64 number = 2;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }
}

impl ::protobuf::Message for BlockInventory_BlockId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.number != 0 {
            os.write_int64(2, self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockInventory_BlockId {
        BlockInventory_BlockId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &BlockInventory_BlockId| { &m.hash },
                |m: &mut BlockInventory_BlockId| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "number",
                |m: &BlockInventory_BlockId| { &m.number },
                |m: &mut BlockInventory_BlockId| { &mut m.number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockInventory_BlockId>(
                "BlockInventory.BlockId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockInventory_BlockId {
        static instance: ::protobuf::rt::LazyV2<BlockInventory_BlockId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockInventory_BlockId::new)
    }
}

impl ::protobuf::Clear for BlockInventory_BlockId {
    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockInventory_BlockId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockInventory_BlockId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum BlockInventory_Type {
    SYNC = 0,
    ADVTISE = 1,
    FETCH = 2,
}

impl ::protobuf::ProtobufEnum for BlockInventory_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockInventory_Type> {
        match value {
            0 => ::std::option::Option::Some(BlockInventory_Type::SYNC),
            1 => ::std::option::Option::Some(BlockInventory_Type::ADVTISE),
            2 => ::std::option::Option::Some(BlockInventory_Type::FETCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlockInventory_Type] = &[
            BlockInventory_Type::SYNC,
            BlockInventory_Type::ADVTISE,
            BlockInventory_Type::FETCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BlockInventory_Type>("BlockInventory.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BlockInventory_Type {
}

impl ::std::default::Default for BlockInventory_Type {
    fn default() -> Self {
        BlockInventory_Type::SYNC
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockInventory_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Inventory {
    // message fields
    pub field_type: Inventory_InventoryType,
    pub ids: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Inventory {
    fn default() -> &'a Inventory {
        <Inventory as ::protobuf::Message>::default_instance()
    }
}

impl Inventory {
    pub fn new() -> Inventory {
        ::std::default::Default::default()
    }

    // .protocol.Inventory.InventoryType type = 1;


    pub fn get_field_type(&self) -> Inventory_InventoryType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Inventory_InventoryType::TRX;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Inventory_InventoryType) {
        self.field_type = v;
    }

    // repeated bytes ids = 2;


    pub fn get_ids(&self) -> &[::std::vec::Vec<u8>] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Inventory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Inventory_InventoryType::TRX {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Inventory_InventoryType::TRX {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        for v in &self.ids {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Inventory {
        Inventory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Inventory_InventoryType>>(
                "type",
                |m: &Inventory| { &m.field_type },
                |m: &mut Inventory| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ids",
                |m: &Inventory| { &m.ids },
                |m: &mut Inventory| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Inventory>(
                "Inventory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Inventory {
        static instance: ::protobuf::rt::LazyV2<Inventory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Inventory::new)
    }
}

impl ::protobuf::Clear for Inventory {
    fn clear(&mut self) {
        self.field_type = Inventory_InventoryType::TRX;
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Inventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Inventory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Inventory_InventoryType {
    TRX = 0,
    BLOCK = 1,
}

impl ::protobuf::ProtobufEnum for Inventory_InventoryType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Inventory_InventoryType> {
        match value {
            0 => ::std::option::Option::Some(Inventory_InventoryType::TRX),
            1 => ::std::option::Option::Some(Inventory_InventoryType::BLOCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Inventory_InventoryType] = &[
            Inventory_InventoryType::TRX,
            Inventory_InventoryType::BLOCK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Inventory_InventoryType>("Inventory.InventoryType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Inventory_InventoryType {
}

impl ::std::default::Default for Inventory_InventoryType {
    fn default() -> Self {
        Inventory_InventoryType::TRX
    }
}

impl ::protobuf::reflect::ProtobufValue for Inventory_InventoryType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Items {
    // message fields
    pub field_type: Items_ItemType,
    pub blocks: ::protobuf::RepeatedField<Block>,
    pub block_headers: ::protobuf::RepeatedField<BlockHeader>,
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Items {
    fn default() -> &'a Items {
        <Items as ::protobuf::Message>::default_instance()
    }
}

impl Items {
    pub fn new() -> Items {
        ::std::default::Default::default()
    }

    // .protocol.Items.ItemType type = 1;


    pub fn get_field_type(&self) -> Items_ItemType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Items_ItemType::ERR;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Items_ItemType) {
        self.field_type = v;
    }

    // repeated .protocol.Block blocks = 2;


    pub fn get_blocks(&self) -> &[Block] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.BlockHeader block_headers = 3;


    pub fn get_block_headers(&self) -> &[BlockHeader] {
        &self.block_headers
    }
    pub fn clear_block_headers(&mut self) {
        self.block_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_headers(&mut self, v: ::protobuf::RepeatedField<BlockHeader>) {
        self.block_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_block_headers(&mut self) -> &mut ::protobuf::RepeatedField<BlockHeader> {
        &mut self.block_headers
    }

    // Take field
    pub fn take_block_headers(&mut self) -> ::protobuf::RepeatedField<BlockHeader> {
        ::std::mem::replace(&mut self.block_headers, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.Transaction transactions = 4;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Items {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.block_headers)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Items_ItemType::ERR {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.block_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Items_ItemType::ERR {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.block_headers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.transactions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Items {
        Items::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Items_ItemType>>(
                "type",
                |m: &Items| { &m.field_type },
                |m: &mut Items| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                "blocks",
                |m: &Items| { &m.blocks },
                |m: &mut Items| { &mut m.blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockHeader>>(
                "block_headers",
                |m: &Items| { &m.block_headers },
                |m: &mut Items| { &mut m.block_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                "transactions",
                |m: &Items| { &m.transactions },
                |m: &mut Items| { &mut m.transactions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Items>(
                "Items",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Items {
        static instance: ::protobuf::rt::LazyV2<Items> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Items::new)
    }
}

impl ::protobuf::Clear for Items {
    fn clear(&mut self) {
        self.field_type = Items_ItemType::ERR;
        self.blocks.clear();
        self.block_headers.clear();
        self.transactions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Items {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Items {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Items_ItemType {
    ERR = 0,
    TRX = 1,
    BLOCK = 2,
    BLOCKHEADER = 3,
}

impl ::protobuf::ProtobufEnum for Items_ItemType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Items_ItemType> {
        match value {
            0 => ::std::option::Option::Some(Items_ItemType::ERR),
            1 => ::std::option::Option::Some(Items_ItemType::TRX),
            2 => ::std::option::Option::Some(Items_ItemType::BLOCK),
            3 => ::std::option::Option::Some(Items_ItemType::BLOCKHEADER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Items_ItemType] = &[
            Items_ItemType::ERR,
            Items_ItemType::TRX,
            Items_ItemType::BLOCK,
            Items_ItemType::BLOCKHEADER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Items_ItemType>("Items.ItemType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Items_ItemType {
}

impl ::std::default::Default for Items_ItemType {
    fn default() -> Self {
        Items_ItemType::ERR
    }
}

impl ::protobuf::reflect::ProtobufValue for Items_ItemType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DynamicProperties {
    // message fields
    pub last_solidity_block_num: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DynamicProperties {
    fn default() -> &'a DynamicProperties {
        <DynamicProperties as ::protobuf::Message>::default_instance()
    }
}

impl DynamicProperties {
    pub fn new() -> DynamicProperties {
        ::std::default::Default::default()
    }

    // int64 last_solidity_block_num = 1;


    pub fn get_last_solidity_block_num(&self) -> i64 {
        self.last_solidity_block_num
    }
    pub fn clear_last_solidity_block_num(&mut self) {
        self.last_solidity_block_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_solidity_block_num(&mut self, v: i64) {
        self.last_solidity_block_num = v;
    }
}

impl ::protobuf::Message for DynamicProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_solidity_block_num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.last_solidity_block_num != 0 {
            my_size += ::protobuf::rt::value_size(1, self.last_solidity_block_num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.last_solidity_block_num != 0 {
            os.write_int64(1, self.last_solidity_block_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DynamicProperties {
        DynamicProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_solidity_block_num",
                |m: &DynamicProperties| { &m.last_solidity_block_num },
                |m: &mut DynamicProperties| { &mut m.last_solidity_block_num },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DynamicProperties>(
                "DynamicProperties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DynamicProperties {
        static instance: ::protobuf::rt::LazyV2<DynamicProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DynamicProperties::new)
    }
}

impl ::protobuf::Clear for DynamicProperties {
    fn clear(&mut self) {
        self.last_solidity_block_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DynamicProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DisconnectMessage {
    // message fields
    pub reason: ReasonCode,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectMessage {
    fn default() -> &'a DisconnectMessage {
        <DisconnectMessage as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectMessage {
    pub fn new() -> DisconnectMessage {
        ::std::default::Default::default()
    }

    // .protocol.ReasonCode reason = 1;


    pub fn get_reason(&self) -> ReasonCode {
        self.reason
    }
    pub fn clear_reason(&mut self) {
        self.reason = ReasonCode::REQUESTED;
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ReasonCode) {
        self.reason = v;
    }
}

impl ::protobuf::Message for DisconnectMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reason != ReasonCode::REQUESTED {
            my_size += ::protobuf::rt::enum_size(1, self.reason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reason != ReasonCode::REQUESTED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.reason))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectMessage {
        DisconnectMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReasonCode>>(
                "reason",
                |m: &DisconnectMessage| { &m.reason },
                |m: &mut DisconnectMessage| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisconnectMessage>(
                "DisconnectMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisconnectMessage {
        static instance: ::protobuf::rt::LazyV2<DisconnectMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisconnectMessage::new)
    }
}

impl ::protobuf::Clear for DisconnectMessage {
    fn clear(&mut self) {
        self.reason = ReasonCode::REQUESTED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct HelloMessage {
    // message fields
    pub from: ::protobuf::SingularPtrField<super::Discover::Endpoint>,
    pub version: i32,
    pub timestamp: i64,
    pub genesisBlockId: ::protobuf::SingularPtrField<HelloMessage_BlockId>,
    pub solidBlockId: ::protobuf::SingularPtrField<HelloMessage_BlockId>,
    pub headBlockId: ::protobuf::SingularPtrField<HelloMessage_BlockId>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloMessage {
    fn default() -> &'a HelloMessage {
        <HelloMessage as ::protobuf::Message>::default_instance()
    }
}

impl HelloMessage {
    pub fn new() -> HelloMessage {
        ::std::default::Default::default()
    }

    // .protocol.Endpoint from = 1;


    pub fn get_from(&self) -> &super::Discover::Endpoint {
        self.from.as_ref().unwrap_or_else(|| <super::Discover::Endpoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    pub fn has_from(&self) -> bool {
        self.from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: super::Discover::Endpoint) {
        self.from = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut super::Discover::Endpoint {
        if self.from.is_none() {
            self.from.set_default();
        }
        self.from.as_mut().unwrap()
    }

    // Take field
    pub fn take_from(&mut self) -> super::Discover::Endpoint {
        self.from.take().unwrap_or_else(|| super::Discover::Endpoint::new())
    }

    // int32 version = 2;


    pub fn get_version(&self) -> i32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = v;
    }

    // int64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // .protocol.HelloMessage.BlockId genesisBlockId = 4;


    pub fn get_genesisBlockId(&self) -> &HelloMessage_BlockId {
        self.genesisBlockId.as_ref().unwrap_or_else(|| <HelloMessage_BlockId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_genesisBlockId(&mut self) {
        self.genesisBlockId.clear();
    }

    pub fn has_genesisBlockId(&self) -> bool {
        self.genesisBlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_genesisBlockId(&mut self, v: HelloMessage_BlockId) {
        self.genesisBlockId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_genesisBlockId(&mut self) -> &mut HelloMessage_BlockId {
        if self.genesisBlockId.is_none() {
            self.genesisBlockId.set_default();
        }
        self.genesisBlockId.as_mut().unwrap()
    }

    // Take field
    pub fn take_genesisBlockId(&mut self) -> HelloMessage_BlockId {
        self.genesisBlockId.take().unwrap_or_else(|| HelloMessage_BlockId::new())
    }

    // .protocol.HelloMessage.BlockId solidBlockId = 5;


    pub fn get_solidBlockId(&self) -> &HelloMessage_BlockId {
        self.solidBlockId.as_ref().unwrap_or_else(|| <HelloMessage_BlockId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_solidBlockId(&mut self) {
        self.solidBlockId.clear();
    }

    pub fn has_solidBlockId(&self) -> bool {
        self.solidBlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solidBlockId(&mut self, v: HelloMessage_BlockId) {
        self.solidBlockId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solidBlockId(&mut self) -> &mut HelloMessage_BlockId {
        if self.solidBlockId.is_none() {
            self.solidBlockId.set_default();
        }
        self.solidBlockId.as_mut().unwrap()
    }

    // Take field
    pub fn take_solidBlockId(&mut self) -> HelloMessage_BlockId {
        self.solidBlockId.take().unwrap_or_else(|| HelloMessage_BlockId::new())
    }

    // .protocol.HelloMessage.BlockId headBlockId = 6;


    pub fn get_headBlockId(&self) -> &HelloMessage_BlockId {
        self.headBlockId.as_ref().unwrap_or_else(|| <HelloMessage_BlockId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_headBlockId(&mut self) {
        self.headBlockId.clear();
    }

    pub fn has_headBlockId(&self) -> bool {
        self.headBlockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headBlockId(&mut self, v: HelloMessage_BlockId) {
        self.headBlockId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headBlockId(&mut self) -> &mut HelloMessage_BlockId {
        if self.headBlockId.is_none() {
            self.headBlockId.set_default();
        }
        self.headBlockId.as_mut().unwrap()
    }

    // Take field
    pub fn take_headBlockId(&mut self) -> HelloMessage_BlockId {
        self.headBlockId.take().unwrap_or_else(|| HelloMessage_BlockId::new())
    }
}

impl ::protobuf::Message for HelloMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.from {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.genesisBlockId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.solidBlockId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headBlockId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.genesisBlockId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.solidBlockId)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.headBlockId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.from.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.genesisBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.solidBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.headBlockId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.from.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.version != 0 {
            os.write_int32(2, self.version)?;
        }
        if self.timestamp != 0 {
            os.write_int64(3, self.timestamp)?;
        }
        if let Some(ref v) = self.genesisBlockId.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.solidBlockId.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.headBlockId.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloMessage {
        HelloMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Discover::Endpoint>>(
                "from",
                |m: &HelloMessage| { &m.from },
                |m: &mut HelloMessage| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "version",
                |m: &HelloMessage| { &m.version },
                |m: &mut HelloMessage| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &HelloMessage| { &m.timestamp },
                |m: &mut HelloMessage| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HelloMessage_BlockId>>(
                "genesisBlockId",
                |m: &HelloMessage| { &m.genesisBlockId },
                |m: &mut HelloMessage| { &mut m.genesisBlockId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HelloMessage_BlockId>>(
                "solidBlockId",
                |m: &HelloMessage| { &m.solidBlockId },
                |m: &mut HelloMessage| { &mut m.solidBlockId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HelloMessage_BlockId>>(
                "headBlockId",
                |m: &HelloMessage| { &m.headBlockId },
                |m: &mut HelloMessage| { &mut m.headBlockId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloMessage>(
                "HelloMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloMessage {
        static instance: ::protobuf::rt::LazyV2<HelloMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloMessage::new)
    }
}

impl ::protobuf::Clear for HelloMessage {
    fn clear(&mut self) {
        self.from.clear();
        self.version = 0;
        self.timestamp = 0;
        self.genesisBlockId.clear();
        self.solidBlockId.clear();
        self.headBlockId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct HelloMessage_BlockId {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub number: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloMessage_BlockId {
    fn default() -> &'a HelloMessage_BlockId {
        <HelloMessage_BlockId as ::protobuf::Message>::default_instance()
    }
}

impl HelloMessage_BlockId {
    pub fn new() -> HelloMessage_BlockId {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // int64 number = 2;


    pub fn get_number(&self) -> i64 {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = 0;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i64) {
        self.number = v;
    }
}

impl ::protobuf::Message for HelloMessage_BlockId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.number != 0 {
            os.write_int64(2, self.number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloMessage_BlockId {
        HelloMessage_BlockId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &HelloMessage_BlockId| { &m.hash },
                |m: &mut HelloMessage_BlockId| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "number",
                |m: &HelloMessage_BlockId| { &m.number },
                |m: &mut HelloMessage_BlockId| { &mut m.number },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloMessage_BlockId>(
                "HelloMessage.BlockId",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloMessage_BlockId {
        static instance: ::protobuf::rt::LazyV2<HelloMessage_BlockId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloMessage_BlockId::new)
    }
}

impl ::protobuf::Clear for HelloMessage_BlockId {
    fn clear(&mut self) {
        self.hash.clear();
        self.number = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloMessage_BlockId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloMessage_BlockId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SmartContract {
    // message fields
    pub origin_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub abi: ::protobuf::SingularPtrField<SmartContract_ABI>,
    pub bytecode: ::std::vec::Vec<u8>,
    pub call_value: i64,
    pub consume_user_resource_percent: i64,
    pub name: ::std::string::String,
    pub origin_energy_limit: i64,
    pub code_hash: ::std::vec::Vec<u8>,
    pub trx_hash: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmartContract {
    fn default() -> &'a SmartContract {
        <SmartContract as ::protobuf::Message>::default_instance()
    }
}

impl SmartContract {
    pub fn new() -> SmartContract {
        ::std::default::Default::default()
    }

    // bytes origin_address = 1;


    pub fn get_origin_address(&self) -> &[u8] {
        &self.origin_address
    }
    pub fn clear_origin_address(&mut self) {
        self.origin_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_origin_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.origin_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.origin_address
    }

    // Take field
    pub fn take_origin_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.origin_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // .protocol.SmartContract.ABI abi = 3;


    pub fn get_abi(&self) -> &SmartContract_ABI {
        self.abi.as_ref().unwrap_or_else(|| <SmartContract_ABI as ::protobuf::Message>::default_instance())
    }
    pub fn clear_abi(&mut self) {
        self.abi.clear();
    }

    pub fn has_abi(&self) -> bool {
        self.abi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abi(&mut self, v: SmartContract_ABI) {
        self.abi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abi(&mut self) -> &mut SmartContract_ABI {
        if self.abi.is_none() {
            self.abi.set_default();
        }
        self.abi.as_mut().unwrap()
    }

    // Take field
    pub fn take_abi(&mut self) -> SmartContract_ABI {
        self.abi.take().unwrap_or_else(|| SmartContract_ABI::new())
    }

    // bytes bytecode = 4;


    pub fn get_bytecode(&self) -> &[u8] {
        &self.bytecode
    }
    pub fn clear_bytecode(&mut self) {
        self.bytecode.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytecode(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytecode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytecode(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytecode
    }

    // Take field
    pub fn take_bytecode(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytecode, ::std::vec::Vec::new())
    }

    // int64 call_value = 5;


    pub fn get_call_value(&self) -> i64 {
        self.call_value
    }
    pub fn clear_call_value(&mut self) {
        self.call_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_value(&mut self, v: i64) {
        self.call_value = v;
    }

    // int64 consume_user_resource_percent = 6;


    pub fn get_consume_user_resource_percent(&self) -> i64 {
        self.consume_user_resource_percent
    }
    pub fn clear_consume_user_resource_percent(&mut self) {
        self.consume_user_resource_percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_consume_user_resource_percent(&mut self, v: i64) {
        self.consume_user_resource_percent = v;
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 origin_energy_limit = 8;


    pub fn get_origin_energy_limit(&self) -> i64 {
        self.origin_energy_limit
    }
    pub fn clear_origin_energy_limit(&mut self) {
        self.origin_energy_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin_energy_limit(&mut self, v: i64) {
        self.origin_energy_limit = v;
    }

    // bytes code_hash = 9;


    pub fn get_code_hash(&self) -> &[u8] {
        &self.code_hash
    }
    pub fn clear_code_hash(&mut self) {
        self.code_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_code_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.code_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.code_hash
    }

    // Take field
    pub fn take_code_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.code_hash, ::std::vec::Vec::new())
    }

    // bytes trx_hash = 10;


    pub fn get_trx_hash(&self) -> &[u8] {
        &self.trx_hash
    }
    pub fn clear_trx_hash(&mut self) {
        self.trx_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_trx_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.trx_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trx_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.trx_hash
    }

    // Take field
    pub fn take_trx_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.trx_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SmartContract {
    fn is_initialized(&self) -> bool {
        for v in &self.abi {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.origin_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.abi)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bytecode)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.consume_user_resource_percent = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.origin_energy_limit = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.code_hash)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.trx_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.origin_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.origin_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        if let Some(ref v) = self.abi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bytecode.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.bytecode);
        }
        if self.call_value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.call_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.consume_user_resource_percent != 0 {
            my_size += ::protobuf::rt::value_size(6, self.consume_user_resource_percent, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        if self.origin_energy_limit != 0 {
            my_size += ::protobuf::rt::value_size(8, self.origin_energy_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.code_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.code_hash);
        }
        if !self.trx_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.trx_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.origin_address.is_empty() {
            os.write_bytes(1, &self.origin_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        if let Some(ref v) = self.abi.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bytecode.is_empty() {
            os.write_bytes(4, &self.bytecode)?;
        }
        if self.call_value != 0 {
            os.write_int64(5, self.call_value)?;
        }
        if self.consume_user_resource_percent != 0 {
            os.write_int64(6, self.consume_user_resource_percent)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        if self.origin_energy_limit != 0 {
            os.write_int64(8, self.origin_energy_limit)?;
        }
        if !self.code_hash.is_empty() {
            os.write_bytes(9, &self.code_hash)?;
        }
        if !self.trx_hash.is_empty() {
            os.write_bytes(10, &self.trx_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmartContract {
        SmartContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "origin_address",
                |m: &SmartContract| { &m.origin_address },
                |m: &mut SmartContract| { &mut m.origin_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contract_address",
                |m: &SmartContract| { &m.contract_address },
                |m: &mut SmartContract| { &mut m.contract_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmartContract_ABI>>(
                "abi",
                |m: &SmartContract| { &m.abi },
                |m: &mut SmartContract| { &mut m.abi },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "bytecode",
                |m: &SmartContract| { &m.bytecode },
                |m: &mut SmartContract| { &mut m.bytecode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "call_value",
                |m: &SmartContract| { &m.call_value },
                |m: &mut SmartContract| { &mut m.call_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "consume_user_resource_percent",
                |m: &SmartContract| { &m.consume_user_resource_percent },
                |m: &mut SmartContract| { &mut m.consume_user_resource_percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SmartContract| { &m.name },
                |m: &mut SmartContract| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "origin_energy_limit",
                |m: &SmartContract| { &m.origin_energy_limit },
                |m: &mut SmartContract| { &mut m.origin_energy_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "code_hash",
                |m: &SmartContract| { &m.code_hash },
                |m: &mut SmartContract| { &mut m.code_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "trx_hash",
                |m: &SmartContract| { &m.trx_hash },
                |m: &mut SmartContract| { &mut m.trx_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SmartContract>(
                "SmartContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SmartContract {
        static instance: ::protobuf::rt::LazyV2<SmartContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SmartContract::new)
    }
}

impl ::protobuf::Clear for SmartContract {
    fn clear(&mut self) {
        self.origin_address.clear();
        self.contract_address.clear();
        self.abi.clear();
        self.bytecode.clear();
        self.call_value = 0;
        self.consume_user_resource_percent = 0;
        self.name.clear();
        self.origin_energy_limit = 0;
        self.code_hash.clear();
        self.trx_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmartContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SmartContract_ABI {
    // message fields
    pub entrys: ::protobuf::RepeatedField<SmartContract_ABI_Entry>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmartContract_ABI {
    fn default() -> &'a SmartContract_ABI {
        <SmartContract_ABI as ::protobuf::Message>::default_instance()
    }
}

impl SmartContract_ABI {
    pub fn new() -> SmartContract_ABI {
        ::std::default::Default::default()
    }

    // repeated .protocol.SmartContract.ABI.Entry entrys = 1;


    pub fn get_entrys(&self) -> &[SmartContract_ABI_Entry] {
        &self.entrys
    }
    pub fn clear_entrys(&mut self) {
        self.entrys.clear();
    }

    // Param is passed by value, moved
    pub fn set_entrys(&mut self, v: ::protobuf::RepeatedField<SmartContract_ABI_Entry>) {
        self.entrys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entrys(&mut self) -> &mut ::protobuf::RepeatedField<SmartContract_ABI_Entry> {
        &mut self.entrys
    }

    // Take field
    pub fn take_entrys(&mut self) -> ::protobuf::RepeatedField<SmartContract_ABI_Entry> {
        ::std::mem::replace(&mut self.entrys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SmartContract_ABI {
    fn is_initialized(&self) -> bool {
        for v in &self.entrys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entrys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entrys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entrys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmartContract_ABI {
        SmartContract_ABI::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmartContract_ABI_Entry>>(
                "entrys",
                |m: &SmartContract_ABI| { &m.entrys },
                |m: &mut SmartContract_ABI| { &mut m.entrys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SmartContract_ABI>(
                "SmartContract.ABI",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SmartContract_ABI {
        static instance: ::protobuf::rt::LazyV2<SmartContract_ABI> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SmartContract_ABI::new)
    }
}

impl ::protobuf::Clear for SmartContract_ABI {
    fn clear(&mut self) {
        self.entrys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmartContract_ABI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SmartContract_ABI_Entry {
    // message fields
    pub anonymous: bool,
    pub constant: bool,
    pub name: ::std::string::String,
    pub inputs: ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param>,
    pub outputs: ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param>,
    pub field_type: SmartContract_ABI_Entry_EntryType,
    pub payable: bool,
    pub stateMutability: SmartContract_ABI_Entry_StateMutabilityType,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmartContract_ABI_Entry {
    fn default() -> &'a SmartContract_ABI_Entry {
        <SmartContract_ABI_Entry as ::protobuf::Message>::default_instance()
    }
}

impl SmartContract_ABI_Entry {
    pub fn new() -> SmartContract_ABI_Entry {
        ::std::default::Default::default()
    }

    // bool anonymous = 1;


    pub fn get_anonymous(&self) -> bool {
        self.anonymous
    }
    pub fn clear_anonymous(&mut self) {
        self.anonymous = false;
    }

    // Param is passed by value, moved
    pub fn set_anonymous(&mut self, v: bool) {
        self.anonymous = v;
    }

    // bool constant = 2;


    pub fn get_constant(&self) -> bool {
        self.constant
    }
    pub fn clear_constant(&mut self) {
        self.constant = false;
    }

    // Param is passed by value, moved
    pub fn set_constant(&mut self, v: bool) {
        self.constant = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .protocol.SmartContract.ABI.Entry.Param inputs = 4;


    pub fn get_inputs(&self) -> &[SmartContract_ABI_Entry_Param] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.SmartContract.ABI.Entry.Param outputs = 5;


    pub fn get_outputs(&self) -> &[SmartContract_ABI_Entry_Param] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<SmartContract_ABI_Entry_Param> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // .protocol.SmartContract.ABI.Entry.EntryType type = 6;


    pub fn get_field_type(&self) -> SmartContract_ABI_Entry_EntryType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SmartContract_ABI_Entry_EntryType::UnknownEntryType;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SmartContract_ABI_Entry_EntryType) {
        self.field_type = v;
    }

    // bool payable = 7;


    pub fn get_payable(&self) -> bool {
        self.payable
    }
    pub fn clear_payable(&mut self) {
        self.payable = false;
    }

    // Param is passed by value, moved
    pub fn set_payable(&mut self, v: bool) {
        self.payable = v;
    }

    // .protocol.SmartContract.ABI.Entry.StateMutabilityType stateMutability = 8;


    pub fn get_stateMutability(&self) -> SmartContract_ABI_Entry_StateMutabilityType {
        self.stateMutability
    }
    pub fn clear_stateMutability(&mut self) {
        self.stateMutability = SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType;
    }

    // Param is passed by value, moved
    pub fn set_stateMutability(&mut self, v: SmartContract_ABI_Entry_StateMutabilityType) {
        self.stateMutability = v;
    }
}

impl ::protobuf::Message for SmartContract_ABI_Entry {
    fn is_initialized(&self) -> bool {
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.anonymous = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.constant = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.payable = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.stateMutability, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.anonymous != false {
            my_size += 2;
        }
        if self.constant != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.field_type != SmartContract_ABI_Entry_EntryType::UnknownEntryType {
            my_size += ::protobuf::rt::enum_size(6, self.field_type);
        }
        if self.payable != false {
            my_size += 2;
        }
        if self.stateMutability != SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType {
            my_size += ::protobuf::rt::enum_size(8, self.stateMutability);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.anonymous != false {
            os.write_bool(1, self.anonymous)?;
        }
        if self.constant != false {
            os.write_bool(2, self.constant)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        for v in &self.inputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.outputs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.field_type != SmartContract_ABI_Entry_EntryType::UnknownEntryType {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.payable != false {
            os.write_bool(7, self.payable)?;
        }
        if self.stateMutability != SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.stateMutability))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmartContract_ABI_Entry {
        SmartContract_ABI_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "anonymous",
                |m: &SmartContract_ABI_Entry| { &m.anonymous },
                |m: &mut SmartContract_ABI_Entry| { &mut m.anonymous },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "constant",
                |m: &SmartContract_ABI_Entry| { &m.constant },
                |m: &mut SmartContract_ABI_Entry| { &mut m.constant },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SmartContract_ABI_Entry| { &m.name },
                |m: &mut SmartContract_ABI_Entry| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmartContract_ABI_Entry_Param>>(
                "inputs",
                |m: &SmartContract_ABI_Entry| { &m.inputs },
                |m: &mut SmartContract_ABI_Entry| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SmartContract_ABI_Entry_Param>>(
                "outputs",
                |m: &SmartContract_ABI_Entry| { &m.outputs },
                |m: &mut SmartContract_ABI_Entry| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SmartContract_ABI_Entry_EntryType>>(
                "type",
                |m: &SmartContract_ABI_Entry| { &m.field_type },
                |m: &mut SmartContract_ABI_Entry| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "payable",
                |m: &SmartContract_ABI_Entry| { &m.payable },
                |m: &mut SmartContract_ABI_Entry| { &mut m.payable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SmartContract_ABI_Entry_StateMutabilityType>>(
                "stateMutability",
                |m: &SmartContract_ABI_Entry| { &m.stateMutability },
                |m: &mut SmartContract_ABI_Entry| { &mut m.stateMutability },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SmartContract_ABI_Entry>(
                "SmartContract.ABI.Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SmartContract_ABI_Entry {
        static instance: ::protobuf::rt::LazyV2<SmartContract_ABI_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SmartContract_ABI_Entry::new)
    }
}

impl ::protobuf::Clear for SmartContract_ABI_Entry {
    fn clear(&mut self) {
        self.anonymous = false;
        self.constant = false;
        self.name.clear();
        self.inputs.clear();
        self.outputs.clear();
        self.field_type = SmartContract_ABI_Entry_EntryType::UnknownEntryType;
        self.payable = false;
        self.stateMutability = SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmartContract_ABI_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SmartContract_ABI_Entry_Param {
    // message fields
    pub indexed: bool,
    pub name: ::std::string::String,
    pub field_type: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SmartContract_ABI_Entry_Param {
    fn default() -> &'a SmartContract_ABI_Entry_Param {
        <SmartContract_ABI_Entry_Param as ::protobuf::Message>::default_instance()
    }
}

impl SmartContract_ABI_Entry_Param {
    pub fn new() -> SmartContract_ABI_Entry_Param {
        ::std::default::Default::default()
    }

    // bool indexed = 1;


    pub fn get_indexed(&self) -> bool {
        self.indexed
    }
    pub fn clear_indexed(&mut self) {
        self.indexed = false;
    }

    // Param is passed by value, moved
    pub fn set_indexed(&mut self, v: bool) {
        self.indexed = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SmartContract_ABI_Entry_Param {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.indexed = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.indexed != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.indexed != false {
            os.write_bool(1, self.indexed)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SmartContract_ABI_Entry_Param {
        SmartContract_ABI_Entry_Param::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "indexed",
                |m: &SmartContract_ABI_Entry_Param| { &m.indexed },
                |m: &mut SmartContract_ABI_Entry_Param| { &mut m.indexed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SmartContract_ABI_Entry_Param| { &m.name },
                |m: &mut SmartContract_ABI_Entry_Param| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &SmartContract_ABI_Entry_Param| { &m.field_type },
                |m: &mut SmartContract_ABI_Entry_Param| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SmartContract_ABI_Entry_Param>(
                "SmartContract.ABI.Entry.Param",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SmartContract_ABI_Entry_Param {
        static instance: ::protobuf::rt::LazyV2<SmartContract_ABI_Entry_Param> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SmartContract_ABI_Entry_Param::new)
    }
}

impl ::protobuf::Clear for SmartContract_ABI_Entry_Param {
    fn clear(&mut self) {
        self.indexed = false;
        self.name.clear();
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SmartContract_ABI_Entry_Param {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI_Entry_Param {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum SmartContract_ABI_Entry_EntryType {
    UnknownEntryType = 0,
    Constructor = 1,
    Function = 2,
    Event = 3,
    Fallback = 4,
}

impl ::protobuf::ProtobufEnum for SmartContract_ABI_Entry_EntryType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SmartContract_ABI_Entry_EntryType> {
        match value {
            0 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::UnknownEntryType),
            1 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::Constructor),
            2 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::Function),
            3 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::Event),
            4 => ::std::option::Option::Some(SmartContract_ABI_Entry_EntryType::Fallback),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SmartContract_ABI_Entry_EntryType] = &[
            SmartContract_ABI_Entry_EntryType::UnknownEntryType,
            SmartContract_ABI_Entry_EntryType::Constructor,
            SmartContract_ABI_Entry_EntryType::Function,
            SmartContract_ABI_Entry_EntryType::Event,
            SmartContract_ABI_Entry_EntryType::Fallback,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SmartContract_ABI_Entry_EntryType>("SmartContract.ABI.Entry.EntryType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SmartContract_ABI_Entry_EntryType {
}

impl ::std::default::Default for SmartContract_ABI_Entry_EntryType {
    fn default() -> Self {
        SmartContract_ABI_Entry_EntryType::UnknownEntryType
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI_Entry_EntryType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum SmartContract_ABI_Entry_StateMutabilityType {
    UnknownMutabilityType = 0,
    Pure = 1,
    View = 2,
    Nonpayable = 3,
    Payable = 4,
}

impl ::protobuf::ProtobufEnum for SmartContract_ABI_Entry_StateMutabilityType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SmartContract_ABI_Entry_StateMutabilityType> {
        match value {
            0 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType),
            1 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::Pure),
            2 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::View),
            3 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::Nonpayable),
            4 => ::std::option::Option::Some(SmartContract_ABI_Entry_StateMutabilityType::Payable),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SmartContract_ABI_Entry_StateMutabilityType] = &[
            SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType,
            SmartContract_ABI_Entry_StateMutabilityType::Pure,
            SmartContract_ABI_Entry_StateMutabilityType::View,
            SmartContract_ABI_Entry_StateMutabilityType::Nonpayable,
            SmartContract_ABI_Entry_StateMutabilityType::Payable,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SmartContract_ABI_Entry_StateMutabilityType>("SmartContract.ABI.Entry.StateMutabilityType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SmartContract_ABI_Entry_StateMutabilityType {
}

impl ::std::default::Default for SmartContract_ABI_Entry_StateMutabilityType {
    fn default() -> Self {
        SmartContract_ABI_Entry_StateMutabilityType::UnknownMutabilityType
    }
}

impl ::protobuf::reflect::ProtobufValue for SmartContract_ABI_Entry_StateMutabilityType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InternalTransaction {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub caller_address: ::std::vec::Vec<u8>,
    pub transferTo_address: ::std::vec::Vec<u8>,
    pub callValueInfo: ::protobuf::RepeatedField<InternalTransaction_CallValueInfo>,
    pub note: ::std::vec::Vec<u8>,
    pub rejected: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InternalTransaction {
    fn default() -> &'a InternalTransaction {
        <InternalTransaction as ::protobuf::Message>::default_instance()
    }
}

impl InternalTransaction {
    pub fn new() -> InternalTransaction {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // bytes caller_address = 2;


    pub fn get_caller_address(&self) -> &[u8] {
        &self.caller_address
    }
    pub fn clear_caller_address(&mut self) {
        self.caller_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_caller_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.caller_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caller_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.caller_address
    }

    // Take field
    pub fn take_caller_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.caller_address, ::std::vec::Vec::new())
    }

    // bytes transferTo_address = 3;


    pub fn get_transferTo_address(&self) -> &[u8] {
        &self.transferTo_address
    }
    pub fn clear_transferTo_address(&mut self) {
        self.transferTo_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_transferTo_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.transferTo_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transferTo_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transferTo_address
    }

    // Take field
    pub fn take_transferTo_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transferTo_address, ::std::vec::Vec::new())
    }

    // repeated .protocol.InternalTransaction.CallValueInfo callValueInfo = 4;


    pub fn get_callValueInfo(&self) -> &[InternalTransaction_CallValueInfo] {
        &self.callValueInfo
    }
    pub fn clear_callValueInfo(&mut self) {
        self.callValueInfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_callValueInfo(&mut self, v: ::protobuf::RepeatedField<InternalTransaction_CallValueInfo>) {
        self.callValueInfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_callValueInfo(&mut self) -> &mut ::protobuf::RepeatedField<InternalTransaction_CallValueInfo> {
        &mut self.callValueInfo
    }

    // Take field
    pub fn take_callValueInfo(&mut self) -> ::protobuf::RepeatedField<InternalTransaction_CallValueInfo> {
        ::std::mem::replace(&mut self.callValueInfo, ::protobuf::RepeatedField::new())
    }

    // bytes note = 5;


    pub fn get_note(&self) -> &[u8] {
        &self.note
    }
    pub fn clear_note(&mut self) {
        self.note.clear();
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::vec::Vec<u8>) {
        self.note = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.note
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.note, ::std::vec::Vec::new())
    }

    // bool rejected = 6;


    pub fn get_rejected(&self) -> bool {
        self.rejected
    }
    pub fn clear_rejected(&mut self) {
        self.rejected = false;
    }

    // Param is passed by value, moved
    pub fn set_rejected(&mut self, v: bool) {
        self.rejected = v;
    }
}

impl ::protobuf::Message for InternalTransaction {
    fn is_initialized(&self) -> bool {
        for v in &self.callValueInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.caller_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transferTo_address)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.callValueInfo)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.note)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rejected = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.caller_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.caller_address);
        }
        if !self.transferTo_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.transferTo_address);
        }
        for value in &self.callValueInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.note.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.note);
        }
        if self.rejected != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.caller_address.is_empty() {
            os.write_bytes(2, &self.caller_address)?;
        }
        if !self.transferTo_address.is_empty() {
            os.write_bytes(3, &self.transferTo_address)?;
        }
        for v in &self.callValueInfo {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.note.is_empty() {
            os.write_bytes(5, &self.note)?;
        }
        if self.rejected != false {
            os.write_bool(6, self.rejected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InternalTransaction {
        InternalTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &InternalTransaction| { &m.hash },
                |m: &mut InternalTransaction| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "caller_address",
                |m: &InternalTransaction| { &m.caller_address },
                |m: &mut InternalTransaction| { &mut m.caller_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transferTo_address",
                |m: &InternalTransaction| { &m.transferTo_address },
                |m: &mut InternalTransaction| { &mut m.transferTo_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InternalTransaction_CallValueInfo>>(
                "callValueInfo",
                |m: &InternalTransaction| { &m.callValueInfo },
                |m: &mut InternalTransaction| { &mut m.callValueInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "note",
                |m: &InternalTransaction| { &m.note },
                |m: &mut InternalTransaction| { &mut m.note },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "rejected",
                |m: &InternalTransaction| { &m.rejected },
                |m: &mut InternalTransaction| { &mut m.rejected },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InternalTransaction>(
                "InternalTransaction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InternalTransaction {
        static instance: ::protobuf::rt::LazyV2<InternalTransaction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InternalTransaction::new)
    }
}

impl ::protobuf::Clear for InternalTransaction {
    fn clear(&mut self) {
        self.hash.clear();
        self.caller_address.clear();
        self.transferTo_address.clear();
        self.callValueInfo.clear();
        self.note.clear();
        self.rejected = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InternalTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InternalTransaction_CallValueInfo {
    // message fields
    pub callValue: i64,
    pub tokenId: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InternalTransaction_CallValueInfo {
    fn default() -> &'a InternalTransaction_CallValueInfo {
        <InternalTransaction_CallValueInfo as ::protobuf::Message>::default_instance()
    }
}

impl InternalTransaction_CallValueInfo {
    pub fn new() -> InternalTransaction_CallValueInfo {
        ::std::default::Default::default()
    }

    // int64 callValue = 1;


    pub fn get_callValue(&self) -> i64 {
        self.callValue
    }
    pub fn clear_callValue(&mut self) {
        self.callValue = 0;
    }

    // Param is passed by value, moved
    pub fn set_callValue(&mut self, v: i64) {
        self.callValue = v;
    }

    // string tokenId = 2;


    pub fn get_tokenId(&self) -> &str {
        &self.tokenId
    }
    pub fn clear_tokenId(&mut self) {
        self.tokenId.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokenId(&mut self, v: ::std::string::String) {
        self.tokenId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tokenId(&mut self) -> &mut ::std::string::String {
        &mut self.tokenId
    }

    // Take field
    pub fn take_tokenId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tokenId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InternalTransaction_CallValueInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.callValue = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tokenId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.callValue != 0 {
            my_size += ::protobuf::rt::value_size(1, self.callValue, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.tokenId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tokenId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.callValue != 0 {
            os.write_int64(1, self.callValue)?;
        }
        if !self.tokenId.is_empty() {
            os.write_string(2, &self.tokenId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InternalTransaction_CallValueInfo {
        InternalTransaction_CallValueInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "callValue",
                |m: &InternalTransaction_CallValueInfo| { &m.callValue },
                |m: &mut InternalTransaction_CallValueInfo| { &mut m.callValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tokenId",
                |m: &InternalTransaction_CallValueInfo| { &m.tokenId },
                |m: &mut InternalTransaction_CallValueInfo| { &mut m.tokenId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InternalTransaction_CallValueInfo>(
                "InternalTransaction.CallValueInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InternalTransaction_CallValueInfo {
        static instance: ::protobuf::rt::LazyV2<InternalTransaction_CallValueInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InternalTransaction_CallValueInfo::new)
    }
}

impl ::protobuf::Clear for InternalTransaction_CallValueInfo {
    fn clear(&mut self) {
        self.callValue = 0;
        self.tokenId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InternalTransaction_CallValueInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalTransaction_CallValueInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DelegatedResourceAccountIndex {
    // message fields
    pub account: ::std::vec::Vec<u8>,
    pub fromAccounts: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub toAccounts: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DelegatedResourceAccountIndex {
    fn default() -> &'a DelegatedResourceAccountIndex {
        <DelegatedResourceAccountIndex as ::protobuf::Message>::default_instance()
    }
}

impl DelegatedResourceAccountIndex {
    pub fn new() -> DelegatedResourceAccountIndex {
        ::std::default::Default::default()
    }

    // bytes account = 1;


    pub fn get_account(&self) -> &[u8] {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::vec::Vec<u8>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account, ::std::vec::Vec::new())
    }

    // repeated bytes fromAccounts = 2;


    pub fn get_fromAccounts(&self) -> &[::std::vec::Vec<u8>] {
        &self.fromAccounts
    }
    pub fn clear_fromAccounts(&mut self) {
        self.fromAccounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_fromAccounts(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.fromAccounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fromAccounts(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.fromAccounts
    }

    // Take field
    pub fn take_fromAccounts(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.fromAccounts, ::protobuf::RepeatedField::new())
    }

    // repeated bytes toAccounts = 3;


    pub fn get_toAccounts(&self) -> &[::std::vec::Vec<u8>] {
        &self.toAccounts
    }
    pub fn clear_toAccounts(&mut self) {
        self.toAccounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAccounts(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.toAccounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_toAccounts(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.toAccounts
    }

    // Take field
    pub fn take_toAccounts(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.toAccounts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DelegatedResourceAccountIndex {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.fromAccounts)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.toAccounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        for value in &self.fromAccounts {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.toAccounts {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        for v in &self.fromAccounts {
            os.write_bytes(2, &v)?;
        };
        for v in &self.toAccounts {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DelegatedResourceAccountIndex {
        DelegatedResourceAccountIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "account",
                |m: &DelegatedResourceAccountIndex| { &m.account },
                |m: &mut DelegatedResourceAccountIndex| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "fromAccounts",
                |m: &DelegatedResourceAccountIndex| { &m.fromAccounts },
                |m: &mut DelegatedResourceAccountIndex| { &mut m.fromAccounts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "toAccounts",
                |m: &DelegatedResourceAccountIndex| { &m.toAccounts },
                |m: &mut DelegatedResourceAccountIndex| { &mut m.toAccounts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DelegatedResourceAccountIndex>(
                "DelegatedResourceAccountIndex",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DelegatedResourceAccountIndex {
        static instance: ::protobuf::rt::LazyV2<DelegatedResourceAccountIndex> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DelegatedResourceAccountIndex::new)
    }
}

impl ::protobuf::Clear for DelegatedResourceAccountIndex {
    fn clear(&mut self) {
        self.account.clear();
        self.fromAccounts.clear();
        self.toAccounts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DelegatedResourceAccountIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DelegatedResourceAccountIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NodeInfo {
    // message fields
    pub beginSyncNum: i64,
    pub block: ::std::string::String,
    pub solidityBlock: ::std::string::String,
    pub currentConnectCount: i32,
    pub activeConnectCount: i32,
    pub passiveConnectCount: i32,
    pub totalFlow: i64,
    pub peerInfoList: ::protobuf::RepeatedField<NodeInfo_PeerInfo>,
    pub configNodeInfo: ::protobuf::SingularPtrField<NodeInfo_ConfigNodeInfo>,
    pub machineInfo: ::protobuf::SingularPtrField<NodeInfo_MachineInfo>,
    pub cheatWitnessInfoMap: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo {
    fn default() -> &'a NodeInfo {
        <NodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo {
    pub fn new() -> NodeInfo {
        ::std::default::Default::default()
    }

    // int64 beginSyncNum = 1;


    pub fn get_beginSyncNum(&self) -> i64 {
        self.beginSyncNum
    }
    pub fn clear_beginSyncNum(&mut self) {
        self.beginSyncNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_beginSyncNum(&mut self, v: i64) {
        self.beginSyncNum = v;
    }

    // string block = 2;


    pub fn get_block(&self) -> &str {
        &self.block
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::std::string::String) {
        self.block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut ::std::string::String {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block, ::std::string::String::new())
    }

    // string solidityBlock = 3;


    pub fn get_solidityBlock(&self) -> &str {
        &self.solidityBlock
    }
    pub fn clear_solidityBlock(&mut self) {
        self.solidityBlock.clear();
    }

    // Param is passed by value, moved
    pub fn set_solidityBlock(&mut self, v: ::std::string::String) {
        self.solidityBlock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solidityBlock(&mut self) -> &mut ::std::string::String {
        &mut self.solidityBlock
    }

    // Take field
    pub fn take_solidityBlock(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.solidityBlock, ::std::string::String::new())
    }

    // int32 currentConnectCount = 4;


    pub fn get_currentConnectCount(&self) -> i32 {
        self.currentConnectCount
    }
    pub fn clear_currentConnectCount(&mut self) {
        self.currentConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_currentConnectCount(&mut self, v: i32) {
        self.currentConnectCount = v;
    }

    // int32 activeConnectCount = 5;


    pub fn get_activeConnectCount(&self) -> i32 {
        self.activeConnectCount
    }
    pub fn clear_activeConnectCount(&mut self) {
        self.activeConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_activeConnectCount(&mut self, v: i32) {
        self.activeConnectCount = v;
    }

    // int32 passiveConnectCount = 6;


    pub fn get_passiveConnectCount(&self) -> i32 {
        self.passiveConnectCount
    }
    pub fn clear_passiveConnectCount(&mut self) {
        self.passiveConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_passiveConnectCount(&mut self, v: i32) {
        self.passiveConnectCount = v;
    }

    // int64 totalFlow = 7;


    pub fn get_totalFlow(&self) -> i64 {
        self.totalFlow
    }
    pub fn clear_totalFlow(&mut self) {
        self.totalFlow = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalFlow(&mut self, v: i64) {
        self.totalFlow = v;
    }

    // repeated .protocol.NodeInfo.PeerInfo peerInfoList = 8;


    pub fn get_peerInfoList(&self) -> &[NodeInfo_PeerInfo] {
        &self.peerInfoList
    }
    pub fn clear_peerInfoList(&mut self) {
        self.peerInfoList.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerInfoList(&mut self, v: ::protobuf::RepeatedField<NodeInfo_PeerInfo>) {
        self.peerInfoList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerInfoList(&mut self) -> &mut ::protobuf::RepeatedField<NodeInfo_PeerInfo> {
        &mut self.peerInfoList
    }

    // Take field
    pub fn take_peerInfoList(&mut self) -> ::protobuf::RepeatedField<NodeInfo_PeerInfo> {
        ::std::mem::replace(&mut self.peerInfoList, ::protobuf::RepeatedField::new())
    }

    // .protocol.NodeInfo.ConfigNodeInfo configNodeInfo = 9;


    pub fn get_configNodeInfo(&self) -> &NodeInfo_ConfigNodeInfo {
        self.configNodeInfo.as_ref().unwrap_or_else(|| <NodeInfo_ConfigNodeInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configNodeInfo(&mut self) {
        self.configNodeInfo.clear();
    }

    pub fn has_configNodeInfo(&self) -> bool {
        self.configNodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configNodeInfo(&mut self, v: NodeInfo_ConfigNodeInfo) {
        self.configNodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configNodeInfo(&mut self) -> &mut NodeInfo_ConfigNodeInfo {
        if self.configNodeInfo.is_none() {
            self.configNodeInfo.set_default();
        }
        self.configNodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_configNodeInfo(&mut self) -> NodeInfo_ConfigNodeInfo {
        self.configNodeInfo.take().unwrap_or_else(|| NodeInfo_ConfigNodeInfo::new())
    }

    // .protocol.NodeInfo.MachineInfo machineInfo = 10;


    pub fn get_machineInfo(&self) -> &NodeInfo_MachineInfo {
        self.machineInfo.as_ref().unwrap_or_else(|| <NodeInfo_MachineInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_machineInfo(&mut self) {
        self.machineInfo.clear();
    }

    pub fn has_machineInfo(&self) -> bool {
        self.machineInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machineInfo(&mut self, v: NodeInfo_MachineInfo) {
        self.machineInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machineInfo(&mut self) -> &mut NodeInfo_MachineInfo {
        if self.machineInfo.is_none() {
            self.machineInfo.set_default();
        }
        self.machineInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_machineInfo(&mut self) -> NodeInfo_MachineInfo {
        self.machineInfo.take().unwrap_or_else(|| NodeInfo_MachineInfo::new())
    }

    // repeated .protocol.NodeInfo.CheatWitnessInfoMapEntry cheatWitnessInfoMap = 11;


    pub fn get_cheatWitnessInfoMap(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.cheatWitnessInfoMap
    }
    pub fn clear_cheatWitnessInfoMap(&mut self) {
        self.cheatWitnessInfoMap.clear();
    }

    // Param is passed by value, moved
    pub fn set_cheatWitnessInfoMap(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.cheatWitnessInfoMap = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cheatWitnessInfoMap(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.cheatWitnessInfoMap
    }

    // Take field
    pub fn take_cheatWitnessInfoMap(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.cheatWitnessInfoMap, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for NodeInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.peerInfoList {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configNodeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.machineInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.beginSyncNum = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.solidityBlock)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.currentConnectCount = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activeConnectCount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.passiveConnectCount = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalFlow = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peerInfoList)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configNodeInfo)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.machineInfo)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.cheatWitnessInfoMap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.beginSyncNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.beginSyncNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.block);
        }
        if !self.solidityBlock.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.solidityBlock);
        }
        if self.currentConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.currentConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.activeConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.activeConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.passiveConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(6, self.passiveConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalFlow != 0 {
            my_size += ::protobuf::rt::value_size(7, self.totalFlow, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.peerInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.configNodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.machineInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.cheatWitnessInfoMap);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.beginSyncNum != 0 {
            os.write_int64(1, self.beginSyncNum)?;
        }
        if !self.block.is_empty() {
            os.write_string(2, &self.block)?;
        }
        if !self.solidityBlock.is_empty() {
            os.write_string(3, &self.solidityBlock)?;
        }
        if self.currentConnectCount != 0 {
            os.write_int32(4, self.currentConnectCount)?;
        }
        if self.activeConnectCount != 0 {
            os.write_int32(5, self.activeConnectCount)?;
        }
        if self.passiveConnectCount != 0 {
            os.write_int32(6, self.passiveConnectCount)?;
        }
        if self.totalFlow != 0 {
            os.write_int64(7, self.totalFlow)?;
        }
        for v in &self.peerInfoList {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.configNodeInfo.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.machineInfo.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.cheatWitnessInfoMap, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo {
        NodeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "beginSyncNum",
                |m: &NodeInfo| { &m.beginSyncNum },
                |m: &mut NodeInfo| { &mut m.beginSyncNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "block",
                |m: &NodeInfo| { &m.block },
                |m: &mut NodeInfo| { &mut m.block },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "solidityBlock",
                |m: &NodeInfo| { &m.solidityBlock },
                |m: &mut NodeInfo| { &mut m.solidityBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "currentConnectCount",
                |m: &NodeInfo| { &m.currentConnectCount },
                |m: &mut NodeInfo| { &mut m.currentConnectCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "activeConnectCount",
                |m: &NodeInfo| { &m.activeConnectCount },
                |m: &mut NodeInfo| { &mut m.activeConnectCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "passiveConnectCount",
                |m: &NodeInfo| { &m.passiveConnectCount },
                |m: &mut NodeInfo| { &mut m.passiveConnectCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalFlow",
                |m: &NodeInfo| { &m.totalFlow },
                |m: &mut NodeInfo| { &mut m.totalFlow },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_PeerInfo>>(
                "peerInfoList",
                |m: &NodeInfo| { &m.peerInfoList },
                |m: &mut NodeInfo| { &mut m.peerInfoList },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_ConfigNodeInfo>>(
                "configNodeInfo",
                |m: &NodeInfo| { &m.configNodeInfo },
                |m: &mut NodeInfo| { &mut m.configNodeInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_MachineInfo>>(
                "machineInfo",
                |m: &NodeInfo| { &m.machineInfo },
                |m: &mut NodeInfo| { &mut m.machineInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "cheatWitnessInfoMap",
                |m: &NodeInfo| { &m.cheatWitnessInfoMap },
                |m: &mut NodeInfo| { &mut m.cheatWitnessInfoMap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInfo>(
                "NodeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInfo {
        static instance: ::protobuf::rt::LazyV2<NodeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInfo::new)
    }
}

impl ::protobuf::Clear for NodeInfo {
    fn clear(&mut self) {
        self.beginSyncNum = 0;
        self.block.clear();
        self.solidityBlock.clear();
        self.currentConnectCount = 0;
        self.activeConnectCount = 0;
        self.passiveConnectCount = 0;
        self.totalFlow = 0;
        self.peerInfoList.clear();
        self.configNodeInfo.clear();
        self.machineInfo.clear();
        self.cheatWitnessInfoMap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NodeInfo_PeerInfo {
    // message fields
    pub lastSyncBlock: ::std::string::String,
    pub remainNum: i64,
    pub lastBlockUpdateTime: i64,
    pub syncFlag: bool,
    pub headBlockTimeWeBothHave: i64,
    pub needSyncFromPeer: bool,
    pub needSyncFromUs: bool,
    pub host: ::std::string::String,
    pub port: i32,
    pub nodeId: ::std::string::String,
    pub connectTime: i64,
    pub avgLatency: f64,
    pub syncToFetchSize: i32,
    pub syncToFetchSizePeekNum: i64,
    pub syncBlockRequestedSize: i32,
    pub unFetchSynNum: i64,
    pub blockInPorcSize: i32,
    pub headBlockWeBothHave: ::std::string::String,
    pub isActive: bool,
    pub score: i32,
    pub nodeCount: i32,
    pub inFlow: i64,
    pub disconnectTimes: i32,
    pub localDisconnectReason: ::std::string::String,
    pub remoteDisconnectReason: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_PeerInfo {
    fn default() -> &'a NodeInfo_PeerInfo {
        <NodeInfo_PeerInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_PeerInfo {
    pub fn new() -> NodeInfo_PeerInfo {
        ::std::default::Default::default()
    }

    // string lastSyncBlock = 1;


    pub fn get_lastSyncBlock(&self) -> &str {
        &self.lastSyncBlock
    }
    pub fn clear_lastSyncBlock(&mut self) {
        self.lastSyncBlock.clear();
    }

    // Param is passed by value, moved
    pub fn set_lastSyncBlock(&mut self, v: ::std::string::String) {
        self.lastSyncBlock = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastSyncBlock(&mut self) -> &mut ::std::string::String {
        &mut self.lastSyncBlock
    }

    // Take field
    pub fn take_lastSyncBlock(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lastSyncBlock, ::std::string::String::new())
    }

    // int64 remainNum = 2;


    pub fn get_remainNum(&self) -> i64 {
        self.remainNum
    }
    pub fn clear_remainNum(&mut self) {
        self.remainNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_remainNum(&mut self, v: i64) {
        self.remainNum = v;
    }

    // int64 lastBlockUpdateTime = 3;


    pub fn get_lastBlockUpdateTime(&self) -> i64 {
        self.lastBlockUpdateTime
    }
    pub fn clear_lastBlockUpdateTime(&mut self) {
        self.lastBlockUpdateTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastBlockUpdateTime(&mut self, v: i64) {
        self.lastBlockUpdateTime = v;
    }

    // bool syncFlag = 4;


    pub fn get_syncFlag(&self) -> bool {
        self.syncFlag
    }
    pub fn clear_syncFlag(&mut self) {
        self.syncFlag = false;
    }

    // Param is passed by value, moved
    pub fn set_syncFlag(&mut self, v: bool) {
        self.syncFlag = v;
    }

    // int64 headBlockTimeWeBothHave = 5;


    pub fn get_headBlockTimeWeBothHave(&self) -> i64 {
        self.headBlockTimeWeBothHave
    }
    pub fn clear_headBlockTimeWeBothHave(&mut self) {
        self.headBlockTimeWeBothHave = 0;
    }

    // Param is passed by value, moved
    pub fn set_headBlockTimeWeBothHave(&mut self, v: i64) {
        self.headBlockTimeWeBothHave = v;
    }

    // bool needSyncFromPeer = 6;


    pub fn get_needSyncFromPeer(&self) -> bool {
        self.needSyncFromPeer
    }
    pub fn clear_needSyncFromPeer(&mut self) {
        self.needSyncFromPeer = false;
    }

    // Param is passed by value, moved
    pub fn set_needSyncFromPeer(&mut self, v: bool) {
        self.needSyncFromPeer = v;
    }

    // bool needSyncFromUs = 7;


    pub fn get_needSyncFromUs(&self) -> bool {
        self.needSyncFromUs
    }
    pub fn clear_needSyncFromUs(&mut self) {
        self.needSyncFromUs = false;
    }

    // Param is passed by value, moved
    pub fn set_needSyncFromUs(&mut self, v: bool) {
        self.needSyncFromUs = v;
    }

    // string host = 8;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // int32 port = 9;


    pub fn get_port(&self) -> i32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    // string nodeId = 10;


    pub fn get_nodeId(&self) -> &str {
        &self.nodeId
    }
    pub fn clear_nodeId(&mut self) {
        self.nodeId.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeId(&mut self, v: ::std::string::String) {
        self.nodeId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeId(&mut self) -> &mut ::std::string::String {
        &mut self.nodeId
    }

    // Take field
    pub fn take_nodeId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodeId, ::std::string::String::new())
    }

    // int64 connectTime = 11;


    pub fn get_connectTime(&self) -> i64 {
        self.connectTime
    }
    pub fn clear_connectTime(&mut self) {
        self.connectTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_connectTime(&mut self, v: i64) {
        self.connectTime = v;
    }

    // double avgLatency = 12;


    pub fn get_avgLatency(&self) -> f64 {
        self.avgLatency
    }
    pub fn clear_avgLatency(&mut self) {
        self.avgLatency = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avgLatency(&mut self, v: f64) {
        self.avgLatency = v;
    }

    // int32 syncToFetchSize = 13;


    pub fn get_syncToFetchSize(&self) -> i32 {
        self.syncToFetchSize
    }
    pub fn clear_syncToFetchSize(&mut self) {
        self.syncToFetchSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_syncToFetchSize(&mut self, v: i32) {
        self.syncToFetchSize = v;
    }

    // int64 syncToFetchSizePeekNum = 14;


    pub fn get_syncToFetchSizePeekNum(&self) -> i64 {
        self.syncToFetchSizePeekNum
    }
    pub fn clear_syncToFetchSizePeekNum(&mut self) {
        self.syncToFetchSizePeekNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_syncToFetchSizePeekNum(&mut self, v: i64) {
        self.syncToFetchSizePeekNum = v;
    }

    // int32 syncBlockRequestedSize = 15;


    pub fn get_syncBlockRequestedSize(&self) -> i32 {
        self.syncBlockRequestedSize
    }
    pub fn clear_syncBlockRequestedSize(&mut self) {
        self.syncBlockRequestedSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_syncBlockRequestedSize(&mut self, v: i32) {
        self.syncBlockRequestedSize = v;
    }

    // int64 unFetchSynNum = 16;


    pub fn get_unFetchSynNum(&self) -> i64 {
        self.unFetchSynNum
    }
    pub fn clear_unFetchSynNum(&mut self) {
        self.unFetchSynNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_unFetchSynNum(&mut self, v: i64) {
        self.unFetchSynNum = v;
    }

    // int32 blockInPorcSize = 17;


    pub fn get_blockInPorcSize(&self) -> i32 {
        self.blockInPorcSize
    }
    pub fn clear_blockInPorcSize(&mut self) {
        self.blockInPorcSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockInPorcSize(&mut self, v: i32) {
        self.blockInPorcSize = v;
    }

    // string headBlockWeBothHave = 18;


    pub fn get_headBlockWeBothHave(&self) -> &str {
        &self.headBlockWeBothHave
    }
    pub fn clear_headBlockWeBothHave(&mut self) {
        self.headBlockWeBothHave.clear();
    }

    // Param is passed by value, moved
    pub fn set_headBlockWeBothHave(&mut self, v: ::std::string::String) {
        self.headBlockWeBothHave = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headBlockWeBothHave(&mut self) -> &mut ::std::string::String {
        &mut self.headBlockWeBothHave
    }

    // Take field
    pub fn take_headBlockWeBothHave(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.headBlockWeBothHave, ::std::string::String::new())
    }

    // bool isActive = 19;


    pub fn get_isActive(&self) -> bool {
        self.isActive
    }
    pub fn clear_isActive(&mut self) {
        self.isActive = false;
    }

    // Param is passed by value, moved
    pub fn set_isActive(&mut self, v: bool) {
        self.isActive = v;
    }

    // int32 score = 20;


    pub fn get_score(&self) -> i32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = v;
    }

    // int32 nodeCount = 21;


    pub fn get_nodeCount(&self) -> i32 {
        self.nodeCount
    }
    pub fn clear_nodeCount(&mut self) {
        self.nodeCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_nodeCount(&mut self, v: i32) {
        self.nodeCount = v;
    }

    // int64 inFlow = 22;


    pub fn get_inFlow(&self) -> i64 {
        self.inFlow
    }
    pub fn clear_inFlow(&mut self) {
        self.inFlow = 0;
    }

    // Param is passed by value, moved
    pub fn set_inFlow(&mut self, v: i64) {
        self.inFlow = v;
    }

    // int32 disconnectTimes = 23;


    pub fn get_disconnectTimes(&self) -> i32 {
        self.disconnectTimes
    }
    pub fn clear_disconnectTimes(&mut self) {
        self.disconnectTimes = 0;
    }

    // Param is passed by value, moved
    pub fn set_disconnectTimes(&mut self, v: i32) {
        self.disconnectTimes = v;
    }

    // string localDisconnectReason = 24;


    pub fn get_localDisconnectReason(&self) -> &str {
        &self.localDisconnectReason
    }
    pub fn clear_localDisconnectReason(&mut self) {
        self.localDisconnectReason.clear();
    }

    // Param is passed by value, moved
    pub fn set_localDisconnectReason(&mut self, v: ::std::string::String) {
        self.localDisconnectReason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localDisconnectReason(&mut self) -> &mut ::std::string::String {
        &mut self.localDisconnectReason
    }

    // Take field
    pub fn take_localDisconnectReason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.localDisconnectReason, ::std::string::String::new())
    }

    // string remoteDisconnectReason = 25;


    pub fn get_remoteDisconnectReason(&self) -> &str {
        &self.remoteDisconnectReason
    }
    pub fn clear_remoteDisconnectReason(&mut self) {
        self.remoteDisconnectReason.clear();
    }

    // Param is passed by value, moved
    pub fn set_remoteDisconnectReason(&mut self, v: ::std::string::String) {
        self.remoteDisconnectReason = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteDisconnectReason(&mut self) -> &mut ::std::string::String {
        &mut self.remoteDisconnectReason
    }

    // Take field
    pub fn take_remoteDisconnectReason(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remoteDisconnectReason, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeInfo_PeerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lastSyncBlock)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remainNum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastBlockUpdateTime = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.syncFlag = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.headBlockTimeWeBothHave = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needSyncFromPeer = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needSyncFromUs = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodeId)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.connectTime = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avgLatency = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.syncToFetchSize = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.syncToFetchSizePeekNum = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.syncBlockRequestedSize = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unFetchSynNum = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.blockInPorcSize = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.headBlockWeBothHave)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isActive = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.score = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nodeCount = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.inFlow = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.disconnectTimes = tmp;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.localDisconnectReason)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remoteDisconnectReason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.lastSyncBlock.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lastSyncBlock);
        }
        if self.remainNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.remainNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lastBlockUpdateTime != 0 {
            my_size += ::protobuf::rt::value_size(3, self.lastBlockUpdateTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.syncFlag != false {
            my_size += 2;
        }
        if self.headBlockTimeWeBothHave != 0 {
            my_size += ::protobuf::rt::value_size(5, self.headBlockTimeWeBothHave, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.needSyncFromPeer != false {
            my_size += 2;
        }
        if self.needSyncFromUs != false {
            my_size += 2;
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(9, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.nodeId.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.nodeId);
        }
        if self.connectTime != 0 {
            my_size += ::protobuf::rt::value_size(11, self.connectTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avgLatency != 0. {
            my_size += 9;
        }
        if self.syncToFetchSize != 0 {
            my_size += ::protobuf::rt::value_size(13, self.syncToFetchSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.syncToFetchSizePeekNum != 0 {
            my_size += ::protobuf::rt::value_size(14, self.syncToFetchSizePeekNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.syncBlockRequestedSize != 0 {
            my_size += ::protobuf::rt::value_size(15, self.syncBlockRequestedSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unFetchSynNum != 0 {
            my_size += ::protobuf::rt::value_size(16, self.unFetchSynNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockInPorcSize != 0 {
            my_size += ::protobuf::rt::value_size(17, self.blockInPorcSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.headBlockWeBothHave.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.headBlockWeBothHave);
        }
        if self.isActive != false {
            my_size += 3;
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(20, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nodeCount != 0 {
            my_size += ::protobuf::rt::value_size(21, self.nodeCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inFlow != 0 {
            my_size += ::protobuf::rt::value_size(22, self.inFlow, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disconnectTimes != 0 {
            my_size += ::protobuf::rt::value_size(23, self.disconnectTimes, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.localDisconnectReason.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.localDisconnectReason);
        }
        if !self.remoteDisconnectReason.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.remoteDisconnectReason);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.lastSyncBlock.is_empty() {
            os.write_string(1, &self.lastSyncBlock)?;
        }
        if self.remainNum != 0 {
            os.write_int64(2, self.remainNum)?;
        }
        if self.lastBlockUpdateTime != 0 {
            os.write_int64(3, self.lastBlockUpdateTime)?;
        }
        if self.syncFlag != false {
            os.write_bool(4, self.syncFlag)?;
        }
        if self.headBlockTimeWeBothHave != 0 {
            os.write_int64(5, self.headBlockTimeWeBothHave)?;
        }
        if self.needSyncFromPeer != false {
            os.write_bool(6, self.needSyncFromPeer)?;
        }
        if self.needSyncFromUs != false {
            os.write_bool(7, self.needSyncFromUs)?;
        }
        if !self.host.is_empty() {
            os.write_string(8, &self.host)?;
        }
        if self.port != 0 {
            os.write_int32(9, self.port)?;
        }
        if !self.nodeId.is_empty() {
            os.write_string(10, &self.nodeId)?;
        }
        if self.connectTime != 0 {
            os.write_int64(11, self.connectTime)?;
        }
        if self.avgLatency != 0. {
            os.write_double(12, self.avgLatency)?;
        }
        if self.syncToFetchSize != 0 {
            os.write_int32(13, self.syncToFetchSize)?;
        }
        if self.syncToFetchSizePeekNum != 0 {
            os.write_int64(14, self.syncToFetchSizePeekNum)?;
        }
        if self.syncBlockRequestedSize != 0 {
            os.write_int32(15, self.syncBlockRequestedSize)?;
        }
        if self.unFetchSynNum != 0 {
            os.write_int64(16, self.unFetchSynNum)?;
        }
        if self.blockInPorcSize != 0 {
            os.write_int32(17, self.blockInPorcSize)?;
        }
        if !self.headBlockWeBothHave.is_empty() {
            os.write_string(18, &self.headBlockWeBothHave)?;
        }
        if self.isActive != false {
            os.write_bool(19, self.isActive)?;
        }
        if self.score != 0 {
            os.write_int32(20, self.score)?;
        }
        if self.nodeCount != 0 {
            os.write_int32(21, self.nodeCount)?;
        }
        if self.inFlow != 0 {
            os.write_int64(22, self.inFlow)?;
        }
        if self.disconnectTimes != 0 {
            os.write_int32(23, self.disconnectTimes)?;
        }
        if !self.localDisconnectReason.is_empty() {
            os.write_string(24, &self.localDisconnectReason)?;
        }
        if !self.remoteDisconnectReason.is_empty() {
            os.write_string(25, &self.remoteDisconnectReason)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_PeerInfo {
        NodeInfo_PeerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastSyncBlock",
                |m: &NodeInfo_PeerInfo| { &m.lastSyncBlock },
                |m: &mut NodeInfo_PeerInfo| { &mut m.lastSyncBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "remainNum",
                |m: &NodeInfo_PeerInfo| { &m.remainNum },
                |m: &mut NodeInfo_PeerInfo| { &mut m.remainNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lastBlockUpdateTime",
                |m: &NodeInfo_PeerInfo| { &m.lastBlockUpdateTime },
                |m: &mut NodeInfo_PeerInfo| { &mut m.lastBlockUpdateTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "syncFlag",
                |m: &NodeInfo_PeerInfo| { &m.syncFlag },
                |m: &mut NodeInfo_PeerInfo| { &mut m.syncFlag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "headBlockTimeWeBothHave",
                |m: &NodeInfo_PeerInfo| { &m.headBlockTimeWeBothHave },
                |m: &mut NodeInfo_PeerInfo| { &mut m.headBlockTimeWeBothHave },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needSyncFromPeer",
                |m: &NodeInfo_PeerInfo| { &m.needSyncFromPeer },
                |m: &mut NodeInfo_PeerInfo| { &mut m.needSyncFromPeer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needSyncFromUs",
                |m: &NodeInfo_PeerInfo| { &m.needSyncFromUs },
                |m: &mut NodeInfo_PeerInfo| { &mut m.needSyncFromUs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &NodeInfo_PeerInfo| { &m.host },
                |m: &mut NodeInfo_PeerInfo| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &NodeInfo_PeerInfo| { &m.port },
                |m: &mut NodeInfo_PeerInfo| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nodeId",
                |m: &NodeInfo_PeerInfo| { &m.nodeId },
                |m: &mut NodeInfo_PeerInfo| { &mut m.nodeId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "connectTime",
                |m: &NodeInfo_PeerInfo| { &m.connectTime },
                |m: &mut NodeInfo_PeerInfo| { &mut m.connectTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "avgLatency",
                |m: &NodeInfo_PeerInfo| { &m.avgLatency },
                |m: &mut NodeInfo_PeerInfo| { &mut m.avgLatency },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "syncToFetchSize",
                |m: &NodeInfo_PeerInfo| { &m.syncToFetchSize },
                |m: &mut NodeInfo_PeerInfo| { &mut m.syncToFetchSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "syncToFetchSizePeekNum",
                |m: &NodeInfo_PeerInfo| { &m.syncToFetchSizePeekNum },
                |m: &mut NodeInfo_PeerInfo| { &mut m.syncToFetchSizePeekNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "syncBlockRequestedSize",
                |m: &NodeInfo_PeerInfo| { &m.syncBlockRequestedSize },
                |m: &mut NodeInfo_PeerInfo| { &mut m.syncBlockRequestedSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "unFetchSynNum",
                |m: &NodeInfo_PeerInfo| { &m.unFetchSynNum },
                |m: &mut NodeInfo_PeerInfo| { &mut m.unFetchSynNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "blockInPorcSize",
                |m: &NodeInfo_PeerInfo| { &m.blockInPorcSize },
                |m: &mut NodeInfo_PeerInfo| { &mut m.blockInPorcSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headBlockWeBothHave",
                |m: &NodeInfo_PeerInfo| { &m.headBlockWeBothHave },
                |m: &mut NodeInfo_PeerInfo| { &mut m.headBlockWeBothHave },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isActive",
                |m: &NodeInfo_PeerInfo| { &m.isActive },
                |m: &mut NodeInfo_PeerInfo| { &mut m.isActive },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "score",
                |m: &NodeInfo_PeerInfo| { &m.score },
                |m: &mut NodeInfo_PeerInfo| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "nodeCount",
                |m: &NodeInfo_PeerInfo| { &m.nodeCount },
                |m: &mut NodeInfo_PeerInfo| { &mut m.nodeCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "inFlow",
                |m: &NodeInfo_PeerInfo| { &m.inFlow },
                |m: &mut NodeInfo_PeerInfo| { &mut m.inFlow },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "disconnectTimes",
                |m: &NodeInfo_PeerInfo| { &m.disconnectTimes },
                |m: &mut NodeInfo_PeerInfo| { &mut m.disconnectTimes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localDisconnectReason",
                |m: &NodeInfo_PeerInfo| { &m.localDisconnectReason },
                |m: &mut NodeInfo_PeerInfo| { &mut m.localDisconnectReason },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remoteDisconnectReason",
                |m: &NodeInfo_PeerInfo| { &m.remoteDisconnectReason },
                |m: &mut NodeInfo_PeerInfo| { &mut m.remoteDisconnectReason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInfo_PeerInfo>(
                "NodeInfo.PeerInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInfo_PeerInfo {
        static instance: ::protobuf::rt::LazyV2<NodeInfo_PeerInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInfo_PeerInfo::new)
    }
}

impl ::protobuf::Clear for NodeInfo_PeerInfo {
    fn clear(&mut self) {
        self.lastSyncBlock.clear();
        self.remainNum = 0;
        self.lastBlockUpdateTime = 0;
        self.syncFlag = false;
        self.headBlockTimeWeBothHave = 0;
        self.needSyncFromPeer = false;
        self.needSyncFromUs = false;
        self.host.clear();
        self.port = 0;
        self.nodeId.clear();
        self.connectTime = 0;
        self.avgLatency = 0.;
        self.syncToFetchSize = 0;
        self.syncToFetchSizePeekNum = 0;
        self.syncBlockRequestedSize = 0;
        self.unFetchSynNum = 0;
        self.blockInPorcSize = 0;
        self.headBlockWeBothHave.clear();
        self.isActive = false;
        self.score = 0;
        self.nodeCount = 0;
        self.inFlow = 0;
        self.disconnectTimes = 0;
        self.localDisconnectReason.clear();
        self.remoteDisconnectReason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_PeerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_PeerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NodeInfo_ConfigNodeInfo {
    // message fields
    pub codeVersion: ::std::string::String,
    pub p2pVersion: ::std::string::String,
    pub listenPort: i32,
    pub discoverEnable: bool,
    pub activeNodeSize: i32,
    pub passiveNodeSize: i32,
    pub sendNodeSize: i32,
    pub maxConnectCount: i32,
    pub sameIpMaxConnectCount: i32,
    pub backupListenPort: i32,
    pub backupMemberSize: i32,
    pub backupPriority: i32,
    pub dbVersion: i32,
    pub minParticipationRate: i32,
    pub supportConstant: bool,
    pub minTimeRatio: f64,
    pub maxTimeRatio: f64,
    pub allowCreationOfContracts: i64,
    pub allowAdaptiveEnergy: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_ConfigNodeInfo {
    fn default() -> &'a NodeInfo_ConfigNodeInfo {
        <NodeInfo_ConfigNodeInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_ConfigNodeInfo {
    pub fn new() -> NodeInfo_ConfigNodeInfo {
        ::std::default::Default::default()
    }

    // string codeVersion = 1;


    pub fn get_codeVersion(&self) -> &str {
        &self.codeVersion
    }
    pub fn clear_codeVersion(&mut self) {
        self.codeVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_codeVersion(&mut self, v: ::std::string::String) {
        self.codeVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codeVersion(&mut self) -> &mut ::std::string::String {
        &mut self.codeVersion
    }

    // Take field
    pub fn take_codeVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.codeVersion, ::std::string::String::new())
    }

    // string p2pVersion = 2;


    pub fn get_p2pVersion(&self) -> &str {
        &self.p2pVersion
    }
    pub fn clear_p2pVersion(&mut self) {
        self.p2pVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_p2pVersion(&mut self, v: ::std::string::String) {
        self.p2pVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_p2pVersion(&mut self) -> &mut ::std::string::String {
        &mut self.p2pVersion
    }

    // Take field
    pub fn take_p2pVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.p2pVersion, ::std::string::String::new())
    }

    // int32 listenPort = 3;


    pub fn get_listenPort(&self) -> i32 {
        self.listenPort
    }
    pub fn clear_listenPort(&mut self) {
        self.listenPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_listenPort(&mut self, v: i32) {
        self.listenPort = v;
    }

    // bool discoverEnable = 4;


    pub fn get_discoverEnable(&self) -> bool {
        self.discoverEnable
    }
    pub fn clear_discoverEnable(&mut self) {
        self.discoverEnable = false;
    }

    // Param is passed by value, moved
    pub fn set_discoverEnable(&mut self, v: bool) {
        self.discoverEnable = v;
    }

    // int32 activeNodeSize = 5;


    pub fn get_activeNodeSize(&self) -> i32 {
        self.activeNodeSize
    }
    pub fn clear_activeNodeSize(&mut self) {
        self.activeNodeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_activeNodeSize(&mut self, v: i32) {
        self.activeNodeSize = v;
    }

    // int32 passiveNodeSize = 6;


    pub fn get_passiveNodeSize(&self) -> i32 {
        self.passiveNodeSize
    }
    pub fn clear_passiveNodeSize(&mut self) {
        self.passiveNodeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_passiveNodeSize(&mut self, v: i32) {
        self.passiveNodeSize = v;
    }

    // int32 sendNodeSize = 7;


    pub fn get_sendNodeSize(&self) -> i32 {
        self.sendNodeSize
    }
    pub fn clear_sendNodeSize(&mut self) {
        self.sendNodeSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_sendNodeSize(&mut self, v: i32) {
        self.sendNodeSize = v;
    }

    // int32 maxConnectCount = 8;


    pub fn get_maxConnectCount(&self) -> i32 {
        self.maxConnectCount
    }
    pub fn clear_maxConnectCount(&mut self) {
        self.maxConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxConnectCount(&mut self, v: i32) {
        self.maxConnectCount = v;
    }

    // int32 sameIpMaxConnectCount = 9;


    pub fn get_sameIpMaxConnectCount(&self) -> i32 {
        self.sameIpMaxConnectCount
    }
    pub fn clear_sameIpMaxConnectCount(&mut self) {
        self.sameIpMaxConnectCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_sameIpMaxConnectCount(&mut self, v: i32) {
        self.sameIpMaxConnectCount = v;
    }

    // int32 backupListenPort = 10;


    pub fn get_backupListenPort(&self) -> i32 {
        self.backupListenPort
    }
    pub fn clear_backupListenPort(&mut self) {
        self.backupListenPort = 0;
    }

    // Param is passed by value, moved
    pub fn set_backupListenPort(&mut self, v: i32) {
        self.backupListenPort = v;
    }

    // int32 backupMemberSize = 11;


    pub fn get_backupMemberSize(&self) -> i32 {
        self.backupMemberSize
    }
    pub fn clear_backupMemberSize(&mut self) {
        self.backupMemberSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_backupMemberSize(&mut self, v: i32) {
        self.backupMemberSize = v;
    }

    // int32 backupPriority = 12;


    pub fn get_backupPriority(&self) -> i32 {
        self.backupPriority
    }
    pub fn clear_backupPriority(&mut self) {
        self.backupPriority = 0;
    }

    // Param is passed by value, moved
    pub fn set_backupPriority(&mut self, v: i32) {
        self.backupPriority = v;
    }

    // int32 dbVersion = 13;


    pub fn get_dbVersion(&self) -> i32 {
        self.dbVersion
    }
    pub fn clear_dbVersion(&mut self) {
        self.dbVersion = 0;
    }

    // Param is passed by value, moved
    pub fn set_dbVersion(&mut self, v: i32) {
        self.dbVersion = v;
    }

    // int32 minParticipationRate = 14;


    pub fn get_minParticipationRate(&self) -> i32 {
        self.minParticipationRate
    }
    pub fn clear_minParticipationRate(&mut self) {
        self.minParticipationRate = 0;
    }

    // Param is passed by value, moved
    pub fn set_minParticipationRate(&mut self, v: i32) {
        self.minParticipationRate = v;
    }

    // bool supportConstant = 15;


    pub fn get_supportConstant(&self) -> bool {
        self.supportConstant
    }
    pub fn clear_supportConstant(&mut self) {
        self.supportConstant = false;
    }

    // Param is passed by value, moved
    pub fn set_supportConstant(&mut self, v: bool) {
        self.supportConstant = v;
    }

    // double minTimeRatio = 16;


    pub fn get_minTimeRatio(&self) -> f64 {
        self.minTimeRatio
    }
    pub fn clear_minTimeRatio(&mut self) {
        self.minTimeRatio = 0.;
    }

    // Param is passed by value, moved
    pub fn set_minTimeRatio(&mut self, v: f64) {
        self.minTimeRatio = v;
    }

    // double maxTimeRatio = 17;


    pub fn get_maxTimeRatio(&self) -> f64 {
        self.maxTimeRatio
    }
    pub fn clear_maxTimeRatio(&mut self) {
        self.maxTimeRatio = 0.;
    }

    // Param is passed by value, moved
    pub fn set_maxTimeRatio(&mut self, v: f64) {
        self.maxTimeRatio = v;
    }

    // int64 allowCreationOfContracts = 18;


    pub fn get_allowCreationOfContracts(&self) -> i64 {
        self.allowCreationOfContracts
    }
    pub fn clear_allowCreationOfContracts(&mut self) {
        self.allowCreationOfContracts = 0;
    }

    // Param is passed by value, moved
    pub fn set_allowCreationOfContracts(&mut self, v: i64) {
        self.allowCreationOfContracts = v;
    }

    // int64 allowAdaptiveEnergy = 19;


    pub fn get_allowAdaptiveEnergy(&self) -> i64 {
        self.allowAdaptiveEnergy
    }
    pub fn clear_allowAdaptiveEnergy(&mut self) {
        self.allowAdaptiveEnergy = 0;
    }

    // Param is passed by value, moved
    pub fn set_allowAdaptiveEnergy(&mut self, v: i64) {
        self.allowAdaptiveEnergy = v;
    }
}

impl ::protobuf::Message for NodeInfo_ConfigNodeInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.codeVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.p2pVersion)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.listenPort = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.discoverEnable = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.activeNodeSize = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.passiveNodeSize = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sendNodeSize = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxConnectCount = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sameIpMaxConnectCount = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backupListenPort = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backupMemberSize = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.backupPriority = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dbVersion = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minParticipationRate = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportConstant = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.minTimeRatio = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.maxTimeRatio = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allowCreationOfContracts = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allowAdaptiveEnergy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.codeVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.codeVersion);
        }
        if !self.p2pVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.p2pVersion);
        }
        if self.listenPort != 0 {
            my_size += ::protobuf::rt::value_size(3, self.listenPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.discoverEnable != false {
            my_size += 2;
        }
        if self.activeNodeSize != 0 {
            my_size += ::protobuf::rt::value_size(5, self.activeNodeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.passiveNodeSize != 0 {
            my_size += ::protobuf::rt::value_size(6, self.passiveNodeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sendNodeSize != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sendNodeSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(8, self.maxConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sameIpMaxConnectCount != 0 {
            my_size += ::protobuf::rt::value_size(9, self.sameIpMaxConnectCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.backupListenPort != 0 {
            my_size += ::protobuf::rt::value_size(10, self.backupListenPort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.backupMemberSize != 0 {
            my_size += ::protobuf::rt::value_size(11, self.backupMemberSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.backupPriority != 0 {
            my_size += ::protobuf::rt::value_size(12, self.backupPriority, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dbVersion != 0 {
            my_size += ::protobuf::rt::value_size(13, self.dbVersion, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.minParticipationRate != 0 {
            my_size += ::protobuf::rt::value_size(14, self.minParticipationRate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.supportConstant != false {
            my_size += 2;
        }
        if self.minTimeRatio != 0. {
            my_size += 10;
        }
        if self.maxTimeRatio != 0. {
            my_size += 10;
        }
        if self.allowCreationOfContracts != 0 {
            my_size += ::protobuf::rt::value_size(18, self.allowCreationOfContracts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.allowAdaptiveEnergy != 0 {
            my_size += ::protobuf::rt::value_size(19, self.allowAdaptiveEnergy, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.codeVersion.is_empty() {
            os.write_string(1, &self.codeVersion)?;
        }
        if !self.p2pVersion.is_empty() {
            os.write_string(2, &self.p2pVersion)?;
        }
        if self.listenPort != 0 {
            os.write_int32(3, self.listenPort)?;
        }
        if self.discoverEnable != false {
            os.write_bool(4, self.discoverEnable)?;
        }
        if self.activeNodeSize != 0 {
            os.write_int32(5, self.activeNodeSize)?;
        }
        if self.passiveNodeSize != 0 {
            os.write_int32(6, self.passiveNodeSize)?;
        }
        if self.sendNodeSize != 0 {
            os.write_int32(7, self.sendNodeSize)?;
        }
        if self.maxConnectCount != 0 {
            os.write_int32(8, self.maxConnectCount)?;
        }
        if self.sameIpMaxConnectCount != 0 {
            os.write_int32(9, self.sameIpMaxConnectCount)?;
        }
        if self.backupListenPort != 0 {
            os.write_int32(10, self.backupListenPort)?;
        }
        if self.backupMemberSize != 0 {
            os.write_int32(11, self.backupMemberSize)?;
        }
        if self.backupPriority != 0 {
            os.write_int32(12, self.backupPriority)?;
        }
        if self.dbVersion != 0 {
            os.write_int32(13, self.dbVersion)?;
        }
        if self.minParticipationRate != 0 {
            os.write_int32(14, self.minParticipationRate)?;
        }
        if self.supportConstant != false {
            os.write_bool(15, self.supportConstant)?;
        }
        if self.minTimeRatio != 0. {
            os.write_double(16, self.minTimeRatio)?;
        }
        if self.maxTimeRatio != 0. {
            os.write_double(17, self.maxTimeRatio)?;
        }
        if self.allowCreationOfContracts != 0 {
            os.write_int64(18, self.allowCreationOfContracts)?;
        }
        if self.allowAdaptiveEnergy != 0 {
            os.write_int64(19, self.allowAdaptiveEnergy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_ConfigNodeInfo {
        NodeInfo_ConfigNodeInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "codeVersion",
                |m: &NodeInfo_ConfigNodeInfo| { &m.codeVersion },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.codeVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "p2pVersion",
                |m: &NodeInfo_ConfigNodeInfo| { &m.p2pVersion },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.p2pVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "listenPort",
                |m: &NodeInfo_ConfigNodeInfo| { &m.listenPort },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.listenPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "discoverEnable",
                |m: &NodeInfo_ConfigNodeInfo| { &m.discoverEnable },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.discoverEnable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "activeNodeSize",
                |m: &NodeInfo_ConfigNodeInfo| { &m.activeNodeSize },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.activeNodeSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "passiveNodeSize",
                |m: &NodeInfo_ConfigNodeInfo| { &m.passiveNodeSize },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.passiveNodeSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sendNodeSize",
                |m: &NodeInfo_ConfigNodeInfo| { &m.sendNodeSize },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.sendNodeSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maxConnectCount",
                |m: &NodeInfo_ConfigNodeInfo| { &m.maxConnectCount },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.maxConnectCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sameIpMaxConnectCount",
                |m: &NodeInfo_ConfigNodeInfo| { &m.sameIpMaxConnectCount },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.sameIpMaxConnectCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backupListenPort",
                |m: &NodeInfo_ConfigNodeInfo| { &m.backupListenPort },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.backupListenPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backupMemberSize",
                |m: &NodeInfo_ConfigNodeInfo| { &m.backupMemberSize },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.backupMemberSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "backupPriority",
                |m: &NodeInfo_ConfigNodeInfo| { &m.backupPriority },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.backupPriority },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dbVersion",
                |m: &NodeInfo_ConfigNodeInfo| { &m.dbVersion },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.dbVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "minParticipationRate",
                |m: &NodeInfo_ConfigNodeInfo| { &m.minParticipationRate },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.minParticipationRate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supportConstant",
                |m: &NodeInfo_ConfigNodeInfo| { &m.supportConstant },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.supportConstant },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "minTimeRatio",
                |m: &NodeInfo_ConfigNodeInfo| { &m.minTimeRatio },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.minTimeRatio },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "maxTimeRatio",
                |m: &NodeInfo_ConfigNodeInfo| { &m.maxTimeRatio },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.maxTimeRatio },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "allowCreationOfContracts",
                |m: &NodeInfo_ConfigNodeInfo| { &m.allowCreationOfContracts },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.allowCreationOfContracts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "allowAdaptiveEnergy",
                |m: &NodeInfo_ConfigNodeInfo| { &m.allowAdaptiveEnergy },
                |m: &mut NodeInfo_ConfigNodeInfo| { &mut m.allowAdaptiveEnergy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInfo_ConfigNodeInfo>(
                "NodeInfo.ConfigNodeInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInfo_ConfigNodeInfo {
        static instance: ::protobuf::rt::LazyV2<NodeInfo_ConfigNodeInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInfo_ConfigNodeInfo::new)
    }
}

impl ::protobuf::Clear for NodeInfo_ConfigNodeInfo {
    fn clear(&mut self) {
        self.codeVersion.clear();
        self.p2pVersion.clear();
        self.listenPort = 0;
        self.discoverEnable = false;
        self.activeNodeSize = 0;
        self.passiveNodeSize = 0;
        self.sendNodeSize = 0;
        self.maxConnectCount = 0;
        self.sameIpMaxConnectCount = 0;
        self.backupListenPort = 0;
        self.backupMemberSize = 0;
        self.backupPriority = 0;
        self.dbVersion = 0;
        self.minParticipationRate = 0;
        self.supportConstant = false;
        self.minTimeRatio = 0.;
        self.maxTimeRatio = 0.;
        self.allowCreationOfContracts = 0;
        self.allowAdaptiveEnergy = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_ConfigNodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_ConfigNodeInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NodeInfo_MachineInfo {
    // message fields
    pub threadCount: i32,
    pub deadLockThreadCount: i32,
    pub cpuCount: i32,
    pub totalMemory: i64,
    pub freeMemory: i64,
    pub cpuRate: f64,
    pub javaVersion: ::std::string::String,
    pub osName: ::std::string::String,
    pub jvmTotalMemoery: i64,
    pub jvmFreeMemory: i64,
    pub processCpuRate: f64,
    pub memoryDescInfoList: ::protobuf::RepeatedField<NodeInfo_MachineInfo_MemoryDescInfo>,
    pub deadLockThreadInfoList: ::protobuf::RepeatedField<NodeInfo_MachineInfo_DeadLockThreadInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_MachineInfo {
    fn default() -> &'a NodeInfo_MachineInfo {
        <NodeInfo_MachineInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_MachineInfo {
    pub fn new() -> NodeInfo_MachineInfo {
        ::std::default::Default::default()
    }

    // int32 threadCount = 1;


    pub fn get_threadCount(&self) -> i32 {
        self.threadCount
    }
    pub fn clear_threadCount(&mut self) {
        self.threadCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_threadCount(&mut self, v: i32) {
        self.threadCount = v;
    }

    // int32 deadLockThreadCount = 2;


    pub fn get_deadLockThreadCount(&self) -> i32 {
        self.deadLockThreadCount
    }
    pub fn clear_deadLockThreadCount(&mut self) {
        self.deadLockThreadCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_deadLockThreadCount(&mut self, v: i32) {
        self.deadLockThreadCount = v;
    }

    // int32 cpuCount = 3;


    pub fn get_cpuCount(&self) -> i32 {
        self.cpuCount
    }
    pub fn clear_cpuCount(&mut self) {
        self.cpuCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpuCount(&mut self, v: i32) {
        self.cpuCount = v;
    }

    // int64 totalMemory = 4;


    pub fn get_totalMemory(&self) -> i64 {
        self.totalMemory
    }
    pub fn clear_totalMemory(&mut self) {
        self.totalMemory = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalMemory(&mut self, v: i64) {
        self.totalMemory = v;
    }

    // int64 freeMemory = 5;


    pub fn get_freeMemory(&self) -> i64 {
        self.freeMemory
    }
    pub fn clear_freeMemory(&mut self) {
        self.freeMemory = 0;
    }

    // Param is passed by value, moved
    pub fn set_freeMemory(&mut self, v: i64) {
        self.freeMemory = v;
    }

    // double cpuRate = 6;


    pub fn get_cpuRate(&self) -> f64 {
        self.cpuRate
    }
    pub fn clear_cpuRate(&mut self) {
        self.cpuRate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cpuRate(&mut self, v: f64) {
        self.cpuRate = v;
    }

    // string javaVersion = 7;


    pub fn get_javaVersion(&self) -> &str {
        &self.javaVersion
    }
    pub fn clear_javaVersion(&mut self) {
        self.javaVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_javaVersion(&mut self, v: ::std::string::String) {
        self.javaVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_javaVersion(&mut self) -> &mut ::std::string::String {
        &mut self.javaVersion
    }

    // Take field
    pub fn take_javaVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.javaVersion, ::std::string::String::new())
    }

    // string osName = 8;


    pub fn get_osName(&self) -> &str {
        &self.osName
    }
    pub fn clear_osName(&mut self) {
        self.osName.clear();
    }

    // Param is passed by value, moved
    pub fn set_osName(&mut self, v: ::std::string::String) {
        self.osName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osName(&mut self) -> &mut ::std::string::String {
        &mut self.osName
    }

    // Take field
    pub fn take_osName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.osName, ::std::string::String::new())
    }

    // int64 jvmTotalMemoery = 9;


    pub fn get_jvmTotalMemoery(&self) -> i64 {
        self.jvmTotalMemoery
    }
    pub fn clear_jvmTotalMemoery(&mut self) {
        self.jvmTotalMemoery = 0;
    }

    // Param is passed by value, moved
    pub fn set_jvmTotalMemoery(&mut self, v: i64) {
        self.jvmTotalMemoery = v;
    }

    // int64 jvmFreeMemory = 10;


    pub fn get_jvmFreeMemory(&self) -> i64 {
        self.jvmFreeMemory
    }
    pub fn clear_jvmFreeMemory(&mut self) {
        self.jvmFreeMemory = 0;
    }

    // Param is passed by value, moved
    pub fn set_jvmFreeMemory(&mut self, v: i64) {
        self.jvmFreeMemory = v;
    }

    // double processCpuRate = 11;


    pub fn get_processCpuRate(&self) -> f64 {
        self.processCpuRate
    }
    pub fn clear_processCpuRate(&mut self) {
        self.processCpuRate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_processCpuRate(&mut self, v: f64) {
        self.processCpuRate = v;
    }

    // repeated .protocol.NodeInfo.MachineInfo.MemoryDescInfo memoryDescInfoList = 12;


    pub fn get_memoryDescInfoList(&self) -> &[NodeInfo_MachineInfo_MemoryDescInfo] {
        &self.memoryDescInfoList
    }
    pub fn clear_memoryDescInfoList(&mut self) {
        self.memoryDescInfoList.clear();
    }

    // Param is passed by value, moved
    pub fn set_memoryDescInfoList(&mut self, v: ::protobuf::RepeatedField<NodeInfo_MachineInfo_MemoryDescInfo>) {
        self.memoryDescInfoList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memoryDescInfoList(&mut self) -> &mut ::protobuf::RepeatedField<NodeInfo_MachineInfo_MemoryDescInfo> {
        &mut self.memoryDescInfoList
    }

    // Take field
    pub fn take_memoryDescInfoList(&mut self) -> ::protobuf::RepeatedField<NodeInfo_MachineInfo_MemoryDescInfo> {
        ::std::mem::replace(&mut self.memoryDescInfoList, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.NodeInfo.MachineInfo.DeadLockThreadInfo deadLockThreadInfoList = 13;


    pub fn get_deadLockThreadInfoList(&self) -> &[NodeInfo_MachineInfo_DeadLockThreadInfo] {
        &self.deadLockThreadInfoList
    }
    pub fn clear_deadLockThreadInfoList(&mut self) {
        self.deadLockThreadInfoList.clear();
    }

    // Param is passed by value, moved
    pub fn set_deadLockThreadInfoList(&mut self, v: ::protobuf::RepeatedField<NodeInfo_MachineInfo_DeadLockThreadInfo>) {
        self.deadLockThreadInfoList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deadLockThreadInfoList(&mut self) -> &mut ::protobuf::RepeatedField<NodeInfo_MachineInfo_DeadLockThreadInfo> {
        &mut self.deadLockThreadInfoList
    }

    // Take field
    pub fn take_deadLockThreadInfoList(&mut self) -> ::protobuf::RepeatedField<NodeInfo_MachineInfo_DeadLockThreadInfo> {
        ::std::mem::replace(&mut self.deadLockThreadInfoList, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeInfo_MachineInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.memoryDescInfoList {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deadLockThreadInfoList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threadCount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.deadLockThreadCount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cpuCount = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalMemory = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.freeMemory = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cpuRate = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.javaVersion)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.osName)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.jvmTotalMemoery = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.jvmFreeMemory = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.processCpuRate = tmp;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.memoryDescInfoList)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deadLockThreadInfoList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.threadCount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.threadCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.deadLockThreadCount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.deadLockThreadCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpuCount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cpuCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.totalMemory != 0 {
            my_size += ::protobuf::rt::value_size(4, self.totalMemory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.freeMemory != 0 {
            my_size += ::protobuf::rt::value_size(5, self.freeMemory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cpuRate != 0. {
            my_size += 9;
        }
        if !self.javaVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.javaVersion);
        }
        if !self.osName.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.osName);
        }
        if self.jvmTotalMemoery != 0 {
            my_size += ::protobuf::rt::value_size(9, self.jvmTotalMemoery, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.jvmFreeMemory != 0 {
            my_size += ::protobuf::rt::value_size(10, self.jvmFreeMemory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.processCpuRate != 0. {
            my_size += 9;
        }
        for value in &self.memoryDescInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.deadLockThreadInfoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.threadCount != 0 {
            os.write_int32(1, self.threadCount)?;
        }
        if self.deadLockThreadCount != 0 {
            os.write_int32(2, self.deadLockThreadCount)?;
        }
        if self.cpuCount != 0 {
            os.write_int32(3, self.cpuCount)?;
        }
        if self.totalMemory != 0 {
            os.write_int64(4, self.totalMemory)?;
        }
        if self.freeMemory != 0 {
            os.write_int64(5, self.freeMemory)?;
        }
        if self.cpuRate != 0. {
            os.write_double(6, self.cpuRate)?;
        }
        if !self.javaVersion.is_empty() {
            os.write_string(7, &self.javaVersion)?;
        }
        if !self.osName.is_empty() {
            os.write_string(8, &self.osName)?;
        }
        if self.jvmTotalMemoery != 0 {
            os.write_int64(9, self.jvmTotalMemoery)?;
        }
        if self.jvmFreeMemory != 0 {
            os.write_int64(10, self.jvmFreeMemory)?;
        }
        if self.processCpuRate != 0. {
            os.write_double(11, self.processCpuRate)?;
        }
        for v in &self.memoryDescInfoList {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.deadLockThreadInfoList {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_MachineInfo {
        NodeInfo_MachineInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "threadCount",
                |m: &NodeInfo_MachineInfo| { &m.threadCount },
                |m: &mut NodeInfo_MachineInfo| { &mut m.threadCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "deadLockThreadCount",
                |m: &NodeInfo_MachineInfo| { &m.deadLockThreadCount },
                |m: &mut NodeInfo_MachineInfo| { &mut m.deadLockThreadCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "cpuCount",
                |m: &NodeInfo_MachineInfo| { &m.cpuCount },
                |m: &mut NodeInfo_MachineInfo| { &mut m.cpuCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "totalMemory",
                |m: &NodeInfo_MachineInfo| { &m.totalMemory },
                |m: &mut NodeInfo_MachineInfo| { &mut m.totalMemory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "freeMemory",
                |m: &NodeInfo_MachineInfo| { &m.freeMemory },
                |m: &mut NodeInfo_MachineInfo| { &mut m.freeMemory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "cpuRate",
                |m: &NodeInfo_MachineInfo| { &m.cpuRate },
                |m: &mut NodeInfo_MachineInfo| { &mut m.cpuRate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "javaVersion",
                |m: &NodeInfo_MachineInfo| { &m.javaVersion },
                |m: &mut NodeInfo_MachineInfo| { &mut m.javaVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osName",
                |m: &NodeInfo_MachineInfo| { &m.osName },
                |m: &mut NodeInfo_MachineInfo| { &mut m.osName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "jvmTotalMemoery",
                |m: &NodeInfo_MachineInfo| { &m.jvmTotalMemoery },
                |m: &mut NodeInfo_MachineInfo| { &mut m.jvmTotalMemoery },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "jvmFreeMemory",
                |m: &NodeInfo_MachineInfo| { &m.jvmFreeMemory },
                |m: &mut NodeInfo_MachineInfo| { &mut m.jvmFreeMemory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "processCpuRate",
                |m: &NodeInfo_MachineInfo| { &m.processCpuRate },
                |m: &mut NodeInfo_MachineInfo| { &mut m.processCpuRate },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_MachineInfo_MemoryDescInfo>>(
                "memoryDescInfoList",
                |m: &NodeInfo_MachineInfo| { &m.memoryDescInfoList },
                |m: &mut NodeInfo_MachineInfo| { &mut m.memoryDescInfoList },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeInfo_MachineInfo_DeadLockThreadInfo>>(
                "deadLockThreadInfoList",
                |m: &NodeInfo_MachineInfo| { &m.deadLockThreadInfoList },
                |m: &mut NodeInfo_MachineInfo| { &mut m.deadLockThreadInfoList },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInfo_MachineInfo>(
                "NodeInfo.MachineInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInfo_MachineInfo {
        static instance: ::protobuf::rt::LazyV2<NodeInfo_MachineInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInfo_MachineInfo::new)
    }
}

impl ::protobuf::Clear for NodeInfo_MachineInfo {
    fn clear(&mut self) {
        self.threadCount = 0;
        self.deadLockThreadCount = 0;
        self.cpuCount = 0;
        self.totalMemory = 0;
        self.freeMemory = 0;
        self.cpuRate = 0.;
        self.javaVersion.clear();
        self.osName.clear();
        self.jvmTotalMemoery = 0;
        self.jvmFreeMemory = 0;
        self.processCpuRate = 0.;
        self.memoryDescInfoList.clear();
        self.deadLockThreadInfoList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_MachineInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_MachineInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NodeInfo_MachineInfo_MemoryDescInfo {
    // message fields
    pub name: ::std::string::String,
    pub initSize: i64,
    pub useSize: i64,
    pub maxSize: i64,
    pub useRate: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_MachineInfo_MemoryDescInfo {
    fn default() -> &'a NodeInfo_MachineInfo_MemoryDescInfo {
        <NodeInfo_MachineInfo_MemoryDescInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_MachineInfo_MemoryDescInfo {
    pub fn new() -> NodeInfo_MachineInfo_MemoryDescInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 initSize = 2;


    pub fn get_initSize(&self) -> i64 {
        self.initSize
    }
    pub fn clear_initSize(&mut self) {
        self.initSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_initSize(&mut self, v: i64) {
        self.initSize = v;
    }

    // int64 useSize = 3;


    pub fn get_useSize(&self) -> i64 {
        self.useSize
    }
    pub fn clear_useSize(&mut self) {
        self.useSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_useSize(&mut self, v: i64) {
        self.useSize = v;
    }

    // int64 maxSize = 4;


    pub fn get_maxSize(&self) -> i64 {
        self.maxSize
    }
    pub fn clear_maxSize(&mut self) {
        self.maxSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxSize(&mut self, v: i64) {
        self.maxSize = v;
    }

    // double useRate = 5;


    pub fn get_useRate(&self) -> f64 {
        self.useRate
    }
    pub fn clear_useRate(&mut self) {
        self.useRate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_useRate(&mut self, v: f64) {
        self.useRate = v;
    }
}

impl ::protobuf::Message for NodeInfo_MachineInfo_MemoryDescInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.initSize = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.useSize = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxSize = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.useRate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.initSize != 0 {
            my_size += ::protobuf::rt::value_size(2, self.initSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.useSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.useSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxSize != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maxSize, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.useRate != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.initSize != 0 {
            os.write_int64(2, self.initSize)?;
        }
        if self.useSize != 0 {
            os.write_int64(3, self.useSize)?;
        }
        if self.maxSize != 0 {
            os.write_int64(4, self.maxSize)?;
        }
        if self.useRate != 0. {
            os.write_double(5, self.useRate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_MachineInfo_MemoryDescInfo {
        NodeInfo_MachineInfo_MemoryDescInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.name },
                |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "initSize",
                |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.initSize },
                |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.initSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "useSize",
                |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.useSize },
                |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.useSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "maxSize",
                |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.maxSize },
                |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.maxSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "useRate",
                |m: &NodeInfo_MachineInfo_MemoryDescInfo| { &m.useRate },
                |m: &mut NodeInfo_MachineInfo_MemoryDescInfo| { &mut m.useRate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInfo_MachineInfo_MemoryDescInfo>(
                "NodeInfo.MachineInfo.MemoryDescInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInfo_MachineInfo_MemoryDescInfo {
        static instance: ::protobuf::rt::LazyV2<NodeInfo_MachineInfo_MemoryDescInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInfo_MachineInfo_MemoryDescInfo::new)
    }
}

impl ::protobuf::Clear for NodeInfo_MachineInfo_MemoryDescInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.initSize = 0;
        self.useSize = 0;
        self.maxSize = 0;
        self.useRate = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_MachineInfo_MemoryDescInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_MachineInfo_MemoryDescInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NodeInfo_MachineInfo_DeadLockThreadInfo {
    // message fields
    pub name: ::std::string::String,
    pub lockName: ::std::string::String,
    pub lockOwner: ::std::string::String,
    pub state: ::std::string::String,
    pub blockTime: i64,
    pub waitTime: i64,
    pub stackTrace: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn default() -> &'a NodeInfo_MachineInfo_DeadLockThreadInfo {
        <NodeInfo_MachineInfo_DeadLockThreadInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeInfo_MachineInfo_DeadLockThreadInfo {
    pub fn new() -> NodeInfo_MachineInfo_DeadLockThreadInfo {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string lockName = 2;


    pub fn get_lockName(&self) -> &str {
        &self.lockName
    }
    pub fn clear_lockName(&mut self) {
        self.lockName.clear();
    }

    // Param is passed by value, moved
    pub fn set_lockName(&mut self, v: ::std::string::String) {
        self.lockName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lockName(&mut self) -> &mut ::std::string::String {
        &mut self.lockName
    }

    // Take field
    pub fn take_lockName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lockName, ::std::string::String::new())
    }

    // string lockOwner = 3;


    pub fn get_lockOwner(&self) -> &str {
        &self.lockOwner
    }
    pub fn clear_lockOwner(&mut self) {
        self.lockOwner.clear();
    }

    // Param is passed by value, moved
    pub fn set_lockOwner(&mut self, v: ::std::string::String) {
        self.lockOwner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lockOwner(&mut self) -> &mut ::std::string::String {
        &mut self.lockOwner
    }

    // Take field
    pub fn take_lockOwner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lockOwner, ::std::string::String::new())
    }

    // string state = 4;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // int64 blockTime = 5;


    pub fn get_blockTime(&self) -> i64 {
        self.blockTime
    }
    pub fn clear_blockTime(&mut self) {
        self.blockTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockTime(&mut self, v: i64) {
        self.blockTime = v;
    }

    // int64 waitTime = 6;


    pub fn get_waitTime(&self) -> i64 {
        self.waitTime
    }
    pub fn clear_waitTime(&mut self) {
        self.waitTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_waitTime(&mut self, v: i64) {
        self.waitTime = v;
    }

    // string stackTrace = 7;


    pub fn get_stackTrace(&self) -> &str {
        &self.stackTrace
    }
    pub fn clear_stackTrace(&mut self) {
        self.stackTrace.clear();
    }

    // Param is passed by value, moved
    pub fn set_stackTrace(&mut self, v: ::std::string::String) {
        self.stackTrace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stackTrace(&mut self) -> &mut ::std::string::String {
        &mut self.stackTrace
    }

    // Take field
    pub fn take_stackTrace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stackTrace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lockName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lockOwner)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.blockTime = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.waitTime = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stackTrace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.lockName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.lockName);
        }
        if !self.lockOwner.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.lockOwner);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.state);
        }
        if self.blockTime != 0 {
            my_size += ::protobuf::rt::value_size(5, self.blockTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.waitTime != 0 {
            my_size += ::protobuf::rt::value_size(6, self.waitTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.stackTrace.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.stackTrace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.lockName.is_empty() {
            os.write_string(2, &self.lockName)?;
        }
        if !self.lockOwner.is_empty() {
            os.write_string(3, &self.lockOwner)?;
        }
        if !self.state.is_empty() {
            os.write_string(4, &self.state)?;
        }
        if self.blockTime != 0 {
            os.write_int64(5, self.blockTime)?;
        }
        if self.waitTime != 0 {
            os.write_int64(6, self.waitTime)?;
        }
        if !self.stackTrace.is_empty() {
            os.write_string(7, &self.stackTrace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeInfo_MachineInfo_DeadLockThreadInfo {
        NodeInfo_MachineInfo_DeadLockThreadInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.name },
                |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lockName",
                |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.lockName },
                |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.lockName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lockOwner",
                |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.lockOwner },
                |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.lockOwner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.state },
                |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "blockTime",
                |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.blockTime },
                |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.blockTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "waitTime",
                |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.waitTime },
                |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.waitTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stackTrace",
                |m: &NodeInfo_MachineInfo_DeadLockThreadInfo| { &m.stackTrace },
                |m: &mut NodeInfo_MachineInfo_DeadLockThreadInfo| { &mut m.stackTrace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeInfo_MachineInfo_DeadLockThreadInfo>(
                "NodeInfo.MachineInfo.DeadLockThreadInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeInfo_MachineInfo_DeadLockThreadInfo {
        static instance: ::protobuf::rt::LazyV2<NodeInfo_MachineInfo_DeadLockThreadInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeInfo_MachineInfo_DeadLockThreadInfo::new)
    }
}

impl ::protobuf::Clear for NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.lockName.clear();
        self.lockOwner.clear();
        self.state.clear();
        self.blockTime = 0;
        self.waitTime = 0;
        self.stackTrace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeInfo_MachineInfo_DeadLockThreadInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum AccountType {
    Normal = 0,
    AssetIssue = 1,
    Contract = 2,
}

impl ::protobuf::ProtobufEnum for AccountType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccountType> {
        match value {
            0 => ::std::option::Option::Some(AccountType::Normal),
            1 => ::std::option::Option::Some(AccountType::AssetIssue),
            2 => ::std::option::Option::Some(AccountType::Contract),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AccountType] = &[
            AccountType::Normal,
            AccountType::AssetIssue,
            AccountType::Contract,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AccountType>("AccountType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AccountType {
}

impl ::std::default::Default for AccountType {
    fn default() -> Self {
        AccountType::Normal
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ReasonCode {
    REQUESTED = 0,
    BAD_PROTOCOL = 2,
    TOO_MANY_PEERS = 4,
    DUPLICATE_PEER = 5,
    INCOMPATIBLE_PROTOCOL = 6,
    NULL_IDENTITY = 7,
    PEER_QUITING = 8,
    UNEXPECTED_IDENTITY = 9,
    LOCAL_IDENTITY = 10,
    PING_TIMEOUT = 11,
    USER_REASON = 16,
    RESET = 17,
    SYNC_FAIL = 18,
    FETCH_FAIL = 19,
    BAD_TX = 20,
    BAD_BLOCK = 21,
    FORKED = 22,
    UNLINKABLE = 23,
    INCOMPATIBLE_VERSION = 24,
    INCOMPATIBLE_CHAIN = 25,
    TIME_OUT = 32,
    CONNECT_FAIL = 33,
    TOO_MANY_PEERS_WITH_SAME_IP = 34,
    UNKNOWN = 255,
}

impl ::protobuf::ProtobufEnum for ReasonCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReasonCode> {
        match value {
            0 => ::std::option::Option::Some(ReasonCode::REQUESTED),
            2 => ::std::option::Option::Some(ReasonCode::BAD_PROTOCOL),
            4 => ::std::option::Option::Some(ReasonCode::TOO_MANY_PEERS),
            5 => ::std::option::Option::Some(ReasonCode::DUPLICATE_PEER),
            6 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_PROTOCOL),
            7 => ::std::option::Option::Some(ReasonCode::NULL_IDENTITY),
            8 => ::std::option::Option::Some(ReasonCode::PEER_QUITING),
            9 => ::std::option::Option::Some(ReasonCode::UNEXPECTED_IDENTITY),
            10 => ::std::option::Option::Some(ReasonCode::LOCAL_IDENTITY),
            11 => ::std::option::Option::Some(ReasonCode::PING_TIMEOUT),
            16 => ::std::option::Option::Some(ReasonCode::USER_REASON),
            17 => ::std::option::Option::Some(ReasonCode::RESET),
            18 => ::std::option::Option::Some(ReasonCode::SYNC_FAIL),
            19 => ::std::option::Option::Some(ReasonCode::FETCH_FAIL),
            20 => ::std::option::Option::Some(ReasonCode::BAD_TX),
            21 => ::std::option::Option::Some(ReasonCode::BAD_BLOCK),
            22 => ::std::option::Option::Some(ReasonCode::FORKED),
            23 => ::std::option::Option::Some(ReasonCode::UNLINKABLE),
            24 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_VERSION),
            25 => ::std::option::Option::Some(ReasonCode::INCOMPATIBLE_CHAIN),
            32 => ::std::option::Option::Some(ReasonCode::TIME_OUT),
            33 => ::std::option::Option::Some(ReasonCode::CONNECT_FAIL),
            34 => ::std::option::Option::Some(ReasonCode::TOO_MANY_PEERS_WITH_SAME_IP),
            255 => ::std::option::Option::Some(ReasonCode::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReasonCode] = &[
            ReasonCode::REQUESTED,
            ReasonCode::BAD_PROTOCOL,
            ReasonCode::TOO_MANY_PEERS,
            ReasonCode::DUPLICATE_PEER,
            ReasonCode::INCOMPATIBLE_PROTOCOL,
            ReasonCode::NULL_IDENTITY,
            ReasonCode::PEER_QUITING,
            ReasonCode::UNEXPECTED_IDENTITY,
            ReasonCode::LOCAL_IDENTITY,
            ReasonCode::PING_TIMEOUT,
            ReasonCode::USER_REASON,
            ReasonCode::RESET,
            ReasonCode::SYNC_FAIL,
            ReasonCode::FETCH_FAIL,
            ReasonCode::BAD_TX,
            ReasonCode::BAD_BLOCK,
            ReasonCode::FORKED,
            ReasonCode::UNLINKABLE,
            ReasonCode::INCOMPATIBLE_VERSION,
            ReasonCode::INCOMPATIBLE_CHAIN,
            ReasonCode::TIME_OUT,
            ReasonCode::CONNECT_FAIL,
            ReasonCode::TOO_MANY_PEERS_WITH_SAME_IP,
            ReasonCode::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReasonCode>("ReasonCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ReasonCode {
}

impl ::std::default::Default for ReasonCode {
    fn default() -> Self {
        ReasonCode::REQUESTED
    }
}

impl ::protobuf::reflect::ProtobufValue for ReasonCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fcore/Tron.proto\x12\x08protocol\x1a\x19google/protobuf/any.proto\
    \x1a\x13core/Discover.proto\"9\n\tAccountId\x12\x12\n\x04name\x18\x01\
    \x20\x01(\x0cR\x04name\x12\x18\n\x07address\x18\x02\x20\x01(\x0cR\x07add\
    ress\"H\n\x04Vote\x12!\n\x0cvote_address\x18\x01\x20\x01(\x0cR\x0bvoteAd\
    dress\x12\x1d\n\nvote_count\x18\x02\x20\x01(\x03R\tvoteCount\"\xb4\x03\n\
    \x08Proposal\x12\x1f\n\x0bproposal_id\x18\x01\x20\x01(\x03R\nproposalId\
    \x12)\n\x10proposer_address\x18\x02\x20\x01(\x0cR\x0fproposerAddress\x12\
    B\n\nparameters\x18\x03\x20\x03(\x0b2\".protocol.Proposal.ParametersEntr\
    yR\nparameters\x12'\n\x0fexpiration_time\x18\x04\x20\x01(\x03R\x0eexpira\
    tionTime\x12\x1f\n\x0bcreate_time\x18\x05\x20\x01(\x03R\ncreateTime\x12\
    \x1c\n\tapprovals\x18\x06\x20\x03(\x0cR\tapprovals\x12.\n\x05state\x18\
    \x07\x20\x01(\x0e2\x18.protocol.Proposal.StateR\x05state\x1a=\n\x0fParam\
    etersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\x03R\x05value:\x028\x01\"A\n\x05State\x12\x0b\n\x07\
    PENDING\x10\0\x12\x0f\n\x0bDISAPPROVED\x10\x01\x12\x0c\n\x08APPROVED\x10\
    \x02\x12\x0c\n\x08CANCELED\x10\x03\"\xa5\x02\n\x08Exchange\x12\x1f\n\x0b\
    exchange_id\x18\x01\x20\x01(\x03R\nexchangeId\x12'\n\x0fcreator_address\
    \x18\x02\x20\x01(\x0cR\x0ecreatorAddress\x12\x1f\n\x0bcreate_time\x18\
    \x03\x20\x01(\x03R\ncreateTime\x12$\n\x0efirst_token_id\x18\x06\x20\x01(\
    \x0cR\x0cfirstTokenId\x12.\n\x13first_token_balance\x18\x07\x20\x01(\x03\
    R\x11firstTokenBalance\x12&\n\x0fsecond_token_id\x18\x08\x20\x01(\x0cR\r\
    secondTokenId\x120\n\x14second_token_balance\x18\t\x20\x01(\x03R\x12seco\
    ndTokenBalance\"\x9d\x01\n\x0fChainParameters\x12P\n\x0echainParameter\
    \x18\x01\x20\x03(\x0b2(.protocol.ChainParameters.ChainParameterR\x0echai\
    nParameter\x1a8\n\x0eChainParameter\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value\"\xb0\x16\n\
    \x07Account\x12!\n\x0caccount_name\x18\x01\x20\x01(\x0cR\x0baccountName\
    \x12)\n\x04type\x18\x02\x20\x01(\x0e2\x15.protocol.AccountTypeR\x04type\
    \x12\x18\n\x07address\x18\x03\x20\x01(\x0cR\x07address\x12\x18\n\x07bala\
    nce\x18\x04\x20\x01(\x03R\x07balance\x12$\n\x05votes\x18\x05\x20\x03(\
    \x0b2\x0e.protocol.VoteR\x05votes\x122\n\x05asset\x18\x06\x20\x03(\x0b2\
    \x1c.protocol.Account.AssetEntryR\x05asset\x128\n\x07assetV2\x188\x20\
    \x03(\x0b2\x1e.protocol.Account.AssetV2EntryR\x07assetV2\x120\n\x06froze\
    n\x18\x07\x20\x03(\x0b2\x18.protocol.Account.FrozenR\x06frozen\x12\x1b\n\
    \tnet_usage\x18\x08\x20\x01(\x03R\x08netUsage\x12c\n/acquired_delegated_\
    frozen_balance_for_bandwidth\x18)\x20\x01(\x03R*acquiredDelegatedFrozenB\
    alanceForBandwidth\x12R\n&delegated_frozen_balance_for_bandwidth\x18*\
    \x20\x01(\x03R\"delegatedFrozenBalanceForBandwidth\x12\x1f\n\x0bcreate_t\
    ime\x18\t\x20\x01(\x03R\ncreateTime\x120\n\x14latest_opration_time\x18\n\
    \x20\x01(\x03R\x12latestOprationTime\x12\x1c\n\tallowance\x18\x0b\x20\
    \x01(\x03R\tallowance\x120\n\x14latest_withdraw_time\x18\x0c\x20\x01(\
    \x03R\x12latestWithdrawTime\x12\x12\n\x04code\x18\r\x20\x01(\x0cR\x04cod\
    e\x12\x1d\n\nis_witness\x18\x0e\x20\x01(\x08R\tisWitness\x12!\n\x0cis_co\
    mmittee\x18\x0f\x20\x01(\x08R\x0bisCommittee\x12=\n\rfrozen_supply\x18\
    \x10\x20\x03(\x0b2\x18.protocol.Account.FrozenR\x0cfrozenSupply\x12*\n\
    \x11asset_issued_name\x18\x11\x20\x01(\x0cR\x0fassetIssuedName\x12&\n\
    \x0fasset_issued_ID\x189\x20\x01(\x0cR\rassetIssuedID\x12n\n\x1blatest_a\
    sset_operation_time\x18\x12\x20\x03(\x0b2/.protocol.Account.LatestAssetO\
    perationTimeEntryR\x18latestAssetOperationTime\x12t\n\x1dlatest_asset_op\
    eration_timeV2\x18:\x20\x03(\x0b21.protocol.Account.LatestAssetOperation\
    TimeV2EntryR\x1alatestAssetOperationTimeV2\x12$\n\x0efree_net_usage\x18\
    \x13\x20\x01(\x03R\x0cfreeNetUsage\x12Y\n\x14free_asset_net_usage\x18\
    \x14\x20\x03(\x0b2(.protocol.Account.FreeAssetNetUsageEntryR\x11freeAsse\
    tNetUsage\x12_\n\x16free_asset_net_usageV2\x18;\x20\x03(\x0b2*.protocol.\
    Account.FreeAssetNetUsageV2EntryR\x13freeAssetNetUsageV2\x12.\n\x13lates\
    t_consume_time\x18\x15\x20\x01(\x03R\x11latestConsumeTime\x127\n\x18late\
    st_consume_free_time\x18\x16\x20\x01(\x03R\x15latestConsumeFreeTime\x12\
    \x1d\n\naccount_id\x18\x17\x20\x01(\x0cR\taccountId\x12L\n\x10account_re\
    source\x18\x1a\x20\x01(\x0b2!.protocol.Account.AccountResourceR\x0faccou\
    ntResource\x12\x1a\n\x08codeHash\x18\x1e\x20\x01(\x0cR\x08codeHash\x12?\
    \n\x10owner_permission\x18\x1f\x20\x01(\x0b2\x14.protocol.PermissionR\
    \x0fownerPermission\x12C\n\x12witness_permission\x18\x20\x20\x01(\x0b2\
    \x14.protocol.PermissionR\x11witnessPermission\x12A\n\x11active_permissi\
    on\x18!\x20\x03(\x0b2\x14.protocol.PermissionR\x10activePermission\x1aP\
    \n\x06Frozen\x12%\n\x0efrozen_balance\x18\x01\x20\x01(\x03R\rfrozenBalan\
    ce\x12\x1f\n\x0bexpire_time\x18\x02\x20\x01(\x03R\nexpireTime\x1a8\n\nAs\
    setEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x03R\x05value:\x028\x01\x1a:\n\x0cAssetV2Entry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aK\n\x1dLatestAssetOperationTimeEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aM\n\x1fLatestAssetOperationTimeV2Entry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\x03R\x05value:\x028\x01\x1aD\n\x16FreeAssetNetUsageEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1aF\n\x18FreeAssetNetUsageV2Entry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x03R\x05value:\x028\x01\x1a\x85\x04\n\x0fAccountResource\x12!\n\x0cener\
    gy_usage\x18\x01\x20\x01(\x03R\x0benergyUsage\x12S\n\x19frozen_balance_f\
    or_energy\x18\x02\x20\x01(\x0b2\x18.protocol.Account.FrozenR\x16frozenBa\
    lanceForEnergy\x12B\n\x1elatest_consume_time_for_energy\x18\x03\x20\x01(\
    \x03R\x1alatestConsumeTimeForEnergy\x12]\n,acquired_delegated_frozen_bal\
    ance_for_energy\x18\x04\x20\x01(\x03R'acquiredDelegatedFrozenBalanceForE\
    nergy\x12L\n#delegated_frozen_balance_for_energy\x18\x05\x20\x01(\x03R\
    \x1fdelegatedFrozenBalanceForEnergy\x12#\n\rstorage_limit\x18\x06\x20\
    \x01(\x03R\x0cstorageLimit\x12#\n\rstorage_usage\x18\x07\x20\x01(\x03R\
    \x0cstorageUsage\x12?\n\x1clatest_exchange_storage_time\x18\x08\x20\x01(\
    \x03R\x19latestExchangeStorageTime\"7\n\x03Key\x12\x18\n\x07address\x18\
    \x01\x20\x01(\x0cR\x07address\x12\x16\n\x06weight\x18\x02\x20\x01(\x03R\
    \x06weight\"\xa3\x02\n\x11DelegatedResource\x12\x12\n\x04from\x18\x01\
    \x20\x01(\x0cR\x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\x0cR\x02to\x12?\
    \n\x1cfrozen_balance_for_bandwidth\x18\x03\x20\x01(\x03R\x19frozenBalanc\
    eForBandwidth\x129\n\x19frozen_balance_for_energy\x18\x04\x20\x01(\x03R\
    \x16frozenBalanceForEnergy\x129\n\x19expire_time_for_bandwidth\x18\x05\
    \x20\x01(\x03R\x16expireTimeForBandwidth\x123\n\x16expire_time_for_energ\
    y\x18\x06\x20\x01(\x03R\x13expireTimeForEnergy\"c\n\tauthority\x12-\n\
    \x07account\x18\x01\x20\x01(\x0b2\x13.protocol.AccountIdR\x07account\x12\
    '\n\x0fpermission_name\x18\x02\x20\x01(\x0cR\x0epermissionName\"\xb2\x02\
    \n\nPermission\x127\n\x04type\x18\x01\x20\x01(\x0e2#.protocol.Permission\
    .PermissionTypeR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x05R\x02id\x12\
    '\n\x0fpermission_name\x18\x03\x20\x01(\tR\x0epermissionName\x12\x1c\n\t\
    threshold\x18\x04\x20\x01(\x03R\tthreshold\x12\x1b\n\tparent_id\x18\x05\
    \x20\x01(\x05R\x08parentId\x12\x1e\n\noperations\x18\x06\x20\x01(\x0cR\n\
    operations\x12!\n\x04keys\x18\x07\x20\x03(\x0b2\r.protocol.KeyR\x04keys\
    \"4\n\x0ePermissionType\x12\t\n\x05Owner\x10\0\x12\x0b\n\x07Witness\x10\
    \x01\x12\n\n\x06Active\x10\x02\"\x99\x02\n\x07Witness\x12\x18\n\x07addre\
    ss\x18\x01\x20\x01(\x0cR\x07address\x12\x1c\n\tvoteCount\x18\x02\x20\x01\
    (\x03R\tvoteCount\x12\x16\n\x06pubKey\x18\x03\x20\x01(\x0cR\x06pubKey\
    \x12\x10\n\x03url\x18\x04\x20\x01(\tR\x03url\x12$\n\rtotalProduced\x18\
    \x05\x20\x01(\x03R\rtotalProduced\x12\x20\n\x0btotalMissed\x18\x06\x20\
    \x01(\x03R\x0btotalMissed\x12&\n\x0elatestBlockNum\x18\x07\x20\x01(\x03R\
    \x0elatestBlockNum\x12$\n\rlatestSlotNum\x18\x08\x20\x01(\x03R\rlatestSl\
    otNum\x12\x16\n\x06isJobs\x18\t\x20\x01(\x08R\x06isJobs\"{\n\x05Votes\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12+\n\told_votes\
    \x18\x02\x20\x03(\x0b2\x0e.protocol.VoteR\x08oldVotes\x12+\n\tnew_votes\
    \x18\x03\x20\x03(\x0b2\x0e.protocol.VoteR\x08newVotes\"@\n\x08TXOutput\
    \x12\x14\n\x05value\x18\x01\x20\x01(\x03R\x05value\x12\x1e\n\npubKeyHash\
    \x18\x02\x20\x01(\x0cR\npubKeyHash\"\xa0\x01\n\x07TXInput\x120\n\x08raw_\
    data\x18\x01\x20\x01(\x0b2\x15.protocol.TXInput.rawR\x07rawData\x12\x1c\
    \n\tsignature\x18\x04\x20\x01(\x0cR\tsignature\x1aE\n\x03raw\x12\x12\n\
    \x04txID\x18\x01\x20\x01(\x0cR\x04txID\x12\x12\n\x04vout\x18\x02\x20\x01\
    (\x03R\x04vout\x12\x16\n\x06pubKey\x18\x03\x20\x01(\x0cR\x06pubKey\"9\n\
    \tTXOutputs\x12,\n\x07outputs\x18\x01\x20\x03(\x0b2\x12.protocol.TXOutpu\
    tR\x07outputs\"\xac\x02\n\x0fResourceReceipt\x12!\n\x0cenergy_usage\x18\
    \x01\x20\x01(\x03R\x0benergyUsage\x12\x1d\n\nenergy_fee\x18\x02\x20\x01(\
    \x03R\tenergyFee\x12.\n\x13origin_energy_usage\x18\x03\x20\x01(\x03R\x11\
    originEnergyUsage\x12,\n\x12energy_usage_total\x18\x04\x20\x01(\x03R\x10\
    energyUsageTotal\x12\x1b\n\tnet_usage\x18\x05\x20\x01(\x03R\x08netUsage\
    \x12\x17\n\x07net_fee\x18\x06\x20\x01(\x03R\x06netFee\x12C\n\x06result\
    \x18\x07\x20\x01(\x0e2+.protocol.Transaction.Result.contractResultR\x06r\
    esult\"\x80\x14\n\x0bTransaction\x124\n\x08raw_data\x18\x01\x20\x01(\x0b\
    2\x19.protocol.Transaction.rawR\x07rawData\x12\x1c\n\tsignature\x18\x02\
    \x20\x03(\x0cR\tsignature\x12.\n\x03ret\x18\x05\x20\x03(\x0b2\x1c.protoc\
    ol.Transaction.ResultR\x03ret\x1a\xf4\x08\n\x08Contract\x12?\n\x04type\
    \x18\x01\x20\x01(\x0e2+.protocol.Transaction.Contract.ContractTypeR\x04t\
    ype\x122\n\tparameter\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\tpa\
    rameter\x12\x1a\n\x08provider\x18\x03\x20\x01(\x0cR\x08provider\x12\"\n\
    \x0cContractName\x18\x04\x20\x01(\x0cR\x0cContractName\x12#\n\rPermissio\
    n_id\x18\x05\x20\x01(\x05R\x0cPermissionId\"\x8d\x07\n\x0cContractType\
    \x12\x19\n\x15AccountCreateContract\x10\0\x12\x14\n\x10TransferContract\
    \x10\x01\x12\x19\n\x15TransferAssetContract\x10\x02\x12\x15\n\x11VoteAss\
    etContract\x10\x03\x12\x17\n\x13VoteWitnessContract\x10\x04\x12\x19\n\
    \x15WitnessCreateContract\x10\x05\x12\x16\n\x12AssetIssueContract\x10\
    \x06\x12\x19\n\x15WitnessUpdateContract\x10\x08\x12!\n\x1dParticipateAss\
    etIssueContract\x10\t\x12\x19\n\x15AccountUpdateContract\x10\n\x12\x19\n\
    \x15FreezeBalanceContract\x10\x0b\x12\x1b\n\x17UnfreezeBalanceContract\
    \x10\x0c\x12\x1b\n\x17WithdrawBalanceContract\x10\r\x12\x19\n\x15Unfreez\
    eAssetContract\x10\x0e\x12\x17\n\x13UpdateAssetContract\x10\x0f\x12\x1a\
    \n\x16ProposalCreateContract\x10\x10\x12\x1b\n\x17ProposalApproveContrac\
    t\x10\x11\x12\x1a\n\x16ProposalDeleteContract\x10\x12\x12\x18\n\x14SetAc\
    countIdContract\x10\x13\x12\x12\n\x0eCustomContract\x10\x14\x12\x17\n\
    \x13CreateSmartContract\x10\x1e\x12\x18\n\x14TriggerSmartContract\x10\
    \x1f\x12\x0f\n\x0bGetContract\x10\x20\x12\x19\n\x15UpdateSettingContract\
    \x10!\x12\x1a\n\x16ExchangeCreateContract\x10)\x12\x1a\n\x16ExchangeInje\
    ctContract\x10*\x12\x1c\n\x18ExchangeWithdrawContract\x10+\x12\x1f\n\x1b\
    ExchangeTransactionContract\x10,\x12\x1d\n\x19UpdateEnergyLimitContract\
    \x10-\x12#\n\x1fAccountPermissionUpdateContract\x10.\x12\x14\n\x10ClearA\
    BIContract\x100\x12\x1b\n\x17UpdateBrokerageContract\x101\x12\x1c\n\x18S\
    hieldedTransferContract\x103\x1a\x8b\x07\n\x06Result\x12\x10\n\x03fee\
    \x18\x01\x20\x01(\x03R\x03fee\x123\n\x03ret\x18\x02\x20\x01(\x0e2!.proto\
    col.Transaction.Result.codeR\x03ret\x12M\n\x0bcontractRet\x18\x03\x20\
    \x01(\x0e2+.protocol.Transaction.Result.contractResultR\x0bcontractRet\
    \x12\"\n\x0cassetIssueID\x18\x0e\x20\x01(\tR\x0cassetIssueID\x12'\n\x0fw\
    ithdraw_amount\x18\x0f\x20\x01(\x03R\x0ewithdrawAmount\x12'\n\x0funfreez\
    e_amount\x18\x10\x20\x01(\x03R\x0eunfreezeAmount\x128\n\x18exchange_rece\
    ived_amount\x18\x12\x20\x01(\x03R\x16exchangeReceivedAmount\x12C\n\x1eex\
    change_inject_another_amount\x18\x13\x20\x01(\x03R\x1bexchangeInjectAnot\
    herAmount\x12G\n\x20exchange_withdraw_another_amount\x18\x14\x20\x01(\
    \x03R\x1dexchangeWithdrawAnotherAmount\x12\x1f\n\x0bexchange_id\x18\x15\
    \x20\x01(\x03R\nexchangeId\x128\n\x18shielded_transaction_fee\x18\x16\
    \x20\x01(\x03R\x16shieldedTransactionFee\"\x1e\n\x04code\x12\n\n\x06SUCE\
    SS\x10\0\x12\n\n\x06FAILED\x10\x01\"\xb1\x02\n\x0econtractResult\x12\x0b\
    \n\x07DEFAULT\x10\0\x12\x0b\n\x07SUCCESS\x10\x01\x12\n\n\x06REVERT\x10\
    \x02\x12\x18\n\x14BAD_JUMP_DESTINATION\x10\x03\x12\x11\n\rOUT_OF_MEMORY\
    \x10\x04\x12\x18\n\x14PRECOMPILED_CONTRACT\x10\x05\x12\x13\n\x0fSTACK_TO\
    O_SMALL\x10\x06\x12\x13\n\x0fSTACK_TOO_LARGE\x10\x07\x12\x15\n\x11ILLEGA\
    L_OPERATION\x10\x08\x12\x12\n\x0eSTACK_OVERFLOW\x10\t\x12\x11\n\rOUT_OF_\
    ENERGY\x10\n\x12\x0f\n\x0bOUT_OF_TIME\x10\x0b\x12\x17\n\x13JVM_STACK_OVE\
    R_FLOW\x10\x0c\x12\x0b\n\x07UNKNOWN\x10\r\x12\x13\n\x0fTRANSFER_FAILED\
    \x10\x0e\x1a\xe7\x02\n\x03raw\x12&\n\x0fref_block_bytes\x18\x01\x20\x01(\
    \x0cR\rrefBlockBytes\x12\"\n\rref_block_num\x18\x03\x20\x01(\x03R\x0bref\
    BlockNum\x12$\n\x0eref_block_hash\x18\x04\x20\x01(\x0cR\x0crefBlockHash\
    \x12\x1e\n\nexpiration\x18\x08\x20\x01(\x03R\nexpiration\x12)\n\x05auths\
    \x18\t\x20\x03(\x0b2\x13.protocol.authorityR\x05auths\x12\x12\n\x04data\
    \x18\n\x20\x01(\x0cR\x04data\x12:\n\x08contract\x18\x0b\x20\x03(\x0b2\
    \x1e.protocol.Transaction.ContractR\x08contract\x12\x18\n\x07scripts\x18\
    \x0c\x20\x01(\x0cR\x07scripts\x12\x1c\n\ttimestamp\x18\x0e\x20\x01(\x03R\
    \ttimestamp\x12\x1b\n\tfee_limit\x18\x12\x20\x01(\x03R\x08feeLimit\"\xe8\
    \x07\n\x0fTransactionInfo\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\
    \x12\x10\n\x03fee\x18\x02\x20\x01(\x03R\x03fee\x12\x20\n\x0bblockNumber\
    \x18\x03\x20\x01(\x03R\x0bblockNumber\x12&\n\x0eblockTimeStamp\x18\x04\
    \x20\x01(\x03R\x0eblockTimeStamp\x12&\n\x0econtractResult\x18\x05\x20\
    \x03(\x0cR\x0econtractResult\x12)\n\x10contract_address\x18\x06\x20\x01(\
    \x0cR\x0fcontractAddress\x123\n\x07receipt\x18\x07\x20\x01(\x0b2\x19.pro\
    tocol.ResourceReceiptR\x07receipt\x12/\n\x03log\x18\x08\x20\x03(\x0b2\
    \x1d.protocol.TransactionInfo.LogR\x03log\x126\n\x06result\x18\t\x20\x01\
    (\x0e2\x1e.protocol.TransactionInfo.codeR\x06result\x12\x1e\n\nresMessag\
    e\x18\n\x20\x01(\x0cR\nresMessage\x12\"\n\x0cassetIssueID\x18\x0e\x20\
    \x01(\tR\x0cassetIssueID\x12'\n\x0fwithdraw_amount\x18\x0f\x20\x01(\x03R\
    \x0ewithdrawAmount\x12'\n\x0funfreeze_amount\x18\x10\x20\x01(\x03R\x0eun\
    freezeAmount\x12R\n\x15internal_transactions\x18\x11\x20\x03(\x0b2\x1d.p\
    rotocol.InternalTransactionR\x14internalTransactions\x128\n\x18exchange_\
    received_amount\x18\x12\x20\x01(\x03R\x16exchangeReceivedAmount\x12C\n\
    \x1eexchange_inject_another_amount\x18\x13\x20\x01(\x03R\x1bexchangeInje\
    ctAnotherAmount\x12G\n\x20exchange_withdraw_another_amount\x18\x14\x20\
    \x01(\x03R\x1dexchangeWithdrawAnotherAmount\x12\x1f\n\x0bexchange_id\x18\
    \x15\x20\x01(\x03R\nexchangeId\x128\n\x18shielded_transaction_fee\x18\
    \x16\x20\x01(\x03R\x16shieldedTransactionFee\x1aK\n\x03Log\x12\x18\n\x07\
    address\x18\x01\x20\x01(\x0cR\x07address\x12\x16\n\x06topics\x18\x02\x20\
    \x03(\x0cR\x06topics\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\
    \x1e\n\x04code\x12\n\n\x06SUCESS\x10\0\x12\n\n\x06FAILED\x10\x01\"\x9f\
    \x01\n\x0eTransactionRet\x12\x20\n\x0bblockNumber\x18\x01\x20\x01(\x03R\
    \x0bblockNumber\x12&\n\x0eblockTimeStamp\x18\x02\x20\x01(\x03R\x0eblockT\
    imeStamp\x12C\n\x0ftransactioninfo\x18\x03\x20\x03(\x0b2\x19.protocol.Tr\
    ansactionInfoR\x0ftransactioninfo\"I\n\x0cTransactions\x129\n\x0ctransac\
    tions\x18\x01\x20\x03(\x0b2\x15.protocol.TransactionR\x0ctransactions\"j\
    \n\x0fTransactionSign\x127\n\x0btransaction\x18\x01\x20\x01(\x0b2\x15.pr\
    otocol.TransactionR\x0btransaction\x12\x1e\n\nprivateKey\x18\x02\x20\x01\
    (\x0cR\nprivateKey\"\xfc\x02\n\x0bBlockHeader\x124\n\x08raw_data\x18\x01\
    \x20\x01(\x0b2\x19.protocol.BlockHeader.rawR\x07rawData\x12+\n\x11witnes\
    s_signature\x18\x02\x20\x01(\x0cR\x10witnessSignature\x1a\x89\x02\n\x03r\
    aw\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\ttimestamp\x12\x1e\n\ntxTr\
    ieRoot\x18\x02\x20\x01(\x0cR\ntxTrieRoot\x12\x1e\n\nparentHash\x18\x03\
    \x20\x01(\x0cR\nparentHash\x12\x16\n\x06number\x18\x07\x20\x01(\x03R\x06\
    number\x12\x1d\n\nwitness_id\x18\x08\x20\x01(\x03R\twitnessId\x12'\n\x0f\
    witness_address\x18\t\x20\x01(\x0cR\x0ewitnessAddress\x12\x18\n\x07versi\
    on\x18\n\x20\x01(\x05R\x07version\x12*\n\x10accountStateRoot\x18\x0b\x20\
    \x01(\x0cR\x10accountStateRoot\"|\n\x05Block\x129\n\x0ctransactions\x18\
    \x01\x20\x03(\x0b2\x15.protocol.TransactionR\x0ctransactions\x128\n\x0cb\
    lock_header\x18\x02\x20\x01(\x0b2\x15.protocol.BlockHeaderR\x0bblockHead\
    er\"\x9a\x01\n\x0eChainInventory\x122\n\x03ids\x18\x01\x20\x03(\x0b2\x20\
    .protocol.ChainInventory.BlockIdR\x03ids\x12\x1d\n\nremain_num\x18\x02\
    \x20\x01(\x03R\tremainNum\x1a5\n\x07BlockId\x12\x12\n\x04hash\x18\x01\
    \x20\x01(\x0cR\x04hash\x12\x16\n\x06number\x18\x02\x20\x01(\x03R\x06numb\
    er\"\xd8\x01\n\x0eBlockInventory\x122\n\x03ids\x18\x01\x20\x03(\x0b2\x20\
    .protocol.BlockInventory.BlockIdR\x03ids\x121\n\x04type\x18\x02\x20\x01(\
    \x0e2\x1d.protocol.BlockInventory.TypeR\x04type\x1a5\n\x07BlockId\x12\
    \x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12\x16\n\x06number\x18\x02\
    \x20\x01(\x03R\x06number\"(\n\x04Type\x12\x08\n\x04SYNC\x10\0\x12\x0b\n\
    \x07ADVTISE\x10\x01\x12\t\n\x05FETCH\x10\x02\"y\n\tInventory\x125\n\x04t\
    ype\x18\x01\x20\x01(\x0e2!.protocol.Inventory.InventoryTypeR\x04type\x12\
    \x10\n\x03ids\x18\x02\x20\x03(\x0cR\x03ids\"#\n\rInventoryType\x12\x07\n\
    \x03TRX\x10\0\x12\t\n\x05BLOCK\x10\x01\"\x8f\x02\n\x05Items\x12,\n\x04ty\
    pe\x18\x01\x20\x01(\x0e2\x18.protocol.Items.ItemTypeR\x04type\x12'\n\x06\
    blocks\x18\x02\x20\x03(\x0b2\x0f.protocol.BlockR\x06blocks\x12:\n\rblock\
    _headers\x18\x03\x20\x03(\x0b2\x15.protocol.BlockHeaderR\x0cblockHeaders\
    \x129\n\x0ctransactions\x18\x04\x20\x03(\x0b2\x15.protocol.TransactionR\
    \x0ctransactions\"8\n\x08ItemType\x12\x07\n\x03ERR\x10\0\x12\x07\n\x03TR\
    X\x10\x01\x12\t\n\x05BLOCK\x10\x02\x12\x0f\n\x0bBLOCKHEADER\x10\x03\"J\n\
    \x11DynamicProperties\x125\n\x17last_solidity_block_num\x18\x01\x20\x01(\
    \x03R\x14lastSolidityBlockNum\"A\n\x11DisconnectMessage\x12,\n\x06reason\
    \x18\x01\x20\x01(\x0e2\x14.protocol.ReasonCodeR\x06reason\"\xf3\x02\n\
    \x0cHelloMessage\x12&\n\x04from\x18\x01\x20\x01(\x0b2\x12.protocol.Endpo\
    intR\x04from\x12\x18\n\x07version\x18\x02\x20\x01(\x05R\x07version\x12\
    \x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\ttimestamp\x12F\n\x0egenesisBloc\
    kId\x18\x04\x20\x01(\x0b2\x1e.protocol.HelloMessage.BlockIdR\x0egenesisB\
    lockId\x12B\n\x0csolidBlockId\x18\x05\x20\x01(\x0b2\x1e.protocol.HelloMe\
    ssage.BlockIdR\x0csolidBlockId\x12@\n\x0bheadBlockId\x18\x06\x20\x01(\
    \x0b2\x1e.protocol.HelloMessage.BlockIdR\x0bheadBlockId\x1a5\n\x07BlockI\
    d\x12\x12\n\x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12\x16\n\x06number\
    \x18\x02\x20\x01(\x03R\x06number\"\xee\x08\n\rSmartContract\x12%\n\x0eor\
    igin_address\x18\x01\x20\x01(\x0cR\roriginAddress\x12)\n\x10contract_add\
    ress\x18\x02\x20\x01(\x0cR\x0fcontractAddress\x12-\n\x03abi\x18\x03\x20\
    \x01(\x0b2\x1b.protocol.SmartContract.ABIR\x03abi\x12\x1a\n\x08bytecode\
    \x18\x04\x20\x01(\x0cR\x08bytecode\x12\x1d\n\ncall_value\x18\x05\x20\x01\
    (\x03R\tcallValue\x12A\n\x1dconsume_user_resource_percent\x18\x06\x20\
    \x01(\x03R\x1aconsumeUserResourcePercent\x12\x12\n\x04name\x18\x07\x20\
    \x01(\tR\x04name\x12.\n\x13origin_energy_limit\x18\x08\x20\x01(\x03R\x11\
    originEnergyLimit\x12\x1b\n\tcode_hash\x18\t\x20\x01(\x0cR\x08codeHash\
    \x12\x19\n\x08trx_hash\x18\n\x20\x01(\x0cR\x07trxHash\x1a\xe1\x05\n\x03A\
    BI\x129\n\x06entrys\x18\x01\x20\x03(\x0b2!.protocol.SmartContract.ABI.En\
    tryR\x06entrys\x1a\x9e\x05\n\x05Entry\x12\x1c\n\tanonymous\x18\x01\x20\
    \x01(\x08R\tanonymous\x12\x1a\n\x08constant\x18\x02\x20\x01(\x08R\x08con\
    stant\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12?\n\x06inputs\x18\
    \x04\x20\x03(\x0b2'.protocol.SmartContract.ABI.Entry.ParamR\x06inputs\
    \x12A\n\x07outputs\x18\x05\x20\x03(\x0b2'.protocol.SmartContract.ABI.Ent\
    ry.ParamR\x07outputs\x12?\n\x04type\x18\x06\x20\x01(\x0e2+.protocol.Smar\
    tContract.ABI.Entry.EntryTypeR\x04type\x12\x18\n\x07payable\x18\x07\x20\
    \x01(\x08R\x07payable\x12_\n\x0fstateMutability\x18\x08\x20\x01(\x0e25.p\
    rotocol.SmartContract.ABI.Entry.StateMutabilityTypeR\x0fstateMutability\
    \x1aI\n\x05Param\x12\x18\n\x07indexed\x18\x01\x20\x01(\x08R\x07indexed\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04type\x18\x03\
    \x20\x01(\tR\x04type\"Y\n\tEntryType\x12\x14\n\x10UnknownEntryType\x10\0\
    \x12\x0f\n\x0bConstructor\x10\x01\x12\x0c\n\x08Function\x10\x02\x12\t\n\
    \x05Event\x10\x03\x12\x0c\n\x08Fallback\x10\x04\"a\n\x13StateMutabilityT\
    ype\x12\x19\n\x15UnknownMutabilityType\x10\0\x12\x08\n\x04Pure\x10\x01\
    \x12\x08\n\x04View\x10\x02\x12\x0e\n\nNonpayable\x10\x03\x12\x0b\n\x07Pa\
    yable\x10\x04\"\xcb\x02\n\x13InternalTransaction\x12\x12\n\x04hash\x18\
    \x01\x20\x01(\x0cR\x04hash\x12%\n\x0ecaller_address\x18\x02\x20\x01(\x0c\
    R\rcallerAddress\x12-\n\x12transferTo_address\x18\x03\x20\x01(\x0cR\x11t\
    ransferToAddress\x12Q\n\rcallValueInfo\x18\x04\x20\x03(\x0b2+.protocol.I\
    nternalTransaction.CallValueInfoR\rcallValueInfo\x12\x12\n\x04note\x18\
    \x05\x20\x01(\x0cR\x04note\x12\x1a\n\x08rejected\x18\x06\x20\x01(\x08R\
    \x08rejected\x1aG\n\rCallValueInfo\x12\x1c\n\tcallValue\x18\x01\x20\x01(\
    \x03R\tcallValue\x12\x18\n\x07tokenId\x18\x02\x20\x01(\tR\x07tokenId\"}\
    \n\x1dDelegatedResourceAccountIndex\x12\x18\n\x07account\x18\x01\x20\x01\
    (\x0cR\x07account\x12\"\n\x0cfromAccounts\x18\x02\x20\x03(\x0cR\x0cfromA\
    ccounts\x12\x1e\n\ntoAccounts\x18\x03\x20\x03(\x0cR\ntoAccounts\"\xbf\
    \x1a\n\x08NodeInfo\x12\"\n\x0cbeginSyncNum\x18\x01\x20\x01(\x03R\x0cbegi\
    nSyncNum\x12\x14\n\x05block\x18\x02\x20\x01(\tR\x05block\x12$\n\rsolidit\
    yBlock\x18\x03\x20\x01(\tR\rsolidityBlock\x120\n\x13currentConnectCount\
    \x18\x04\x20\x01(\x05R\x13currentConnectCount\x12.\n\x12activeConnectCou\
    nt\x18\x05\x20\x01(\x05R\x12activeConnectCount\x120\n\x13passiveConnectC\
    ount\x18\x06\x20\x01(\x05R\x13passiveConnectCount\x12\x1c\n\ttotalFlow\
    \x18\x07\x20\x01(\x03R\ttotalFlow\x12?\n\x0cpeerInfoList\x18\x08\x20\x03\
    (\x0b2\x1b.protocol.NodeInfo.PeerInfoR\x0cpeerInfoList\x12I\n\x0econfigN\
    odeInfo\x18\t\x20\x01(\x0b2!.protocol.NodeInfo.ConfigNodeInfoR\x0econfig\
    NodeInfo\x12@\n\x0bmachineInfo\x18\n\x20\x01(\x0b2\x1e.protocol.NodeInfo\
    .MachineInfoR\x0bmachineInfo\x12]\n\x13cheatWitnessInfoMap\x18\x0b\x20\
    \x03(\x0b2+.protocol.NodeInfo.CheatWitnessInfoMapEntryR\x13cheatWitnessI\
    nfoMap\x1aF\n\x18CheatWitnessInfoMapEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\x1a\xc8\x07\n\x08PeerInfo\x12$\n\rlastSyncBlock\x18\x01\x20\x01(\tR\
    \rlastSyncBlock\x12\x1c\n\tremainNum\x18\x02\x20\x01(\x03R\tremainNum\
    \x120\n\x13lastBlockUpdateTime\x18\x03\x20\x01(\x03R\x13lastBlockUpdateT\
    ime\x12\x1a\n\x08syncFlag\x18\x04\x20\x01(\x08R\x08syncFlag\x128\n\x17he\
    adBlockTimeWeBothHave\x18\x05\x20\x01(\x03R\x17headBlockTimeWeBothHave\
    \x12*\n\x10needSyncFromPeer\x18\x06\x20\x01(\x08R\x10needSyncFromPeer\
    \x12&\n\x0eneedSyncFromUs\x18\x07\x20\x01(\x08R\x0eneedSyncFromUs\x12\
    \x12\n\x04host\x18\x08\x20\x01(\tR\x04host\x12\x12\n\x04port\x18\t\x20\
    \x01(\x05R\x04port\x12\x16\n\x06nodeId\x18\n\x20\x01(\tR\x06nodeId\x12\
    \x20\n\x0bconnectTime\x18\x0b\x20\x01(\x03R\x0bconnectTime\x12\x1e\n\nav\
    gLatency\x18\x0c\x20\x01(\x01R\navgLatency\x12(\n\x0fsyncToFetchSize\x18\
    \r\x20\x01(\x05R\x0fsyncToFetchSize\x126\n\x16syncToFetchSizePeekNum\x18\
    \x0e\x20\x01(\x03R\x16syncToFetchSizePeekNum\x126\n\x16syncBlockRequeste\
    dSize\x18\x0f\x20\x01(\x05R\x16syncBlockRequestedSize\x12$\n\runFetchSyn\
    Num\x18\x10\x20\x01(\x03R\runFetchSynNum\x12(\n\x0fblockInPorcSize\x18\
    \x11\x20\x01(\x05R\x0fblockInPorcSize\x120\n\x13headBlockWeBothHave\x18\
    \x12\x20\x01(\tR\x13headBlockWeBothHave\x12\x1a\n\x08isActive\x18\x13\
    \x20\x01(\x08R\x08isActive\x12\x14\n\x05score\x18\x14\x20\x01(\x05R\x05s\
    core\x12\x1c\n\tnodeCount\x18\x15\x20\x01(\x05R\tnodeCount\x12\x16\n\x06\
    inFlow\x18\x16\x20\x01(\x03R\x06inFlow\x12(\n\x0fdisconnectTimes\x18\x17\
    \x20\x01(\x05R\x0fdisconnectTimes\x124\n\x15localDisconnectReason\x18\
    \x18\x20\x01(\tR\x15localDisconnectReason\x126\n\x16remoteDisconnectReas\
    on\x18\x19\x20\x01(\tR\x16remoteDisconnectReason\x1a\xa2\x06\n\x0eConfig\
    NodeInfo\x12\x20\n\x0bcodeVersion\x18\x01\x20\x01(\tR\x0bcodeVersion\x12\
    \x1e\n\np2pVersion\x18\x02\x20\x01(\tR\np2pVersion\x12\x1e\n\nlistenPort\
    \x18\x03\x20\x01(\x05R\nlistenPort\x12&\n\x0ediscoverEnable\x18\x04\x20\
    \x01(\x08R\x0ediscoverEnable\x12&\n\x0eactiveNodeSize\x18\x05\x20\x01(\
    \x05R\x0eactiveNodeSize\x12(\n\x0fpassiveNodeSize\x18\x06\x20\x01(\x05R\
    \x0fpassiveNodeSize\x12\"\n\x0csendNodeSize\x18\x07\x20\x01(\x05R\x0csen\
    dNodeSize\x12(\n\x0fmaxConnectCount\x18\x08\x20\x01(\x05R\x0fmaxConnectC\
    ount\x124\n\x15sameIpMaxConnectCount\x18\t\x20\x01(\x05R\x15sameIpMaxCon\
    nectCount\x12*\n\x10backupListenPort\x18\n\x20\x01(\x05R\x10backupListen\
    Port\x12*\n\x10backupMemberSize\x18\x0b\x20\x01(\x05R\x10backupMemberSiz\
    e\x12&\n\x0ebackupPriority\x18\x0c\x20\x01(\x05R\x0ebackupPriority\x12\
    \x1c\n\tdbVersion\x18\r\x20\x01(\x05R\tdbVersion\x122\n\x14minParticipat\
    ionRate\x18\x0e\x20\x01(\x05R\x14minParticipationRate\x12(\n\x0fsupportC\
    onstant\x18\x0f\x20\x01(\x08R\x0fsupportConstant\x12\"\n\x0cminTimeRatio\
    \x18\x10\x20\x01(\x01R\x0cminTimeRatio\x12\"\n\x0cmaxTimeRatio\x18\x11\
    \x20\x01(\x01R\x0cmaxTimeRatio\x12:\n\x18allowCreationOfContracts\x18\
    \x12\x20\x01(\x03R\x18allowCreationOfContracts\x120\n\x13allowAdaptiveEn\
    ergy\x18\x13\x20\x01(\x03R\x13allowAdaptiveEnergy\x1a\xbb\x07\n\x0bMachi\
    neInfo\x12\x20\n\x0bthreadCount\x18\x01\x20\x01(\x05R\x0bthreadCount\x12\
    0\n\x13deadLockThreadCount\x18\x02\x20\x01(\x05R\x13deadLockThreadCount\
    \x12\x1a\n\x08cpuCount\x18\x03\x20\x01(\x05R\x08cpuCount\x12\x20\n\x0bto\
    talMemory\x18\x04\x20\x01(\x03R\x0btotalMemory\x12\x1e\n\nfreeMemory\x18\
    \x05\x20\x01(\x03R\nfreeMemory\x12\x18\n\x07cpuRate\x18\x06\x20\x01(\x01\
    R\x07cpuRate\x12\x20\n\x0bjavaVersion\x18\x07\x20\x01(\tR\x0bjavaVersion\
    \x12\x16\n\x06osName\x18\x08\x20\x01(\tR\x06osName\x12(\n\x0fjvmTotalMem\
    oery\x18\t\x20\x01(\x03R\x0fjvmTotalMemoery\x12$\n\rjvmFreeMemory\x18\n\
    \x20\x01(\x03R\rjvmFreeMemory\x12&\n\x0eprocessCpuRate\x18\x0b\x20\x01(\
    \x01R\x0eprocessCpuRate\x12]\n\x12memoryDescInfoList\x18\x0c\x20\x03(\
    \x0b2-.protocol.NodeInfo.MachineInfo.MemoryDescInfoR\x12memoryDescInfoLi\
    st\x12i\n\x16deadLockThreadInfoList\x18\r\x20\x03(\x0b21.protocol.NodeIn\
    fo.MachineInfo.DeadLockThreadInfoR\x16deadLockThreadInfoList\x1a\x8e\x01\
    \n\x0eMemoryDescInfo\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x1a\n\x08initSize\x18\x02\x20\x01(\x03R\x08initSize\x12\x18\n\x07useSiz\
    e\x18\x03\x20\x01(\x03R\x07useSize\x12\x18\n\x07maxSize\x18\x04\x20\x01(\
    \x03R\x07maxSize\x12\x18\n\x07useRate\x18\x05\x20\x01(\x01R\x07useRate\
    \x1a\xd2\x01\n\x12DeadLockThreadInfo\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x1a\n\x08lockName\x18\x02\x20\x01(\tR\x08lockName\x12\
    \x1c\n\tlockOwner\x18\x03\x20\x01(\tR\tlockOwner\x12\x14\n\x05state\x18\
    \x04\x20\x01(\tR\x05state\x12\x1c\n\tblockTime\x18\x05\x20\x01(\x03R\tbl\
    ockTime\x12\x1a\n\x08waitTime\x18\x06\x20\x01(\x03R\x08waitTime\x12\x1e\
    \n\nstackTrace\x18\x07\x20\x01(\tR\nstackTrace*7\n\x0bAccountType\x12\n\
    \n\x06Normal\x10\0\x12\x0e\n\nAssetIssue\x10\x01\x12\x0c\n\x08Contract\
    \x10\x02*\xc7\x03\n\nReasonCode\x12\r\n\tREQUESTED\x10\0\x12\x10\n\x0cBA\
    D_PROTOCOL\x10\x02\x12\x12\n\x0eTOO_MANY_PEERS\x10\x04\x12\x12\n\x0eDUPL\
    ICATE_PEER\x10\x05\x12\x19\n\x15INCOMPATIBLE_PROTOCOL\x10\x06\x12\x11\n\
    \rNULL_IDENTITY\x10\x07\x12\x10\n\x0cPEER_QUITING\x10\x08\x12\x17\n\x13U\
    NEXPECTED_IDENTITY\x10\t\x12\x12\n\x0eLOCAL_IDENTITY\x10\n\x12\x10\n\x0c\
    PING_TIMEOUT\x10\x0b\x12\x0f\n\x0bUSER_REASON\x10\x10\x12\t\n\x05RESET\
    \x10\x11\x12\r\n\tSYNC_FAIL\x10\x12\x12\x0e\n\nFETCH_FAIL\x10\x13\x12\n\
    \n\x06BAD_TX\x10\x14\x12\r\n\tBAD_BLOCK\x10\x15\x12\n\n\x06FORKED\x10\
    \x16\x12\x0e\n\nUNLINKABLE\x10\x17\x12\x18\n\x14INCOMPATIBLE_VERSION\x10\
    \x18\x12\x16\n\x12INCOMPATIBLE_CHAIN\x10\x19\x12\x0c\n\x08TIME_OUT\x10\
    \x20\x12\x10\n\x0cCONNECT_FAIL\x10!\x12\x1f\n\x1bTOO_MANY_PEERS_WITH_SAM\
    E_IP\x10\"\x12\x0c\n\x07UNKNOWN\x10\xff\x01BF\n\x0forg.tron.protosB\x08P\
    rotocolZ)github.com/tronprotocol/grpc-gateway/coreb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
