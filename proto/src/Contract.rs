// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `core/Contract.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AccountCreateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub account_address: ::std::vec::Vec<u8>,
    pub field_type: super::Tron::AccountType,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountCreateContract {
    fn default() -> &'a AccountCreateContract {
        <AccountCreateContract as ::protobuf::Message>::default_instance()
    }
}

impl AccountCreateContract {
    pub fn new() -> AccountCreateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes account_address = 2;


    pub fn get_account_address(&self) -> &[u8] {
        &self.account_address
    }
    pub fn clear_account_address(&mut self) {
        self.account_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_address
    }

    // Take field
    pub fn take_account_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_address, ::std::vec::Vec::new())
    }

    // .protocol.AccountType type = 3;


    pub fn get_field_type(&self) -> super::Tron::AccountType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = super::Tron::AccountType::Normal;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: super::Tron::AccountType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for AccountCreateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_address)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.account_address);
        }
        if self.field_type != super::Tron::AccountType::Normal {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.account_address.is_empty() {
            os.write_bytes(2, &self.account_address)?;
        }
        if self.field_type != super::Tron::AccountType::Normal {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountCreateContract {
        AccountCreateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &AccountCreateContract| { &m.owner_address },
                |m: &mut AccountCreateContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "account_address",
                |m: &AccountCreateContract| { &m.account_address },
                |m: &mut AccountCreateContract| { &mut m.account_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::Tron::AccountType>>(
                "type",
                |m: &AccountCreateContract| { &m.field_type },
                |m: &mut AccountCreateContract| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccountCreateContract>(
                "AccountCreateContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccountCreateContract {
        static instance: ::protobuf::rt::LazyV2<AccountCreateContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountCreateContract::new)
    }
}

impl ::protobuf::Clear for AccountCreateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.account_address.clear();
        self.field_type = super::Tron::AccountType::Normal;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountCreateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountCreateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AccountUpdateContract {
    // message fields
    pub account_name: ::std::vec::Vec<u8>,
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountUpdateContract {
    fn default() -> &'a AccountUpdateContract {
        <AccountUpdateContract as ::protobuf::Message>::default_instance()
    }
}

impl AccountUpdateContract {
    pub fn new() -> AccountUpdateContract {
        ::std::default::Default::default()
    }

    // bytes account_name = 1;


    pub fn get_account_name(&self) -> &[u8] {
        &self.account_name
    }
    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_name
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_name, ::std::vec::Vec::new())
    }

    // bytes owner_address = 2;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AccountUpdateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account_name);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account_name.is_empty() {
            os.write_bytes(1, &self.account_name)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(2, &self.owner_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountUpdateContract {
        AccountUpdateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "account_name",
                |m: &AccountUpdateContract| { &m.account_name },
                |m: &mut AccountUpdateContract| { &mut m.account_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &AccountUpdateContract| { &m.owner_address },
                |m: &mut AccountUpdateContract| { &mut m.owner_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccountUpdateContract>(
                "AccountUpdateContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccountUpdateContract {
        static instance: ::protobuf::rt::LazyV2<AccountUpdateContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountUpdateContract::new)
    }
}

impl ::protobuf::Clear for AccountUpdateContract {
    fn clear(&mut self) {
        self.account_name.clear();
        self.owner_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountUpdateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountUpdateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SetAccountIdContract {
    // message fields
    pub account_id: ::std::vec::Vec<u8>,
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetAccountIdContract {
    fn default() -> &'a SetAccountIdContract {
        <SetAccountIdContract as ::protobuf::Message>::default_instance()
    }
}

impl SetAccountIdContract {
    pub fn new() -> SetAccountIdContract {
        ::std::default::Default::default()
    }

    // bytes account_id = 1;


    pub fn get_account_id(&self) -> &[u8] {
        &self.account_id
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.account_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account_id
    }

    // Take field
    pub fn take_account_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account_id, ::std::vec::Vec::new())
    }

    // bytes owner_address = 2;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SetAccountIdContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account_id);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.account_id.is_empty() {
            os.write_bytes(1, &self.account_id)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(2, &self.owner_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetAccountIdContract {
        SetAccountIdContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "account_id",
                |m: &SetAccountIdContract| { &m.account_id },
                |m: &mut SetAccountIdContract| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &SetAccountIdContract| { &m.owner_address },
                |m: &mut SetAccountIdContract| { &mut m.owner_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetAccountIdContract>(
                "SetAccountIdContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetAccountIdContract {
        static instance: ::protobuf::rt::LazyV2<SetAccountIdContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetAccountIdContract::new)
    }
}

impl ::protobuf::Clear for SetAccountIdContract {
    fn clear(&mut self) {
        self.account_id.clear();
        self.owner_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetAccountIdContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetAccountIdContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransferContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub to_address: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferContract {
    fn default() -> &'a TransferContract {
        <TransferContract as ::protobuf::Message>::default_instance()
    }
}

impl TransferContract {
    pub fn new() -> TransferContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes to_address = 2;


    pub fn get_to_address(&self) -> &[u8] {
        &self.to_address
    }
    pub fn clear_to_address(&mut self) {
        self.to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to_address
    }

    // Take field
    pub fn take_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to_address, ::std::vec::Vec::new())
    }

    // int64 amount = 3;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for TransferContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to_address);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(3, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(2, &self.to_address)?;
        }
        if self.amount != 0 {
            os.write_int64(3, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferContract {
        TransferContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &TransferContract| { &m.owner_address },
                |m: &mut TransferContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "to_address",
                |m: &TransferContract| { &m.to_address },
                |m: &mut TransferContract| { &mut m.to_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &TransferContract| { &m.amount },
                |m: &mut TransferContract| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferContract>(
                "TransferContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferContract {
        static instance: ::protobuf::rt::LazyV2<TransferContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferContract::new)
    }
}

impl ::protobuf::Clear for TransferContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.to_address.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ShieldAddress {
    // message fields
    pub private_address: ::std::vec::Vec<u8>,
    pub public_address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShieldAddress {
    fn default() -> &'a ShieldAddress {
        <ShieldAddress as ::protobuf::Message>::default_instance()
    }
}

impl ShieldAddress {
    pub fn new() -> ShieldAddress {
        ::std::default::Default::default()
    }

    // bytes private_address = 1;


    pub fn get_private_address(&self) -> &[u8] {
        &self.private_address
    }
    pub fn clear_private_address(&mut self) {
        self.private_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_private_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.private_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.private_address
    }

    // Take field
    pub fn take_private_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.private_address, ::std::vec::Vec::new())
    }

    // bytes public_address = 2;


    pub fn get_public_address(&self) -> &[u8] {
        &self.public_address
    }
    pub fn clear_public_address(&mut self) {
        self.public_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_address
    }

    // Take field
    pub fn take_public_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ShieldAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.private_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.private_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.private_address);
        }
        if !self.public_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.public_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.private_address.is_empty() {
            os.write_bytes(1, &self.private_address)?;
        }
        if !self.public_address.is_empty() {
            os.write_bytes(2, &self.public_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShieldAddress {
        ShieldAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "private_address",
                |m: &ShieldAddress| { &m.private_address },
                |m: &mut ShieldAddress| { &mut m.private_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "public_address",
                |m: &ShieldAddress| { &m.public_address },
                |m: &mut ShieldAddress| { &mut m.public_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShieldAddress>(
                "ShieldAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShieldAddress {
        static instance: ::protobuf::rt::LazyV2<ShieldAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShieldAddress::new)
    }
}

impl ::protobuf::Clear for ShieldAddress {
    fn clear(&mut self) {
        self.private_address.clear();
        self.public_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShieldAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShieldAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TransferAssetContract {
    // message fields
    pub asset_name: ::std::vec::Vec<u8>,
    pub owner_address: ::std::vec::Vec<u8>,
    pub to_address: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferAssetContract {
    fn default() -> &'a TransferAssetContract {
        <TransferAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl TransferAssetContract {
    pub fn new() -> TransferAssetContract {
        ::std::default::Default::default()
    }

    // bytes asset_name = 1;


    pub fn get_asset_name(&self) -> &[u8] {
        &self.asset_name
    }
    pub fn clear_asset_name(&mut self) {
        self.asset_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.asset_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.asset_name
    }

    // Take field
    pub fn take_asset_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.asset_name, ::std::vec::Vec::new())
    }

    // bytes owner_address = 2;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes to_address = 3;


    pub fn get_to_address(&self) -> &[u8] {
        &self.to_address
    }
    pub fn clear_to_address(&mut self) {
        self.to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to_address
    }

    // Take field
    pub fn take_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to_address, ::std::vec::Vec::new())
    }

    // int64 amount = 4;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for TransferAssetContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.asset_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to_address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.asset_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.asset_name);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.owner_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.to_address);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.asset_name.is_empty() {
            os.write_bytes(1, &self.asset_name)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(2, &self.owner_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(3, &self.to_address)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferAssetContract {
        TransferAssetContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "asset_name",
                |m: &TransferAssetContract| { &m.asset_name },
                |m: &mut TransferAssetContract| { &mut m.asset_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &TransferAssetContract| { &m.owner_address },
                |m: &mut TransferAssetContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "to_address",
                |m: &TransferAssetContract| { &m.to_address },
                |m: &mut TransferAssetContract| { &mut m.to_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &TransferAssetContract| { &m.amount },
                |m: &mut TransferAssetContract| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferAssetContract>(
                "TransferAssetContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferAssetContract {
        static instance: ::protobuf::rt::LazyV2<TransferAssetContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferAssetContract::new)
    }
}

impl ::protobuf::Clear for TransferAssetContract {
    fn clear(&mut self) {
        self.asset_name.clear();
        self.owner_address.clear();
        self.to_address.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferAssetContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VoteAssetContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub vote_address: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub support: bool,
    pub count: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteAssetContract {
    fn default() -> &'a VoteAssetContract {
        <VoteAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl VoteAssetContract {
    pub fn new() -> VoteAssetContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // repeated bytes vote_address = 2;


    pub fn get_vote_address(&self) -> &[::std::vec::Vec<u8>] {
        &self.vote_address
    }
    pub fn clear_vote_address(&mut self) {
        self.vote_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_vote_address(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.vote_address = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vote_address(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.vote_address
    }

    // Take field
    pub fn take_vote_address(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.vote_address, ::protobuf::RepeatedField::new())
    }

    // bool support = 3;


    pub fn get_support(&self) -> bool {
        self.support
    }
    pub fn clear_support(&mut self) {
        self.support = false;
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: bool) {
        self.support = v;
    }

    // int32 count = 5;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }
}

impl ::protobuf::Message for VoteAssetContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.vote_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.support = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        for value in &self.vote_address {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.support != false {
            my_size += 2;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        for v in &self.vote_address {
            os.write_bytes(2, &v)?;
        };
        if self.support != false {
            os.write_bool(3, self.support)?;
        }
        if self.count != 0 {
            os.write_int32(5, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteAssetContract {
        VoteAssetContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &VoteAssetContract| { &m.owner_address },
                |m: &mut VoteAssetContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vote_address",
                |m: &VoteAssetContract| { &m.vote_address },
                |m: &mut VoteAssetContract| { &mut m.vote_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "support",
                |m: &VoteAssetContract| { &m.support },
                |m: &mut VoteAssetContract| { &mut m.support },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &VoteAssetContract| { &m.count },
                |m: &mut VoteAssetContract| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteAssetContract>(
                "VoteAssetContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteAssetContract {
        static instance: ::protobuf::rt::LazyV2<VoteAssetContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteAssetContract::new)
    }
}

impl ::protobuf::Clear for VoteAssetContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.vote_address.clear();
        self.support = false;
        self.count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteAssetContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VoteWitnessContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub votes: ::protobuf::RepeatedField<VoteWitnessContract_Vote>,
    pub support: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteWitnessContract {
    fn default() -> &'a VoteWitnessContract {
        <VoteWitnessContract as ::protobuf::Message>::default_instance()
    }
}

impl VoteWitnessContract {
    pub fn new() -> VoteWitnessContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // repeated .protocol.VoteWitnessContract.Vote votes = 2;


    pub fn get_votes(&self) -> &[VoteWitnessContract_Vote] {
        &self.votes
    }
    pub fn clear_votes(&mut self) {
        self.votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_votes(&mut self, v: ::protobuf::RepeatedField<VoteWitnessContract_Vote>) {
        self.votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_votes(&mut self) -> &mut ::protobuf::RepeatedField<VoteWitnessContract_Vote> {
        &mut self.votes
    }

    // Take field
    pub fn take_votes(&mut self) -> ::protobuf::RepeatedField<VoteWitnessContract_Vote> {
        ::std::mem::replace(&mut self.votes, ::protobuf::RepeatedField::new())
    }

    // bool support = 3;


    pub fn get_support(&self) -> bool {
        self.support
    }
    pub fn clear_support(&mut self) {
        self.support = false;
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: bool) {
        self.support = v;
    }
}

impl ::protobuf::Message for VoteWitnessContract {
    fn is_initialized(&self) -> bool {
        for v in &self.votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.votes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.support = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.support != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        for v in &self.votes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.support != false {
            os.write_bool(3, self.support)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteWitnessContract {
        VoteWitnessContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &VoteWitnessContract| { &m.owner_address },
                |m: &mut VoteWitnessContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VoteWitnessContract_Vote>>(
                "votes",
                |m: &VoteWitnessContract| { &m.votes },
                |m: &mut VoteWitnessContract| { &mut m.votes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "support",
                |m: &VoteWitnessContract| { &m.support },
                |m: &mut VoteWitnessContract| { &mut m.support },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteWitnessContract>(
                "VoteWitnessContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteWitnessContract {
        static instance: ::protobuf::rt::LazyV2<VoteWitnessContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteWitnessContract::new)
    }
}

impl ::protobuf::Clear for VoteWitnessContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.votes.clear();
        self.support = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteWitnessContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteWitnessContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VoteWitnessContract_Vote {
    // message fields
    pub vote_address: ::std::vec::Vec<u8>,
    pub vote_count: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VoteWitnessContract_Vote {
    fn default() -> &'a VoteWitnessContract_Vote {
        <VoteWitnessContract_Vote as ::protobuf::Message>::default_instance()
    }
}

impl VoteWitnessContract_Vote {
    pub fn new() -> VoteWitnessContract_Vote {
        ::std::default::Default::default()
    }

    // bytes vote_address = 1;


    pub fn get_vote_address(&self) -> &[u8] {
        &self.vote_address
    }
    pub fn clear_vote_address(&mut self) {
        self.vote_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_vote_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.vote_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.vote_address
    }

    // Take field
    pub fn take_vote_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.vote_address, ::std::vec::Vec::new())
    }

    // int64 vote_count = 2;


    pub fn get_vote_count(&self) -> i64 {
        self.vote_count
    }
    pub fn clear_vote_count(&mut self) {
        self.vote_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_vote_count(&mut self, v: i64) {
        self.vote_count = v;
    }
}

impl ::protobuf::Message for VoteWitnessContract_Vote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.vote_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vote_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.vote_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.vote_address);
        }
        if self.vote_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.vote_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.vote_address.is_empty() {
            os.write_bytes(1, &self.vote_address)?;
        }
        if self.vote_count != 0 {
            os.write_int64(2, self.vote_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VoteWitnessContract_Vote {
        VoteWitnessContract_Vote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vote_address",
                |m: &VoteWitnessContract_Vote| { &m.vote_address },
                |m: &mut VoteWitnessContract_Vote| { &mut m.vote_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "vote_count",
                |m: &VoteWitnessContract_Vote| { &m.vote_count },
                |m: &mut VoteWitnessContract_Vote| { &mut m.vote_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VoteWitnessContract_Vote>(
                "VoteWitnessContract.Vote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VoteWitnessContract_Vote {
        static instance: ::protobuf::rt::LazyV2<VoteWitnessContract_Vote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VoteWitnessContract_Vote::new)
    }
}

impl ::protobuf::Clear for VoteWitnessContract_Vote {
    fn clear(&mut self) {
        self.vote_address.clear();
        self.vote_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VoteWitnessContract_Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoteWitnessContract_Vote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateSettingContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub consume_user_resource_percent: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateSettingContract {
    fn default() -> &'a UpdateSettingContract {
        <UpdateSettingContract as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSettingContract {
    pub fn new() -> UpdateSettingContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // int64 consume_user_resource_percent = 3;


    pub fn get_consume_user_resource_percent(&self) -> i64 {
        self.consume_user_resource_percent
    }
    pub fn clear_consume_user_resource_percent(&mut self) {
        self.consume_user_resource_percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_consume_user_resource_percent(&mut self, v: i64) {
        self.consume_user_resource_percent = v;
    }
}

impl ::protobuf::Message for UpdateSettingContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.consume_user_resource_percent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        if self.consume_user_resource_percent != 0 {
            my_size += ::protobuf::rt::value_size(3, self.consume_user_resource_percent, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        if self.consume_user_resource_percent != 0 {
            os.write_int64(3, self.consume_user_resource_percent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateSettingContract {
        UpdateSettingContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &UpdateSettingContract| { &m.owner_address },
                |m: &mut UpdateSettingContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contract_address",
                |m: &UpdateSettingContract| { &m.contract_address },
                |m: &mut UpdateSettingContract| { &mut m.contract_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "consume_user_resource_percent",
                |m: &UpdateSettingContract| { &m.consume_user_resource_percent },
                |m: &mut UpdateSettingContract| { &mut m.consume_user_resource_percent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateSettingContract>(
                "UpdateSettingContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateSettingContract {
        static instance: ::protobuf::rt::LazyV2<UpdateSettingContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateSettingContract::new)
    }
}

impl ::protobuf::Clear for UpdateSettingContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.contract_address.clear();
        self.consume_user_resource_percent = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateSettingContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSettingContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateEnergyLimitContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub origin_energy_limit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateEnergyLimitContract {
    fn default() -> &'a UpdateEnergyLimitContract {
        <UpdateEnergyLimitContract as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEnergyLimitContract {
    pub fn new() -> UpdateEnergyLimitContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // int64 origin_energy_limit = 3;


    pub fn get_origin_energy_limit(&self) -> i64 {
        self.origin_energy_limit
    }
    pub fn clear_origin_energy_limit(&mut self) {
        self.origin_energy_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_origin_energy_limit(&mut self, v: i64) {
        self.origin_energy_limit = v;
    }
}

impl ::protobuf::Message for UpdateEnergyLimitContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.origin_energy_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        if self.origin_energy_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.origin_energy_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        if self.origin_energy_limit != 0 {
            os.write_int64(3, self.origin_energy_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateEnergyLimitContract {
        UpdateEnergyLimitContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &UpdateEnergyLimitContract| { &m.owner_address },
                |m: &mut UpdateEnergyLimitContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contract_address",
                |m: &UpdateEnergyLimitContract| { &m.contract_address },
                |m: &mut UpdateEnergyLimitContract| { &mut m.contract_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "origin_energy_limit",
                |m: &UpdateEnergyLimitContract| { &m.origin_energy_limit },
                |m: &mut UpdateEnergyLimitContract| { &mut m.origin_energy_limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateEnergyLimitContract>(
                "UpdateEnergyLimitContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateEnergyLimitContract {
        static instance: ::protobuf::rt::LazyV2<UpdateEnergyLimitContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateEnergyLimitContract::new)
    }
}

impl ::protobuf::Clear for UpdateEnergyLimitContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.contract_address.clear();
        self.origin_energy_limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateEnergyLimitContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEnergyLimitContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ClearABIContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClearABIContract {
    fn default() -> &'a ClearABIContract {
        <ClearABIContract as ::protobuf::Message>::default_instance()
    }
}

impl ClearABIContract {
    pub fn new() -> ClearABIContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ClearABIContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearABIContract {
        ClearABIContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ClearABIContract| { &m.owner_address },
                |m: &mut ClearABIContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contract_address",
                |m: &ClearABIContract| { &m.contract_address },
                |m: &mut ClearABIContract| { &mut m.contract_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClearABIContract>(
                "ClearABIContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClearABIContract {
        static instance: ::protobuf::rt::LazyV2<ClearABIContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClearABIContract::new)
    }
}

impl ::protobuf::Clear for ClearABIContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.contract_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClearABIContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearABIContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WitnessCreateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub url: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WitnessCreateContract {
    fn default() -> &'a WitnessCreateContract {
        <WitnessCreateContract as ::protobuf::Message>::default_instance()
    }
}

impl WitnessCreateContract {
    pub fn new() -> WitnessCreateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes url = 2;


    pub fn get_url(&self) -> &[u8] {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::vec::Vec<u8>) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.url, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WitnessCreateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.url.is_empty() {
            os.write_bytes(2, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WitnessCreateContract {
        WitnessCreateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &WitnessCreateContract| { &m.owner_address },
                |m: &mut WitnessCreateContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "url",
                |m: &WitnessCreateContract| { &m.url },
                |m: &mut WitnessCreateContract| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WitnessCreateContract>(
                "WitnessCreateContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WitnessCreateContract {
        static instance: ::protobuf::rt::LazyV2<WitnessCreateContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WitnessCreateContract::new)
    }
}

impl ::protobuf::Clear for WitnessCreateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WitnessCreateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WitnessCreateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WitnessUpdateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub update_url: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WitnessUpdateContract {
    fn default() -> &'a WitnessUpdateContract {
        <WitnessUpdateContract as ::protobuf::Message>::default_instance()
    }
}

impl WitnessUpdateContract {
    pub fn new() -> WitnessUpdateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes update_url = 12;


    pub fn get_update_url(&self) -> &[u8] {
        &self.update_url
    }
    pub fn clear_update_url(&mut self) {
        self.update_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_update_url(&mut self, v: ::std::vec::Vec<u8>) {
        self.update_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_url(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.update_url
    }

    // Take field
    pub fn take_update_url(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.update_url, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WitnessUpdateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.update_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.update_url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.update_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.update_url.is_empty() {
            os.write_bytes(12, &self.update_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WitnessUpdateContract {
        WitnessUpdateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &WitnessUpdateContract| { &m.owner_address },
                |m: &mut WitnessUpdateContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "update_url",
                |m: &WitnessUpdateContract| { &m.update_url },
                |m: &mut WitnessUpdateContract| { &mut m.update_url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WitnessUpdateContract>(
                "WitnessUpdateContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WitnessUpdateContract {
        static instance: ::protobuf::rt::LazyV2<WitnessUpdateContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WitnessUpdateContract::new)
    }
}

impl ::protobuf::Clear for WitnessUpdateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.update_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WitnessUpdateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WitnessUpdateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AssetIssueContract {
    // message fields
    pub id: ::std::string::String,
    pub owner_address: ::std::vec::Vec<u8>,
    pub name: ::std::vec::Vec<u8>,
    pub abbr: ::std::vec::Vec<u8>,
    pub total_supply: i64,
    pub frozen_supply: ::protobuf::RepeatedField<AssetIssueContract_FrozenSupply>,
    pub trx_num: i32,
    pub precision: i32,
    pub num: i32,
    pub start_time: i64,
    pub end_time: i64,
    pub order: i64,
    pub vote_score: i32,
    pub description: ::std::vec::Vec<u8>,
    pub url: ::std::vec::Vec<u8>,
    pub free_asset_net_limit: i64,
    pub public_free_asset_net_limit: i64,
    pub public_free_asset_net_usage: i64,
    pub public_latest_free_net_time: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetIssueContract {
    fn default() -> &'a AssetIssueContract {
        <AssetIssueContract as ::protobuf::Message>::default_instance()
    }
}

impl AssetIssueContract {
    pub fn new() -> AssetIssueContract {
        ::std::default::Default::default()
    }

    // string id = 41;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes name = 2;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }

    // bytes abbr = 3;


    pub fn get_abbr(&self) -> &[u8] {
        &self.abbr
    }
    pub fn clear_abbr(&mut self) {
        self.abbr.clear();
    }

    // Param is passed by value, moved
    pub fn set_abbr(&mut self, v: ::std::vec::Vec<u8>) {
        self.abbr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abbr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.abbr
    }

    // Take field
    pub fn take_abbr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.abbr, ::std::vec::Vec::new())
    }

    // int64 total_supply = 4;


    pub fn get_total_supply(&self) -> i64 {
        self.total_supply
    }
    pub fn clear_total_supply(&mut self) {
        self.total_supply = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_supply(&mut self, v: i64) {
        self.total_supply = v;
    }

    // repeated .protocol.AssetIssueContract.FrozenSupply frozen_supply = 5;


    pub fn get_frozen_supply(&self) -> &[AssetIssueContract_FrozenSupply] {
        &self.frozen_supply
    }
    pub fn clear_frozen_supply(&mut self) {
        self.frozen_supply.clear();
    }

    // Param is passed by value, moved
    pub fn set_frozen_supply(&mut self, v: ::protobuf::RepeatedField<AssetIssueContract_FrozenSupply>) {
        self.frozen_supply = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frozen_supply(&mut self) -> &mut ::protobuf::RepeatedField<AssetIssueContract_FrozenSupply> {
        &mut self.frozen_supply
    }

    // Take field
    pub fn take_frozen_supply(&mut self) -> ::protobuf::RepeatedField<AssetIssueContract_FrozenSupply> {
        ::std::mem::replace(&mut self.frozen_supply, ::protobuf::RepeatedField::new())
    }

    // int32 trx_num = 6;


    pub fn get_trx_num(&self) -> i32 {
        self.trx_num
    }
    pub fn clear_trx_num(&mut self) {
        self.trx_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_trx_num(&mut self, v: i32) {
        self.trx_num = v;
    }

    // int32 precision = 7;


    pub fn get_precision(&self) -> i32 {
        self.precision
    }
    pub fn clear_precision(&mut self) {
        self.precision = 0;
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: i32) {
        self.precision = v;
    }

    // int32 num = 8;


    pub fn get_num(&self) -> i32 {
        self.num
    }
    pub fn clear_num(&mut self) {
        self.num = 0;
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: i32) {
        self.num = v;
    }

    // int64 start_time = 9;


    pub fn get_start_time(&self) -> i64 {
        self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = v;
    }

    // int64 end_time = 10;


    pub fn get_end_time(&self) -> i64 {
        self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = v;
    }

    // int64 order = 11;


    pub fn get_order(&self) -> i64 {
        self.order
    }
    pub fn clear_order(&mut self) {
        self.order = 0;
    }

    // Param is passed by value, moved
    pub fn set_order(&mut self, v: i64) {
        self.order = v;
    }

    // int32 vote_score = 16;


    pub fn get_vote_score(&self) -> i32 {
        self.vote_score
    }
    pub fn clear_vote_score(&mut self) {
        self.vote_score = 0;
    }

    // Param is passed by value, moved
    pub fn set_vote_score(&mut self, v: i32) {
        self.vote_score = v;
    }

    // bytes description = 20;


    pub fn get_description(&self) -> &[u8] {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::vec::Vec<u8>) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description, ::std::vec::Vec::new())
    }

    // bytes url = 21;


    pub fn get_url(&self) -> &[u8] {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::vec::Vec<u8>) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.url, ::std::vec::Vec::new())
    }

    // int64 free_asset_net_limit = 22;


    pub fn get_free_asset_net_limit(&self) -> i64 {
        self.free_asset_net_limit
    }
    pub fn clear_free_asset_net_limit(&mut self) {
        self.free_asset_net_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_free_asset_net_limit(&mut self, v: i64) {
        self.free_asset_net_limit = v;
    }

    // int64 public_free_asset_net_limit = 23;


    pub fn get_public_free_asset_net_limit(&self) -> i64 {
        self.public_free_asset_net_limit
    }
    pub fn clear_public_free_asset_net_limit(&mut self) {
        self.public_free_asset_net_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_public_free_asset_net_limit(&mut self, v: i64) {
        self.public_free_asset_net_limit = v;
    }

    // int64 public_free_asset_net_usage = 24;


    pub fn get_public_free_asset_net_usage(&self) -> i64 {
        self.public_free_asset_net_usage
    }
    pub fn clear_public_free_asset_net_usage(&mut self) {
        self.public_free_asset_net_usage = 0;
    }

    // Param is passed by value, moved
    pub fn set_public_free_asset_net_usage(&mut self, v: i64) {
        self.public_free_asset_net_usage = v;
    }

    // int64 public_latest_free_net_time = 25;


    pub fn get_public_latest_free_net_time(&self) -> i64 {
        self.public_latest_free_net_time
    }
    pub fn clear_public_latest_free_net_time(&mut self) {
        self.public_latest_free_net_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_public_latest_free_net_time(&mut self, v: i64) {
        self.public_latest_free_net_time = v;
    }
}

impl ::protobuf::Message for AssetIssueContract {
    fn is_initialized(&self) -> bool {
        for v in &self.frozen_supply {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                41 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.abbr)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.total_supply = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frozen_supply)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.trx_num = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.precision = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_time = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_time = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.order = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.vote_score = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.url)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.free_asset_net_limit = tmp;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.public_free_asset_net_limit = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.public_free_asset_net_usage = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.public_latest_free_net_time = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(41, &self.id);
        }
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.name);
        }
        if !self.abbr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.abbr);
        }
        if self.total_supply != 0 {
            my_size += ::protobuf::rt::value_size(4, self.total_supply, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.frozen_supply {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.trx_num != 0 {
            my_size += ::protobuf::rt::value_size(6, self.trx_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.precision != 0 {
            my_size += ::protobuf::rt::value_size(7, self.precision, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num != 0 {
            my_size += ::protobuf::rt::value_size(8, self.num, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_time != 0 {
            my_size += ::protobuf::rt::value_size(9, self.start_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_time != 0 {
            my_size += ::protobuf::rt::value_size(10, self.end_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.order != 0 {
            my_size += ::protobuf::rt::value_size(11, self.order, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vote_score != 0 {
            my_size += ::protobuf::rt::value_size(16, self.vote_score, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(20, &self.description);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(21, &self.url);
        }
        if self.free_asset_net_limit != 0 {
            my_size += ::protobuf::rt::value_size(22, self.free_asset_net_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.public_free_asset_net_limit != 0 {
            my_size += ::protobuf::rt::value_size(23, self.public_free_asset_net_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.public_free_asset_net_usage != 0 {
            my_size += ::protobuf::rt::value_size(24, self.public_free_asset_net_usage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.public_latest_free_net_time != 0 {
            my_size += ::protobuf::rt::value_size(25, self.public_latest_free_net_time, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(41, &self.id)?;
        }
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.name.is_empty() {
            os.write_bytes(2, &self.name)?;
        }
        if !self.abbr.is_empty() {
            os.write_bytes(3, &self.abbr)?;
        }
        if self.total_supply != 0 {
            os.write_int64(4, self.total_supply)?;
        }
        for v in &self.frozen_supply {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.trx_num != 0 {
            os.write_int32(6, self.trx_num)?;
        }
        if self.precision != 0 {
            os.write_int32(7, self.precision)?;
        }
        if self.num != 0 {
            os.write_int32(8, self.num)?;
        }
        if self.start_time != 0 {
            os.write_int64(9, self.start_time)?;
        }
        if self.end_time != 0 {
            os.write_int64(10, self.end_time)?;
        }
        if self.order != 0 {
            os.write_int64(11, self.order)?;
        }
        if self.vote_score != 0 {
            os.write_int32(16, self.vote_score)?;
        }
        if !self.description.is_empty() {
            os.write_bytes(20, &self.description)?;
        }
        if !self.url.is_empty() {
            os.write_bytes(21, &self.url)?;
        }
        if self.free_asset_net_limit != 0 {
            os.write_int64(22, self.free_asset_net_limit)?;
        }
        if self.public_free_asset_net_limit != 0 {
            os.write_int64(23, self.public_free_asset_net_limit)?;
        }
        if self.public_free_asset_net_usage != 0 {
            os.write_int64(24, self.public_free_asset_net_usage)?;
        }
        if self.public_latest_free_net_time != 0 {
            os.write_int64(25, self.public_latest_free_net_time)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetIssueContract {
        AssetIssueContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &AssetIssueContract| { &m.id },
                |m: &mut AssetIssueContract| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &AssetIssueContract| { &m.owner_address },
                |m: &mut AssetIssueContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &AssetIssueContract| { &m.name },
                |m: &mut AssetIssueContract| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "abbr",
                |m: &AssetIssueContract| { &m.abbr },
                |m: &mut AssetIssueContract| { &mut m.abbr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "total_supply",
                |m: &AssetIssueContract| { &m.total_supply },
                |m: &mut AssetIssueContract| { &mut m.total_supply },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AssetIssueContract_FrozenSupply>>(
                "frozen_supply",
                |m: &AssetIssueContract| { &m.frozen_supply },
                |m: &mut AssetIssueContract| { &mut m.frozen_supply },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "trx_num",
                |m: &AssetIssueContract| { &m.trx_num },
                |m: &mut AssetIssueContract| { &mut m.trx_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "precision",
                |m: &AssetIssueContract| { &m.precision },
                |m: &mut AssetIssueContract| { &mut m.precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num",
                |m: &AssetIssueContract| { &m.num },
                |m: &mut AssetIssueContract| { &mut m.num },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_time",
                |m: &AssetIssueContract| { &m.start_time },
                |m: &mut AssetIssueContract| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end_time",
                |m: &AssetIssueContract| { &m.end_time },
                |m: &mut AssetIssueContract| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "order",
                |m: &AssetIssueContract| { &m.order },
                |m: &mut AssetIssueContract| { &mut m.order },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "vote_score",
                |m: &AssetIssueContract| { &m.vote_score },
                |m: &mut AssetIssueContract| { &mut m.vote_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "description",
                |m: &AssetIssueContract| { &m.description },
                |m: &mut AssetIssueContract| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "url",
                |m: &AssetIssueContract| { &m.url },
                |m: &mut AssetIssueContract| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "free_asset_net_limit",
                |m: &AssetIssueContract| { &m.free_asset_net_limit },
                |m: &mut AssetIssueContract| { &mut m.free_asset_net_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "public_free_asset_net_limit",
                |m: &AssetIssueContract| { &m.public_free_asset_net_limit },
                |m: &mut AssetIssueContract| { &mut m.public_free_asset_net_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "public_free_asset_net_usage",
                |m: &AssetIssueContract| { &m.public_free_asset_net_usage },
                |m: &mut AssetIssueContract| { &mut m.public_free_asset_net_usage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "public_latest_free_net_time",
                |m: &AssetIssueContract| { &m.public_latest_free_net_time },
                |m: &mut AssetIssueContract| { &mut m.public_latest_free_net_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AssetIssueContract>(
                "AssetIssueContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetIssueContract {
        static instance: ::protobuf::rt::LazyV2<AssetIssueContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AssetIssueContract::new)
    }
}

impl ::protobuf::Clear for AssetIssueContract {
    fn clear(&mut self) {
        self.id.clear();
        self.owner_address.clear();
        self.name.clear();
        self.abbr.clear();
        self.total_supply = 0;
        self.frozen_supply.clear();
        self.trx_num = 0;
        self.precision = 0;
        self.num = 0;
        self.start_time = 0;
        self.end_time = 0;
        self.order = 0;
        self.vote_score = 0;
        self.description.clear();
        self.url.clear();
        self.free_asset_net_limit = 0;
        self.public_free_asset_net_limit = 0;
        self.public_free_asset_net_usage = 0;
        self.public_latest_free_net_time = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetIssueContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIssueContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AssetIssueContract_FrozenSupply {
    // message fields
    pub frozen_amount: i64,
    pub frozen_days: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AssetIssueContract_FrozenSupply {
    fn default() -> &'a AssetIssueContract_FrozenSupply {
        <AssetIssueContract_FrozenSupply as ::protobuf::Message>::default_instance()
    }
}

impl AssetIssueContract_FrozenSupply {
    pub fn new() -> AssetIssueContract_FrozenSupply {
        ::std::default::Default::default()
    }

    // int64 frozen_amount = 1;


    pub fn get_frozen_amount(&self) -> i64 {
        self.frozen_amount
    }
    pub fn clear_frozen_amount(&mut self) {
        self.frozen_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_amount(&mut self, v: i64) {
        self.frozen_amount = v;
    }

    // int64 frozen_days = 2;


    pub fn get_frozen_days(&self) -> i64 {
        self.frozen_days
    }
    pub fn clear_frozen_days(&mut self) {
        self.frozen_days = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_days(&mut self, v: i64) {
        self.frozen_days = v;
    }
}

impl ::protobuf::Message for AssetIssueContract_FrozenSupply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_amount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_days = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.frozen_amount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.frozen_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frozen_days != 0 {
            my_size += ::protobuf::rt::value_size(2, self.frozen_days, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.frozen_amount != 0 {
            os.write_int64(1, self.frozen_amount)?;
        }
        if self.frozen_days != 0 {
            os.write_int64(2, self.frozen_days)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssetIssueContract_FrozenSupply {
        AssetIssueContract_FrozenSupply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "frozen_amount",
                |m: &AssetIssueContract_FrozenSupply| { &m.frozen_amount },
                |m: &mut AssetIssueContract_FrozenSupply| { &mut m.frozen_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "frozen_days",
                |m: &AssetIssueContract_FrozenSupply| { &m.frozen_days },
                |m: &mut AssetIssueContract_FrozenSupply| { &mut m.frozen_days },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AssetIssueContract_FrozenSupply>(
                "AssetIssueContract.FrozenSupply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AssetIssueContract_FrozenSupply {
        static instance: ::protobuf::rt::LazyV2<AssetIssueContract_FrozenSupply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AssetIssueContract_FrozenSupply::new)
    }
}

impl ::protobuf::Clear for AssetIssueContract_FrozenSupply {
    fn clear(&mut self) {
        self.frozen_amount = 0;
        self.frozen_days = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssetIssueContract_FrozenSupply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssetIssueContract_FrozenSupply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ParticipateAssetIssueContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub to_address: ::std::vec::Vec<u8>,
    pub asset_name: ::std::vec::Vec<u8>,
    pub amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParticipateAssetIssueContract {
    fn default() -> &'a ParticipateAssetIssueContract {
        <ParticipateAssetIssueContract as ::protobuf::Message>::default_instance()
    }
}

impl ParticipateAssetIssueContract {
    pub fn new() -> ParticipateAssetIssueContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes to_address = 2;


    pub fn get_to_address(&self) -> &[u8] {
        &self.to_address
    }
    pub fn clear_to_address(&mut self) {
        self.to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to_address
    }

    // Take field
    pub fn take_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to_address, ::std::vec::Vec::new())
    }

    // bytes asset_name = 3;


    pub fn get_asset_name(&self) -> &[u8] {
        &self.asset_name
    }
    pub fn clear_asset_name(&mut self) {
        self.asset_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.asset_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.asset_name
    }

    // Take field
    pub fn take_asset_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.asset_name, ::std::vec::Vec::new())
    }

    // int64 amount = 4;


    pub fn get_amount(&self) -> i64 {
        self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = v;
    }
}

impl ::protobuf::Message for ParticipateAssetIssueContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to_address)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.asset_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to_address);
        }
        if !self.asset_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.asset_name);
        }
        if self.amount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(2, &self.to_address)?;
        }
        if !self.asset_name.is_empty() {
            os.write_bytes(3, &self.asset_name)?;
        }
        if self.amount != 0 {
            os.write_int64(4, self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParticipateAssetIssueContract {
        ParticipateAssetIssueContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ParticipateAssetIssueContract| { &m.owner_address },
                |m: &mut ParticipateAssetIssueContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "to_address",
                |m: &ParticipateAssetIssueContract| { &m.to_address },
                |m: &mut ParticipateAssetIssueContract| { &mut m.to_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "asset_name",
                |m: &ParticipateAssetIssueContract| { &m.asset_name },
                |m: &mut ParticipateAssetIssueContract| { &mut m.asset_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "amount",
                |m: &ParticipateAssetIssueContract| { &m.amount },
                |m: &mut ParticipateAssetIssueContract| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ParticipateAssetIssueContract>(
                "ParticipateAssetIssueContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ParticipateAssetIssueContract {
        static instance: ::protobuf::rt::LazyV2<ParticipateAssetIssueContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ParticipateAssetIssueContract::new)
    }
}

impl ::protobuf::Clear for ParticipateAssetIssueContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.to_address.clear();
        self.asset_name.clear();
        self.amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParticipateAssetIssueContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParticipateAssetIssueContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct FreezeBalanceContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub frozen_balance: i64,
    pub frozen_duration: i64,
    pub resource: ResourceCode,
    pub receiver_address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FreezeBalanceContract {
    fn default() -> &'a FreezeBalanceContract {
        <FreezeBalanceContract as ::protobuf::Message>::default_instance()
    }
}

impl FreezeBalanceContract {
    pub fn new() -> FreezeBalanceContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 frozen_balance = 2;


    pub fn get_frozen_balance(&self) -> i64 {
        self.frozen_balance
    }
    pub fn clear_frozen_balance(&mut self) {
        self.frozen_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_balance(&mut self, v: i64) {
        self.frozen_balance = v;
    }

    // int64 frozen_duration = 3;


    pub fn get_frozen_duration(&self) -> i64 {
        self.frozen_duration
    }
    pub fn clear_frozen_duration(&mut self) {
        self.frozen_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_duration(&mut self, v: i64) {
        self.frozen_duration = v;
    }

    // .protocol.ResourceCode resource = 10;


    pub fn get_resource(&self) -> ResourceCode {
        self.resource
    }
    pub fn clear_resource(&mut self) {
        self.resource = ResourceCode::BANDWIDTH;
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ResourceCode) {
        self.resource = v;
    }

    // bytes receiver_address = 15;


    pub fn get_receiver_address(&self) -> &[u8] {
        &self.receiver_address
    }
    pub fn clear_receiver_address(&mut self) {
        self.receiver_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.receiver_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receiver_address
    }

    // Take field
    pub fn take_receiver_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receiver_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FreezeBalanceContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_balance = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_duration = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.resource, 10, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receiver_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.frozen_balance != 0 {
            my_size += ::protobuf::rt::value_size(2, self.frozen_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frozen_duration != 0 {
            my_size += ::protobuf::rt::value_size(3, self.frozen_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.resource != ResourceCode::BANDWIDTH {
            my_size += ::protobuf::rt::enum_size(10, self.resource);
        }
        if !self.receiver_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.receiver_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.frozen_balance != 0 {
            os.write_int64(2, self.frozen_balance)?;
        }
        if self.frozen_duration != 0 {
            os.write_int64(3, self.frozen_duration)?;
        }
        if self.resource != ResourceCode::BANDWIDTH {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.resource))?;
        }
        if !self.receiver_address.is_empty() {
            os.write_bytes(15, &self.receiver_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FreezeBalanceContract {
        FreezeBalanceContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &FreezeBalanceContract| { &m.owner_address },
                |m: &mut FreezeBalanceContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "frozen_balance",
                |m: &FreezeBalanceContract| { &m.frozen_balance },
                |m: &mut FreezeBalanceContract| { &mut m.frozen_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "frozen_duration",
                |m: &FreezeBalanceContract| { &m.frozen_duration },
                |m: &mut FreezeBalanceContract| { &mut m.frozen_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResourceCode>>(
                "resource",
                |m: &FreezeBalanceContract| { &m.resource },
                |m: &mut FreezeBalanceContract| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "receiver_address",
                |m: &FreezeBalanceContract| { &m.receiver_address },
                |m: &mut FreezeBalanceContract| { &mut m.receiver_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FreezeBalanceContract>(
                "FreezeBalanceContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FreezeBalanceContract {
        static instance: ::protobuf::rt::LazyV2<FreezeBalanceContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FreezeBalanceContract::new)
    }
}

impl ::protobuf::Clear for FreezeBalanceContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.frozen_balance = 0;
        self.frozen_duration = 0;
        self.resource = ResourceCode::BANDWIDTH;
        self.receiver_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FreezeBalanceContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FreezeBalanceContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UnfreezeBalanceContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub resource: ResourceCode,
    pub receiver_address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnfreezeBalanceContract {
    fn default() -> &'a UnfreezeBalanceContract {
        <UnfreezeBalanceContract as ::protobuf::Message>::default_instance()
    }
}

impl UnfreezeBalanceContract {
    pub fn new() -> UnfreezeBalanceContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // .protocol.ResourceCode resource = 10;


    pub fn get_resource(&self) -> ResourceCode {
        self.resource
    }
    pub fn clear_resource(&mut self) {
        self.resource = ResourceCode::BANDWIDTH;
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ResourceCode) {
        self.resource = v;
    }

    // bytes receiver_address = 15;


    pub fn get_receiver_address(&self) -> &[u8] {
        &self.receiver_address
    }
    pub fn clear_receiver_address(&mut self) {
        self.receiver_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiver_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.receiver_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receiver_address
    }

    // Take field
    pub fn take_receiver_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receiver_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UnfreezeBalanceContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.resource, 10, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receiver_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.resource != ResourceCode::BANDWIDTH {
            my_size += ::protobuf::rt::enum_size(10, self.resource);
        }
        if !self.receiver_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.receiver_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.resource != ResourceCode::BANDWIDTH {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.resource))?;
        }
        if !self.receiver_address.is_empty() {
            os.write_bytes(15, &self.receiver_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnfreezeBalanceContract {
        UnfreezeBalanceContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &UnfreezeBalanceContract| { &m.owner_address },
                |m: &mut UnfreezeBalanceContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResourceCode>>(
                "resource",
                |m: &UnfreezeBalanceContract| { &m.resource },
                |m: &mut UnfreezeBalanceContract| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "receiver_address",
                |m: &UnfreezeBalanceContract| { &m.receiver_address },
                |m: &mut UnfreezeBalanceContract| { &mut m.receiver_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnfreezeBalanceContract>(
                "UnfreezeBalanceContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnfreezeBalanceContract {
        static instance: ::protobuf::rt::LazyV2<UnfreezeBalanceContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnfreezeBalanceContract::new)
    }
}

impl ::protobuf::Clear for UnfreezeBalanceContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.resource = ResourceCode::BANDWIDTH;
        self.receiver_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnfreezeBalanceContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnfreezeBalanceContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UnfreezeAssetContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnfreezeAssetContract {
    fn default() -> &'a UnfreezeAssetContract {
        <UnfreezeAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl UnfreezeAssetContract {
    pub fn new() -> UnfreezeAssetContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UnfreezeAssetContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnfreezeAssetContract {
        UnfreezeAssetContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &UnfreezeAssetContract| { &m.owner_address },
                |m: &mut UnfreezeAssetContract| { &mut m.owner_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnfreezeAssetContract>(
                "UnfreezeAssetContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnfreezeAssetContract {
        static instance: ::protobuf::rt::LazyV2<UnfreezeAssetContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnfreezeAssetContract::new)
    }
}

impl ::protobuf::Clear for UnfreezeAssetContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnfreezeAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnfreezeAssetContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WithdrawBalanceContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WithdrawBalanceContract {
    fn default() -> &'a WithdrawBalanceContract {
        <WithdrawBalanceContract as ::protobuf::Message>::default_instance()
    }
}

impl WithdrawBalanceContract {
    pub fn new() -> WithdrawBalanceContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WithdrawBalanceContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WithdrawBalanceContract {
        WithdrawBalanceContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &WithdrawBalanceContract| { &m.owner_address },
                |m: &mut WithdrawBalanceContract| { &mut m.owner_address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WithdrawBalanceContract>(
                "WithdrawBalanceContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WithdrawBalanceContract {
        static instance: ::protobuf::rt::LazyV2<WithdrawBalanceContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WithdrawBalanceContract::new)
    }
}

impl ::protobuf::Clear for WithdrawBalanceContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WithdrawBalanceContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WithdrawBalanceContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateAssetContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub description: ::std::vec::Vec<u8>,
    pub url: ::std::vec::Vec<u8>,
    pub new_limit: i64,
    pub new_public_limit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateAssetContract {
    fn default() -> &'a UpdateAssetContract {
        <UpdateAssetContract as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAssetContract {
    pub fn new() -> UpdateAssetContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes description = 2;


    pub fn get_description(&self) -> &[u8] {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::vec::Vec<u8>) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.description, ::std::vec::Vec::new())
    }

    // bytes url = 3;


    pub fn get_url(&self) -> &[u8] {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::vec::Vec<u8>) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.url, ::std::vec::Vec::new())
    }

    // int64 new_limit = 4;


    pub fn get_new_limit(&self) -> i64 {
        self.new_limit
    }
    pub fn clear_new_limit(&mut self) {
        self.new_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_limit(&mut self, v: i64) {
        self.new_limit = v;
    }

    // int64 new_public_limit = 5;


    pub fn get_new_public_limit(&self) -> i64 {
        self.new_public_limit
    }
    pub fn clear_new_public_limit(&mut self) {
        self.new_public_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_public_limit(&mut self, v: i64) {
        self.new_public_limit = v;
    }
}

impl ::protobuf::Message for UpdateAssetContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.url)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.new_limit = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.new_public_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.description);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.url);
        }
        if self.new_limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.new_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.new_public_limit != 0 {
            my_size += ::protobuf::rt::value_size(5, self.new_public_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.description.is_empty() {
            os.write_bytes(2, &self.description)?;
        }
        if !self.url.is_empty() {
            os.write_bytes(3, &self.url)?;
        }
        if self.new_limit != 0 {
            os.write_int64(4, self.new_limit)?;
        }
        if self.new_public_limit != 0 {
            os.write_int64(5, self.new_public_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAssetContract {
        UpdateAssetContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &UpdateAssetContract| { &m.owner_address },
                |m: &mut UpdateAssetContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "description",
                |m: &UpdateAssetContract| { &m.description },
                |m: &mut UpdateAssetContract| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "url",
                |m: &UpdateAssetContract| { &m.url },
                |m: &mut UpdateAssetContract| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "new_limit",
                |m: &UpdateAssetContract| { &m.new_limit },
                |m: &mut UpdateAssetContract| { &mut m.new_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "new_public_limit",
                |m: &UpdateAssetContract| { &m.new_public_limit },
                |m: &mut UpdateAssetContract| { &mut m.new_public_limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateAssetContract>(
                "UpdateAssetContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateAssetContract {
        static instance: ::protobuf::rt::LazyV2<UpdateAssetContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateAssetContract::new)
    }
}

impl ::protobuf::Clear for UpdateAssetContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.description.clear();
        self.url.clear();
        self.new_limit = 0;
        self.new_public_limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateAssetContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAssetContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ProposalCreateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub parameters: ::std::collections::HashMap<i64, i64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalCreateContract {
    fn default() -> &'a ProposalCreateContract {
        <ProposalCreateContract as ::protobuf::Message>::default_instance()
    }
}

impl ProposalCreateContract {
    pub fn new() -> ProposalCreateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // repeated .protocol.ProposalCreateContract.ParametersEntry parameters = 2;


    pub fn get_parameters(&self) -> &::std::collections::HashMap<i64, i64> {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::std::collections::HashMap<i64, i64>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::std::collections::HashMap<i64, i64> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::std::collections::HashMap<i64, i64> {
        ::std::mem::replace(&mut self.parameters, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ProposalCreateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(2, &self.parameters);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(2, &self.parameters, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalCreateContract {
        ProposalCreateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ProposalCreateContract| { &m.owner_address },
                |m: &mut ProposalCreateContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt64>(
                "parameters",
                |m: &ProposalCreateContract| { &m.parameters },
                |m: &mut ProposalCreateContract| { &mut m.parameters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProposalCreateContract>(
                "ProposalCreateContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProposalCreateContract {
        static instance: ::protobuf::rt::LazyV2<ProposalCreateContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProposalCreateContract::new)
    }
}

impl ::protobuf::Clear for ProposalCreateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalCreateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalCreateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ProposalApproveContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub proposal_id: i64,
    pub is_add_approval: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalApproveContract {
    fn default() -> &'a ProposalApproveContract {
        <ProposalApproveContract as ::protobuf::Message>::default_instance()
    }
}

impl ProposalApproveContract {
    pub fn new() -> ProposalApproveContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 proposal_id = 2;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }

    // bool is_add_approval = 3;


    pub fn get_is_add_approval(&self) -> bool {
        self.is_add_approval
    }
    pub fn clear_is_add_approval(&mut self) {
        self.is_add_approval = false;
    }

    // Param is passed by value, moved
    pub fn set_is_add_approval(&mut self, v: bool) {
        self.is_add_approval = v;
    }
}

impl ::protobuf::Message for ProposalApproveContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.proposal_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_add_approval = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.proposal_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_add_approval != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.proposal_id != 0 {
            os.write_int64(2, self.proposal_id)?;
        }
        if self.is_add_approval != false {
            os.write_bool(3, self.is_add_approval)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalApproveContract {
        ProposalApproveContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ProposalApproveContract| { &m.owner_address },
                |m: &mut ProposalApproveContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "proposal_id",
                |m: &ProposalApproveContract| { &m.proposal_id },
                |m: &mut ProposalApproveContract| { &mut m.proposal_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_add_approval",
                |m: &ProposalApproveContract| { &m.is_add_approval },
                |m: &mut ProposalApproveContract| { &mut m.is_add_approval },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProposalApproveContract>(
                "ProposalApproveContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProposalApproveContract {
        static instance: ::protobuf::rt::LazyV2<ProposalApproveContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProposalApproveContract::new)
    }
}

impl ::protobuf::Clear for ProposalApproveContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.proposal_id = 0;
        self.is_add_approval = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalApproveContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalApproveContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ProposalDeleteContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub proposal_id: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProposalDeleteContract {
    fn default() -> &'a ProposalDeleteContract {
        <ProposalDeleteContract as ::protobuf::Message>::default_instance()
    }
}

impl ProposalDeleteContract {
    pub fn new() -> ProposalDeleteContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 proposal_id = 2;


    pub fn get_proposal_id(&self) -> i64 {
        self.proposal_id
    }
    pub fn clear_proposal_id(&mut self) {
        self.proposal_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposal_id(&mut self, v: i64) {
        self.proposal_id = v;
    }
}

impl ::protobuf::Message for ProposalDeleteContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.proposal_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.proposal_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.proposal_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.proposal_id != 0 {
            os.write_int64(2, self.proposal_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProposalDeleteContract {
        ProposalDeleteContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ProposalDeleteContract| { &m.owner_address },
                |m: &mut ProposalDeleteContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "proposal_id",
                |m: &ProposalDeleteContract| { &m.proposal_id },
                |m: &mut ProposalDeleteContract| { &mut m.proposal_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProposalDeleteContract>(
                "ProposalDeleteContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProposalDeleteContract {
        static instance: ::protobuf::rt::LazyV2<ProposalDeleteContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProposalDeleteContract::new)
    }
}

impl ::protobuf::Clear for ProposalDeleteContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.proposal_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProposalDeleteContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProposalDeleteContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CreateSmartContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub new_contract: ::protobuf::SingularPtrField<super::Tron::SmartContract>,
    pub call_token_value: i64,
    pub token_id: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSmartContract {
    fn default() -> &'a CreateSmartContract {
        <CreateSmartContract as ::protobuf::Message>::default_instance()
    }
}

impl CreateSmartContract {
    pub fn new() -> CreateSmartContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // .protocol.SmartContract new_contract = 2;


    pub fn get_new_contract(&self) -> &super::Tron::SmartContract {
        self.new_contract.as_ref().unwrap_or_else(|| <super::Tron::SmartContract as ::protobuf::Message>::default_instance())
    }
    pub fn clear_new_contract(&mut self) {
        self.new_contract.clear();
    }

    pub fn has_new_contract(&self) -> bool {
        self.new_contract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_contract(&mut self, v: super::Tron::SmartContract) {
        self.new_contract = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_contract(&mut self) -> &mut super::Tron::SmartContract {
        if self.new_contract.is_none() {
            self.new_contract.set_default();
        }
        self.new_contract.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_contract(&mut self) -> super::Tron::SmartContract {
        self.new_contract.take().unwrap_or_else(|| super::Tron::SmartContract::new())
    }

    // int64 call_token_value = 3;


    pub fn get_call_token_value(&self) -> i64 {
        self.call_token_value
    }
    pub fn clear_call_token_value(&mut self) {
        self.call_token_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_token_value(&mut self, v: i64) {
        self.call_token_value = v;
    }

    // int64 token_id = 4;


    pub fn get_token_id(&self) -> i64 {
        self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: i64) {
        self.token_id = v;
    }
}

impl ::protobuf::Message for CreateSmartContract {
    fn is_initialized(&self) -> bool {
        for v in &self.new_contract {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.new_contract)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_token_value = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.token_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if let Some(ref v) = self.new_contract.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.call_token_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.call_token_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.token_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.token_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if let Some(ref v) = self.new_contract.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.call_token_value != 0 {
            os.write_int64(3, self.call_token_value)?;
        }
        if self.token_id != 0 {
            os.write_int64(4, self.token_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSmartContract {
        CreateSmartContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &CreateSmartContract| { &m.owner_address },
                |m: &mut CreateSmartContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::SmartContract>>(
                "new_contract",
                |m: &CreateSmartContract| { &m.new_contract },
                |m: &mut CreateSmartContract| { &mut m.new_contract },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "call_token_value",
                |m: &CreateSmartContract| { &m.call_token_value },
                |m: &mut CreateSmartContract| { &mut m.call_token_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "token_id",
                |m: &CreateSmartContract| { &m.token_id },
                |m: &mut CreateSmartContract| { &mut m.token_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSmartContract>(
                "CreateSmartContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSmartContract {
        static instance: ::protobuf::rt::LazyV2<CreateSmartContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSmartContract::new)
    }
}

impl ::protobuf::Clear for CreateSmartContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.new_contract.clear();
        self.call_token_value = 0;
        self.token_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSmartContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSmartContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TriggerSmartContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub contract_address: ::std::vec::Vec<u8>,
    pub call_value: i64,
    pub data: ::std::vec::Vec<u8>,
    pub call_token_value: i64,
    pub token_id: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TriggerSmartContract {
    fn default() -> &'a TriggerSmartContract {
        <TriggerSmartContract as ::protobuf::Message>::default_instance()
    }
}

impl TriggerSmartContract {
    pub fn new() -> TriggerSmartContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes contract_address = 2;


    pub fn get_contract_address(&self) -> &[u8] {
        &self.contract_address
    }
    pub fn clear_contract_address(&mut self) {
        self.contract_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract_address
    }

    // Take field
    pub fn take_contract_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract_address, ::std::vec::Vec::new())
    }

    // int64 call_value = 3;


    pub fn get_call_value(&self) -> i64 {
        self.call_value
    }
    pub fn clear_call_value(&mut self) {
        self.call_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_value(&mut self, v: i64) {
        self.call_value = v;
    }

    // bytes data = 4;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // int64 call_token_value = 5;


    pub fn get_call_token_value(&self) -> i64 {
        self.call_token_value
    }
    pub fn clear_call_token_value(&mut self) {
        self.call_token_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_token_value(&mut self, v: i64) {
        self.call_token_value = v;
    }

    // int64 token_id = 6;


    pub fn get_token_id(&self) -> i64 {
        self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: i64) {
        self.token_id = v;
    }
}

impl ::protobuf::Message for TriggerSmartContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract_address)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_value = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_token_value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.token_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.contract_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contract_address);
        }
        if self.call_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.call_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if self.call_token_value != 0 {
            my_size += ::protobuf::rt::value_size(5, self.call_token_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.token_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.token_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.contract_address.is_empty() {
            os.write_bytes(2, &self.contract_address)?;
        }
        if self.call_value != 0 {
            os.write_int64(3, self.call_value)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if self.call_token_value != 0 {
            os.write_int64(5, self.call_token_value)?;
        }
        if self.token_id != 0 {
            os.write_int64(6, self.token_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TriggerSmartContract {
        TriggerSmartContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &TriggerSmartContract| { &m.owner_address },
                |m: &mut TriggerSmartContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "contract_address",
                |m: &TriggerSmartContract| { &m.contract_address },
                |m: &mut TriggerSmartContract| { &mut m.contract_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "call_value",
                |m: &TriggerSmartContract| { &m.call_value },
                |m: &mut TriggerSmartContract| { &mut m.call_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &TriggerSmartContract| { &m.data },
                |m: &mut TriggerSmartContract| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "call_token_value",
                |m: &TriggerSmartContract| { &m.call_token_value },
                |m: &mut TriggerSmartContract| { &mut m.call_token_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "token_id",
                |m: &TriggerSmartContract| { &m.token_id },
                |m: &mut TriggerSmartContract| { &mut m.token_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TriggerSmartContract>(
                "TriggerSmartContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TriggerSmartContract {
        static instance: ::protobuf::rt::LazyV2<TriggerSmartContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TriggerSmartContract::new)
    }
}

impl ::protobuf::Clear for TriggerSmartContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.contract_address.clear();
        self.call_value = 0;
        self.data.clear();
        self.call_token_value = 0;
        self.token_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TriggerSmartContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TriggerSmartContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BuyStorageContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub quant: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyStorageContract {
    fn default() -> &'a BuyStorageContract {
        <BuyStorageContract as ::protobuf::Message>::default_instance()
    }
}

impl BuyStorageContract {
    pub fn new() -> BuyStorageContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 quant = 2;


    pub fn get_quant(&self) -> i64 {
        self.quant
    }
    pub fn clear_quant(&mut self) {
        self.quant = 0;
    }

    // Param is passed by value, moved
    pub fn set_quant(&mut self, v: i64) {
        self.quant = v;
    }
}

impl ::protobuf::Message for BuyStorageContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quant = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.quant != 0 {
            my_size += ::protobuf::rt::value_size(2, self.quant, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.quant != 0 {
            os.write_int64(2, self.quant)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyStorageContract {
        BuyStorageContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &BuyStorageContract| { &m.owner_address },
                |m: &mut BuyStorageContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "quant",
                |m: &BuyStorageContract| { &m.quant },
                |m: &mut BuyStorageContract| { &mut m.quant },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuyStorageContract>(
                "BuyStorageContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyStorageContract {
        static instance: ::protobuf::rt::LazyV2<BuyStorageContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuyStorageContract::new)
    }
}

impl ::protobuf::Clear for BuyStorageContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.quant = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyStorageContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyStorageContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BuyStorageBytesContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub bytes: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BuyStorageBytesContract {
    fn default() -> &'a BuyStorageBytesContract {
        <BuyStorageBytesContract as ::protobuf::Message>::default_instance()
    }
}

impl BuyStorageBytesContract {
    pub fn new() -> BuyStorageBytesContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 bytes = 2;


    pub fn get_bytes(&self) -> i64 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i64) {
        self.bytes = v;
    }
}

impl ::protobuf::Message for BuyStorageBytesContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.bytes != 0 {
            os.write_int64(2, self.bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BuyStorageBytesContract {
        BuyStorageBytesContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &BuyStorageBytesContract| { &m.owner_address },
                |m: &mut BuyStorageBytesContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bytes",
                |m: &BuyStorageBytesContract| { &m.bytes },
                |m: &mut BuyStorageBytesContract| { &mut m.bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BuyStorageBytesContract>(
                "BuyStorageBytesContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BuyStorageBytesContract {
        static instance: ::protobuf::rt::LazyV2<BuyStorageBytesContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BuyStorageBytesContract::new)
    }
}

impl ::protobuf::Clear for BuyStorageBytesContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BuyStorageBytesContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuyStorageBytesContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SellStorageContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub storage_bytes: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SellStorageContract {
    fn default() -> &'a SellStorageContract {
        <SellStorageContract as ::protobuf::Message>::default_instance()
    }
}

impl SellStorageContract {
    pub fn new() -> SellStorageContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 storage_bytes = 2;


    pub fn get_storage_bytes(&self) -> i64 {
        self.storage_bytes
    }
    pub fn clear_storage_bytes(&mut self) {
        self.storage_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_storage_bytes(&mut self, v: i64) {
        self.storage_bytes = v;
    }
}

impl ::protobuf::Message for SellStorageContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.storage_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.storage_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.storage_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.storage_bytes != 0 {
            os.write_int64(2, self.storage_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SellStorageContract {
        SellStorageContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &SellStorageContract| { &m.owner_address },
                |m: &mut SellStorageContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "storage_bytes",
                |m: &SellStorageContract| { &m.storage_bytes },
                |m: &mut SellStorageContract| { &mut m.storage_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SellStorageContract>(
                "SellStorageContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SellStorageContract {
        static instance: ::protobuf::rt::LazyV2<SellStorageContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SellStorageContract::new)
    }
}

impl ::protobuf::Clear for SellStorageContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.storage_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SellStorageContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SellStorageContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExchangeCreateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub first_token_id: ::std::vec::Vec<u8>,
    pub first_token_balance: i64,
    pub second_token_id: ::std::vec::Vec<u8>,
    pub second_token_balance: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeCreateContract {
    fn default() -> &'a ExchangeCreateContract {
        <ExchangeCreateContract as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeCreateContract {
    pub fn new() -> ExchangeCreateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // bytes first_token_id = 2;


    pub fn get_first_token_id(&self) -> &[u8] {
        &self.first_token_id
    }
    pub fn clear_first_token_id(&mut self) {
        self.first_token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_first_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.first_token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.first_token_id
    }

    // Take field
    pub fn take_first_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.first_token_id, ::std::vec::Vec::new())
    }

    // int64 first_token_balance = 3;


    pub fn get_first_token_balance(&self) -> i64 {
        self.first_token_balance
    }
    pub fn clear_first_token_balance(&mut self) {
        self.first_token_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_token_balance(&mut self, v: i64) {
        self.first_token_balance = v;
    }

    // bytes second_token_id = 4;


    pub fn get_second_token_id(&self) -> &[u8] {
        &self.second_token_id
    }
    pub fn clear_second_token_id(&mut self) {
        self.second_token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_second_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.second_token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_second_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.second_token_id
    }

    // Take field
    pub fn take_second_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.second_token_id, ::std::vec::Vec::new())
    }

    // int64 second_token_balance = 5;


    pub fn get_second_token_balance(&self) -> i64 {
        self.second_token_balance
    }
    pub fn clear_second_token_balance(&mut self) {
        self.second_token_balance = 0;
    }

    // Param is passed by value, moved
    pub fn set_second_token_balance(&mut self, v: i64) {
        self.second_token_balance = v;
    }
}

impl ::protobuf::Message for ExchangeCreateContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.first_token_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.first_token_balance = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.second_token_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.second_token_balance = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if !self.first_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.first_token_id);
        }
        if self.first_token_balance != 0 {
            my_size += ::protobuf::rt::value_size(3, self.first_token_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.second_token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.second_token_id);
        }
        if self.second_token_balance != 0 {
            my_size += ::protobuf::rt::value_size(5, self.second_token_balance, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if !self.first_token_id.is_empty() {
            os.write_bytes(2, &self.first_token_id)?;
        }
        if self.first_token_balance != 0 {
            os.write_int64(3, self.first_token_balance)?;
        }
        if !self.second_token_id.is_empty() {
            os.write_bytes(4, &self.second_token_id)?;
        }
        if self.second_token_balance != 0 {
            os.write_int64(5, self.second_token_balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeCreateContract {
        ExchangeCreateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ExchangeCreateContract| { &m.owner_address },
                |m: &mut ExchangeCreateContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "first_token_id",
                |m: &ExchangeCreateContract| { &m.first_token_id },
                |m: &mut ExchangeCreateContract| { &mut m.first_token_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "first_token_balance",
                |m: &ExchangeCreateContract| { &m.first_token_balance },
                |m: &mut ExchangeCreateContract| { &mut m.first_token_balance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "second_token_id",
                |m: &ExchangeCreateContract| { &m.second_token_id },
                |m: &mut ExchangeCreateContract| { &mut m.second_token_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "second_token_balance",
                |m: &ExchangeCreateContract| { &m.second_token_balance },
                |m: &mut ExchangeCreateContract| { &mut m.second_token_balance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExchangeCreateContract>(
                "ExchangeCreateContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExchangeCreateContract {
        static instance: ::protobuf::rt::LazyV2<ExchangeCreateContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExchangeCreateContract::new)
    }
}

impl ::protobuf::Clear for ExchangeCreateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.first_token_id.clear();
        self.first_token_balance = 0;
        self.second_token_id.clear();
        self.second_token_balance = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeCreateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeCreateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExchangeInjectContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub exchange_id: i64,
    pub token_id: ::std::vec::Vec<u8>,
    pub quant: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeInjectContract {
    fn default() -> &'a ExchangeInjectContract {
        <ExchangeInjectContract as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeInjectContract {
    pub fn new() -> ExchangeInjectContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 exchange_id = 2;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // bytes token_id = 3;


    pub fn get_token_id(&self) -> &[u8] {
        &self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.token_id
    }

    // Take field
    pub fn take_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.token_id, ::std::vec::Vec::new())
    }

    // int64 quant = 4;


    pub fn get_quant(&self) -> i64 {
        self.quant
    }
    pub fn clear_quant(&mut self) {
        self.quant = 0;
    }

    // Param is passed by value, moved
    pub fn set_quant(&mut self, v: i64) {
        self.quant = v;
    }
}

impl ::protobuf::Message for ExchangeInjectContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.token_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quant = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token_id);
        }
        if self.quant != 0 {
            my_size += ::protobuf::rt::value_size(4, self.quant, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(2, self.exchange_id)?;
        }
        if !self.token_id.is_empty() {
            os.write_bytes(3, &self.token_id)?;
        }
        if self.quant != 0 {
            os.write_int64(4, self.quant)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeInjectContract {
        ExchangeInjectContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ExchangeInjectContract| { &m.owner_address },
                |m: &mut ExchangeInjectContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_id",
                |m: &ExchangeInjectContract| { &m.exchange_id },
                |m: &mut ExchangeInjectContract| { &mut m.exchange_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token_id",
                |m: &ExchangeInjectContract| { &m.token_id },
                |m: &mut ExchangeInjectContract| { &mut m.token_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "quant",
                |m: &ExchangeInjectContract| { &m.quant },
                |m: &mut ExchangeInjectContract| { &mut m.quant },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExchangeInjectContract>(
                "ExchangeInjectContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExchangeInjectContract {
        static instance: ::protobuf::rt::LazyV2<ExchangeInjectContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExchangeInjectContract::new)
    }
}

impl ::protobuf::Clear for ExchangeInjectContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.exchange_id = 0;
        self.token_id.clear();
        self.quant = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeInjectContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeInjectContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExchangeWithdrawContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub exchange_id: i64,
    pub token_id: ::std::vec::Vec<u8>,
    pub quant: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeWithdrawContract {
    fn default() -> &'a ExchangeWithdrawContract {
        <ExchangeWithdrawContract as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeWithdrawContract {
    pub fn new() -> ExchangeWithdrawContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 exchange_id = 2;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // bytes token_id = 3;


    pub fn get_token_id(&self) -> &[u8] {
        &self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.token_id
    }

    // Take field
    pub fn take_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.token_id, ::std::vec::Vec::new())
    }

    // int64 quant = 4;


    pub fn get_quant(&self) -> i64 {
        self.quant
    }
    pub fn clear_quant(&mut self) {
        self.quant = 0;
    }

    // Param is passed by value, moved
    pub fn set_quant(&mut self, v: i64) {
        self.quant = v;
    }
}

impl ::protobuf::Message for ExchangeWithdrawContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.token_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quant = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token_id);
        }
        if self.quant != 0 {
            my_size += ::protobuf::rt::value_size(4, self.quant, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(2, self.exchange_id)?;
        }
        if !self.token_id.is_empty() {
            os.write_bytes(3, &self.token_id)?;
        }
        if self.quant != 0 {
            os.write_int64(4, self.quant)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeWithdrawContract {
        ExchangeWithdrawContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ExchangeWithdrawContract| { &m.owner_address },
                |m: &mut ExchangeWithdrawContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_id",
                |m: &ExchangeWithdrawContract| { &m.exchange_id },
                |m: &mut ExchangeWithdrawContract| { &mut m.exchange_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token_id",
                |m: &ExchangeWithdrawContract| { &m.token_id },
                |m: &mut ExchangeWithdrawContract| { &mut m.token_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "quant",
                |m: &ExchangeWithdrawContract| { &m.quant },
                |m: &mut ExchangeWithdrawContract| { &mut m.quant },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExchangeWithdrawContract>(
                "ExchangeWithdrawContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExchangeWithdrawContract {
        static instance: ::protobuf::rt::LazyV2<ExchangeWithdrawContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExchangeWithdrawContract::new)
    }
}

impl ::protobuf::Clear for ExchangeWithdrawContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.exchange_id = 0;
        self.token_id.clear();
        self.quant = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeWithdrawContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeWithdrawContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ExchangeTransactionContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub exchange_id: i64,
    pub token_id: ::std::vec::Vec<u8>,
    pub quant: i64,
    pub expected: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExchangeTransactionContract {
    fn default() -> &'a ExchangeTransactionContract {
        <ExchangeTransactionContract as ::protobuf::Message>::default_instance()
    }
}

impl ExchangeTransactionContract {
    pub fn new() -> ExchangeTransactionContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int64 exchange_id = 2;


    pub fn get_exchange_id(&self) -> i64 {
        self.exchange_id
    }
    pub fn clear_exchange_id(&mut self) {
        self.exchange_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_exchange_id(&mut self, v: i64) {
        self.exchange_id = v;
    }

    // bytes token_id = 3;


    pub fn get_token_id(&self) -> &[u8] {
        &self.token_id
    }
    pub fn clear_token_id(&mut self) {
        self.token_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.token_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.token_id
    }

    // Take field
    pub fn take_token_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.token_id, ::std::vec::Vec::new())
    }

    // int64 quant = 4;


    pub fn get_quant(&self) -> i64 {
        self.quant
    }
    pub fn clear_quant(&mut self) {
        self.quant = 0;
    }

    // Param is passed by value, moved
    pub fn set_quant(&mut self, v: i64) {
        self.quant = v;
    }

    // int64 expected = 5;


    pub fn get_expected(&self) -> i64 {
        self.expected
    }
    pub fn clear_expected(&mut self) {
        self.expected = 0;
    }

    // Param is passed by value, moved
    pub fn set_expected(&mut self, v: i64) {
        self.expected = v;
    }
}

impl ::protobuf::Message for ExchangeTransactionContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.exchange_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.token_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.quant = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expected = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.exchange_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.exchange_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.token_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.token_id);
        }
        if self.quant != 0 {
            my_size += ::protobuf::rt::value_size(4, self.quant, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.expected != 0 {
            my_size += ::protobuf::rt::value_size(5, self.expected, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.exchange_id != 0 {
            os.write_int64(2, self.exchange_id)?;
        }
        if !self.token_id.is_empty() {
            os.write_bytes(3, &self.token_id)?;
        }
        if self.quant != 0 {
            os.write_int64(4, self.quant)?;
        }
        if self.expected != 0 {
            os.write_int64(5, self.expected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExchangeTransactionContract {
        ExchangeTransactionContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &ExchangeTransactionContract| { &m.owner_address },
                |m: &mut ExchangeTransactionContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "exchange_id",
                |m: &ExchangeTransactionContract| { &m.exchange_id },
                |m: &mut ExchangeTransactionContract| { &mut m.exchange_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token_id",
                |m: &ExchangeTransactionContract| { &m.token_id },
                |m: &mut ExchangeTransactionContract| { &mut m.token_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "quant",
                |m: &ExchangeTransactionContract| { &m.quant },
                |m: &mut ExchangeTransactionContract| { &mut m.quant },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expected",
                |m: &ExchangeTransactionContract| { &m.expected },
                |m: &mut ExchangeTransactionContract| { &mut m.expected },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExchangeTransactionContract>(
                "ExchangeTransactionContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExchangeTransactionContract {
        static instance: ::protobuf::rt::LazyV2<ExchangeTransactionContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExchangeTransactionContract::new)
    }
}

impl ::protobuf::Clear for ExchangeTransactionContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.exchange_id = 0;
        self.token_id.clear();
        self.quant = 0;
        self.expected = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExchangeTransactionContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExchangeTransactionContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AccountPermissionUpdateContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub owner: ::protobuf::SingularPtrField<super::Tron::Permission>,
    pub witness: ::protobuf::SingularPtrField<super::Tron::Permission>,
    pub actives: ::protobuf::RepeatedField<super::Tron::Permission>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AccountPermissionUpdateContract {
    fn default() -> &'a AccountPermissionUpdateContract {
        <AccountPermissionUpdateContract as ::protobuf::Message>::default_instance()
    }
}

impl AccountPermissionUpdateContract {
    pub fn new() -> AccountPermissionUpdateContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // .protocol.Permission owner = 2;


    pub fn get_owner(&self) -> &super::Tron::Permission {
        self.owner.as_ref().unwrap_or_else(|| <super::Tron::Permission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: super::Tron::Permission) {
        self.owner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut super::Tron::Permission {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> super::Tron::Permission {
        self.owner.take().unwrap_or_else(|| super::Tron::Permission::new())
    }

    // .protocol.Permission witness = 3;


    pub fn get_witness(&self) -> &super::Tron::Permission {
        self.witness.as_ref().unwrap_or_else(|| <super::Tron::Permission as ::protobuf::Message>::default_instance())
    }
    pub fn clear_witness(&mut self) {
        self.witness.clear();
    }

    pub fn has_witness(&self) -> bool {
        self.witness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_witness(&mut self, v: super::Tron::Permission) {
        self.witness = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_witness(&mut self) -> &mut super::Tron::Permission {
        if self.witness.is_none() {
            self.witness.set_default();
        }
        self.witness.as_mut().unwrap()
    }

    // Take field
    pub fn take_witness(&mut self) -> super::Tron::Permission {
        self.witness.take().unwrap_or_else(|| super::Tron::Permission::new())
    }

    // repeated .protocol.Permission actives = 4;


    pub fn get_actives(&self) -> &[super::Tron::Permission] {
        &self.actives
    }
    pub fn clear_actives(&mut self) {
        self.actives.clear();
    }

    // Param is passed by value, moved
    pub fn set_actives(&mut self, v: ::protobuf::RepeatedField<super::Tron::Permission>) {
        self.actives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actives(&mut self) -> &mut ::protobuf::RepeatedField<super::Tron::Permission> {
        &mut self.actives
    }

    // Take field
    pub fn take_actives(&mut self) -> ::protobuf::RepeatedField<super::Tron::Permission> {
        ::std::mem::replace(&mut self.actives, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AccountPermissionUpdateContract {
    fn is_initialized(&self) -> bool {
        for v in &self.owner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.witness {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actives {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.witness)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actives)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if let Some(ref v) = self.owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.witness.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.actives {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.witness.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.actives {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountPermissionUpdateContract {
        AccountPermissionUpdateContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &AccountPermissionUpdateContract| { &m.owner_address },
                |m: &mut AccountPermissionUpdateContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Permission>>(
                "owner",
                |m: &AccountPermissionUpdateContract| { &m.owner },
                |m: &mut AccountPermissionUpdateContract| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Permission>>(
                "witness",
                |m: &AccountPermissionUpdateContract| { &m.witness },
                |m: &mut AccountPermissionUpdateContract| { &mut m.witness },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Tron::Permission>>(
                "actives",
                |m: &AccountPermissionUpdateContract| { &m.actives },
                |m: &mut AccountPermissionUpdateContract| { &mut m.actives },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AccountPermissionUpdateContract>(
                "AccountPermissionUpdateContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AccountPermissionUpdateContract {
        static instance: ::protobuf::rt::LazyV2<AccountPermissionUpdateContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AccountPermissionUpdateContract::new)
    }
}

impl ::protobuf::Clear for AccountPermissionUpdateContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.owner.clear();
        self.witness.clear();
        self.actives.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountPermissionUpdateContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountPermissionUpdateContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AuthenticationPath {
    // message fields
    pub value: ::std::vec::Vec<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticationPath {
    fn default() -> &'a AuthenticationPath {
        <AuthenticationPath as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticationPath {
    pub fn new() -> AuthenticationPath {
        ::std::default::Default::default()
    }

    // repeated bool value = 1;


    pub fn get_value(&self) -> &[bool] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<bool>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AuthenticationPath {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 2 * self.value.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_bool(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticationPath {
        AuthenticationPath::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "value",
                |m: &AuthenticationPath| { &m.value },
                |m: &mut AuthenticationPath| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthenticationPath>(
                "AuthenticationPath",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticationPath {
        static instance: ::protobuf::rt::LazyV2<AuthenticationPath> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticationPath::new)
    }
}

impl ::protobuf::Clear for AuthenticationPath {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticationPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticationPath {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct MerklePath {
    // message fields
    pub authentication_paths: ::protobuf::RepeatedField<AuthenticationPath>,
    pub index: ::std::vec::Vec<bool>,
    pub rt: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MerklePath {
    fn default() -> &'a MerklePath {
        <MerklePath as ::protobuf::Message>::default_instance()
    }
}

impl MerklePath {
    pub fn new() -> MerklePath {
        ::std::default::Default::default()
    }

    // repeated .protocol.AuthenticationPath authentication_paths = 1;


    pub fn get_authentication_paths(&self) -> &[AuthenticationPath] {
        &self.authentication_paths
    }
    pub fn clear_authentication_paths(&mut self) {
        self.authentication_paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_authentication_paths(&mut self, v: ::protobuf::RepeatedField<AuthenticationPath>) {
        self.authentication_paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authentication_paths(&mut self) -> &mut ::protobuf::RepeatedField<AuthenticationPath> {
        &mut self.authentication_paths
    }

    // Take field
    pub fn take_authentication_paths(&mut self) -> ::protobuf::RepeatedField<AuthenticationPath> {
        ::std::mem::replace(&mut self.authentication_paths, ::protobuf::RepeatedField::new())
    }

    // repeated bool index = 2;


    pub fn get_index(&self) -> &[bool] {
        &self.index
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: ::std::vec::Vec<bool>) {
        self.index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_index(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.index
    }

    // Take field
    pub fn take_index(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.index, ::std::vec::Vec::new())
    }

    // bytes rt = 3;


    pub fn get_rt(&self) -> &[u8] {
        &self.rt
    }
    pub fn clear_rt(&mut self) {
        self.rt.clear();
    }

    // Param is passed by value, moved
    pub fn set_rt(&mut self, v: ::std::vec::Vec<u8>) {
        self.rt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.rt
    }

    // Take field
    pub fn take_rt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.rt, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MerklePath {
    fn is_initialized(&self) -> bool {
        for v in &self.authentication_paths {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.authentication_paths)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.index)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.rt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.authentication_paths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 2 * self.index.len() as u32;
        if !self.rt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.rt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.authentication_paths {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.index {
            os.write_bool(2, *v)?;
        };
        if !self.rt.is_empty() {
            os.write_bytes(3, &self.rt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MerklePath {
        MerklePath::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthenticationPath>>(
                "authentication_paths",
                |m: &MerklePath| { &m.authentication_paths },
                |m: &mut MerklePath| { &mut m.authentication_paths },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "index",
                |m: &MerklePath| { &m.index },
                |m: &mut MerklePath| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rt",
                |m: &MerklePath| { &m.rt },
                |m: &mut MerklePath| { &mut m.rt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MerklePath>(
                "MerklePath",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MerklePath {
        static instance: ::protobuf::rt::LazyV2<MerklePath> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MerklePath::new)
    }
}

impl ::protobuf::Clear for MerklePath {
    fn clear(&mut self) {
        self.authentication_paths.clear();
        self.index.clear();
        self.rt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MerklePath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerklePath {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct OutputPoint {
    // message fields
    pub hash: ::std::vec::Vec<u8>,
    pub index: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputPoint {
    fn default() -> &'a OutputPoint {
        <OutputPoint as ::protobuf::Message>::default_instance()
    }
}

impl OutputPoint {
    pub fn new() -> OutputPoint {
        ::std::default::Default::default()
    }

    // bytes hash = 1;


    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    // int32 index = 2;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }
}

impl ::protobuf::Message for OutputPoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if self.index != 0 {
            os.write_int32(2, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputPoint {
        OutputPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &OutputPoint| { &m.hash },
                |m: &mut OutputPoint| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &OutputPoint| { &m.index },
                |m: &mut OutputPoint| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputPoint>(
                "OutputPoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputPoint {
        static instance: ::protobuf::rt::LazyV2<OutputPoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputPoint::new)
    }
}

impl ::protobuf::Clear for OutputPoint {
    fn clear(&mut self) {
        self.hash.clear();
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct OutputPointInfo {
    // message fields
    pub out_points: ::protobuf::RepeatedField<OutputPoint>,
    pub block_num: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputPointInfo {
    fn default() -> &'a OutputPointInfo {
        <OutputPointInfo as ::protobuf::Message>::default_instance()
    }
}

impl OutputPointInfo {
    pub fn new() -> OutputPointInfo {
        ::std::default::Default::default()
    }

    // repeated .protocol.OutputPoint out_points = 1;


    pub fn get_out_points(&self) -> &[OutputPoint] {
        &self.out_points
    }
    pub fn clear_out_points(&mut self) {
        self.out_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_out_points(&mut self, v: ::protobuf::RepeatedField<OutputPoint>) {
        self.out_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_out_points(&mut self) -> &mut ::protobuf::RepeatedField<OutputPoint> {
        &mut self.out_points
    }

    // Take field
    pub fn take_out_points(&mut self) -> ::protobuf::RepeatedField<OutputPoint> {
        ::std::mem::replace(&mut self.out_points, ::protobuf::RepeatedField::new())
    }

    // int32 block_num = 2;


    pub fn get_block_num(&self) -> i32 {
        self.block_num
    }
    pub fn clear_block_num(&mut self) {
        self.block_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_num(&mut self, v: i32) {
        self.block_num = v;
    }
}

impl ::protobuf::Message for OutputPointInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.out_points {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.out_points)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.out_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.block_num != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.out_points {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.block_num != 0 {
            os.write_int32(2, self.block_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputPointInfo {
        OutputPointInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputPoint>>(
                "out_points",
                |m: &OutputPointInfo| { &m.out_points },
                |m: &mut OutputPointInfo| { &mut m.out_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_num",
                |m: &OutputPointInfo| { &m.block_num },
                |m: &mut OutputPointInfo| { &mut m.block_num },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputPointInfo>(
                "OutputPointInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputPointInfo {
        static instance: ::protobuf::rt::LazyV2<OutputPointInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputPointInfo::new)
    }
}

impl ::protobuf::Clear for OutputPointInfo {
    fn clear(&mut self) {
        self.out_points.clear();
        self.block_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputPointInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputPointInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PedersenHash {
    // message fields
    pub content: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PedersenHash {
    fn default() -> &'a PedersenHash {
        <PedersenHash as ::protobuf::Message>::default_instance()
    }
}

impl PedersenHash {
    pub fn new() -> PedersenHash {
        ::std::default::Default::default()
    }

    // bytes content = 1;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PedersenHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_bytes(1, &self.content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PedersenHash {
        PedersenHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &PedersenHash| { &m.content },
                |m: &mut PedersenHash| { &mut m.content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PedersenHash>(
                "PedersenHash",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PedersenHash {
        static instance: ::protobuf::rt::LazyV2<PedersenHash> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PedersenHash::new)
    }
}

impl ::protobuf::Clear for PedersenHash {
    fn clear(&mut self) {
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PedersenHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PedersenHash {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IncrementalMerkleTree {
    // message fields
    pub left: ::protobuf::SingularPtrField<PedersenHash>,
    pub right: ::protobuf::SingularPtrField<PedersenHash>,
    pub parents: ::protobuf::RepeatedField<PedersenHash>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IncrementalMerkleTree {
    fn default() -> &'a IncrementalMerkleTree {
        <IncrementalMerkleTree as ::protobuf::Message>::default_instance()
    }
}

impl IncrementalMerkleTree {
    pub fn new() -> IncrementalMerkleTree {
        ::std::default::Default::default()
    }

    // .protocol.PedersenHash left = 1;


    pub fn get_left(&self) -> &PedersenHash {
        self.left.as_ref().unwrap_or_else(|| <PedersenHash as ::protobuf::Message>::default_instance())
    }
    pub fn clear_left(&mut self) {
        self.left.clear();
    }

    pub fn has_left(&self) -> bool {
        self.left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: PedersenHash) {
        self.left = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_left(&mut self) -> &mut PedersenHash {
        if self.left.is_none() {
            self.left.set_default();
        }
        self.left.as_mut().unwrap()
    }

    // Take field
    pub fn take_left(&mut self) -> PedersenHash {
        self.left.take().unwrap_or_else(|| PedersenHash::new())
    }

    // .protocol.PedersenHash right = 2;


    pub fn get_right(&self) -> &PedersenHash {
        self.right.as_ref().unwrap_or_else(|| <PedersenHash as ::protobuf::Message>::default_instance())
    }
    pub fn clear_right(&mut self) {
        self.right.clear();
    }

    pub fn has_right(&self) -> bool {
        self.right.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: PedersenHash) {
        self.right = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right(&mut self) -> &mut PedersenHash {
        if self.right.is_none() {
            self.right.set_default();
        }
        self.right.as_mut().unwrap()
    }

    // Take field
    pub fn take_right(&mut self) -> PedersenHash {
        self.right.take().unwrap_or_else(|| PedersenHash::new())
    }

    // repeated .protocol.PedersenHash parents = 3;


    pub fn get_parents(&self) -> &[PedersenHash] {
        &self.parents
    }
    pub fn clear_parents(&mut self) {
        self.parents.clear();
    }

    // Param is passed by value, moved
    pub fn set_parents(&mut self, v: ::protobuf::RepeatedField<PedersenHash>) {
        self.parents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parents(&mut self) -> &mut ::protobuf::RepeatedField<PedersenHash> {
        &mut self.parents
    }

    // Take field
    pub fn take_parents(&mut self) -> ::protobuf::RepeatedField<PedersenHash> {
        ::std::mem::replace(&mut self.parents, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IncrementalMerkleTree {
    fn is_initialized(&self) -> bool {
        for v in &self.left {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parents {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.left)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.right)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.left.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.right.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.parents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.left.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.right.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.parents {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IncrementalMerkleTree {
        IncrementalMerkleTree::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PedersenHash>>(
                "left",
                |m: &IncrementalMerkleTree| { &m.left },
                |m: &mut IncrementalMerkleTree| { &mut m.left },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PedersenHash>>(
                "right",
                |m: &IncrementalMerkleTree| { &m.right },
                |m: &mut IncrementalMerkleTree| { &mut m.right },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PedersenHash>>(
                "parents",
                |m: &IncrementalMerkleTree| { &m.parents },
                |m: &mut IncrementalMerkleTree| { &mut m.parents },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IncrementalMerkleTree>(
                "IncrementalMerkleTree",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IncrementalMerkleTree {
        static instance: ::protobuf::rt::LazyV2<IncrementalMerkleTree> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IncrementalMerkleTree::new)
    }
}

impl ::protobuf::Clear for IncrementalMerkleTree {
    fn clear(&mut self) {
        self.left.clear();
        self.right.clear();
        self.parents.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IncrementalMerkleTree {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IncrementalMerkleTree {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IncrementalMerkleVoucher {
    // message fields
    pub tree: ::protobuf::SingularPtrField<IncrementalMerkleTree>,
    pub filled: ::protobuf::RepeatedField<PedersenHash>,
    pub cursor: ::protobuf::SingularPtrField<IncrementalMerkleTree>,
    pub cursor_depth: i64,
    pub rt: ::std::vec::Vec<u8>,
    pub output_point: ::protobuf::SingularPtrField<OutputPoint>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IncrementalMerkleVoucher {
    fn default() -> &'a IncrementalMerkleVoucher {
        <IncrementalMerkleVoucher as ::protobuf::Message>::default_instance()
    }
}

impl IncrementalMerkleVoucher {
    pub fn new() -> IncrementalMerkleVoucher {
        ::std::default::Default::default()
    }

    // .protocol.IncrementalMerkleTree tree = 1;


    pub fn get_tree(&self) -> &IncrementalMerkleTree {
        self.tree.as_ref().unwrap_or_else(|| <IncrementalMerkleTree as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tree(&mut self) {
        self.tree.clear();
    }

    pub fn has_tree(&self) -> bool {
        self.tree.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tree(&mut self, v: IncrementalMerkleTree) {
        self.tree = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tree(&mut self) -> &mut IncrementalMerkleTree {
        if self.tree.is_none() {
            self.tree.set_default();
        }
        self.tree.as_mut().unwrap()
    }

    // Take field
    pub fn take_tree(&mut self) -> IncrementalMerkleTree {
        self.tree.take().unwrap_or_else(|| IncrementalMerkleTree::new())
    }

    // repeated .protocol.PedersenHash filled = 2;


    pub fn get_filled(&self) -> &[PedersenHash] {
        &self.filled
    }
    pub fn clear_filled(&mut self) {
        self.filled.clear();
    }

    // Param is passed by value, moved
    pub fn set_filled(&mut self, v: ::protobuf::RepeatedField<PedersenHash>) {
        self.filled = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filled(&mut self) -> &mut ::protobuf::RepeatedField<PedersenHash> {
        &mut self.filled
    }

    // Take field
    pub fn take_filled(&mut self) -> ::protobuf::RepeatedField<PedersenHash> {
        ::std::mem::replace(&mut self.filled, ::protobuf::RepeatedField::new())
    }

    // .protocol.IncrementalMerkleTree cursor = 3;


    pub fn get_cursor(&self) -> &IncrementalMerkleTree {
        self.cursor.as_ref().unwrap_or_else(|| <IncrementalMerkleTree as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: IncrementalMerkleTree) {
        self.cursor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut IncrementalMerkleTree {
        if self.cursor.is_none() {
            self.cursor.set_default();
        }
        self.cursor.as_mut().unwrap()
    }

    // Take field
    pub fn take_cursor(&mut self) -> IncrementalMerkleTree {
        self.cursor.take().unwrap_or_else(|| IncrementalMerkleTree::new())
    }

    // int64 cursor_depth = 4;


    pub fn get_cursor_depth(&self) -> i64 {
        self.cursor_depth
    }
    pub fn clear_cursor_depth(&mut self) {
        self.cursor_depth = 0;
    }

    // Param is passed by value, moved
    pub fn set_cursor_depth(&mut self, v: i64) {
        self.cursor_depth = v;
    }

    // bytes rt = 5;


    pub fn get_rt(&self) -> &[u8] {
        &self.rt
    }
    pub fn clear_rt(&mut self) {
        self.rt.clear();
    }

    // Param is passed by value, moved
    pub fn set_rt(&mut self, v: ::std::vec::Vec<u8>) {
        self.rt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.rt
    }

    // Take field
    pub fn take_rt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.rt, ::std::vec::Vec::new())
    }

    // .protocol.OutputPoint output_point = 10;


    pub fn get_output_point(&self) -> &OutputPoint {
        self.output_point.as_ref().unwrap_or_else(|| <OutputPoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_point(&mut self) {
        self.output_point.clear();
    }

    pub fn has_output_point(&self) -> bool {
        self.output_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_point(&mut self, v: OutputPoint) {
        self.output_point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_point(&mut self) -> &mut OutputPoint {
        if self.output_point.is_none() {
            self.output_point.set_default();
        }
        self.output_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_point(&mut self) -> OutputPoint {
        self.output_point.take().unwrap_or_else(|| OutputPoint::new())
    }
}

impl ::protobuf::Message for IncrementalMerkleVoucher {
    fn is_initialized(&self) -> bool {
        for v in &self.tree {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cursor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tree)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filled)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cursor)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cursor_depth = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.rt)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tree.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.filled {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.cursor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.cursor_depth != 0 {
            my_size += ::protobuf::rt::value_size(4, self.cursor_depth, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.rt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.rt);
        }
        if let Some(ref v) = self.output_point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tree.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.filled {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.cursor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.cursor_depth != 0 {
            os.write_int64(4, self.cursor_depth)?;
        }
        if !self.rt.is_empty() {
            os.write_bytes(5, &self.rt)?;
        }
        if let Some(ref v) = self.output_point.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IncrementalMerkleVoucher {
        IncrementalMerkleVoucher::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IncrementalMerkleTree>>(
                "tree",
                |m: &IncrementalMerkleVoucher| { &m.tree },
                |m: &mut IncrementalMerkleVoucher| { &mut m.tree },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PedersenHash>>(
                "filled",
                |m: &IncrementalMerkleVoucher| { &m.filled },
                |m: &mut IncrementalMerkleVoucher| { &mut m.filled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IncrementalMerkleTree>>(
                "cursor",
                |m: &IncrementalMerkleVoucher| { &m.cursor },
                |m: &mut IncrementalMerkleVoucher| { &mut m.cursor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cursor_depth",
                |m: &IncrementalMerkleVoucher| { &m.cursor_depth },
                |m: &mut IncrementalMerkleVoucher| { &mut m.cursor_depth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rt",
                |m: &IncrementalMerkleVoucher| { &m.rt },
                |m: &mut IncrementalMerkleVoucher| { &mut m.rt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputPoint>>(
                "output_point",
                |m: &IncrementalMerkleVoucher| { &m.output_point },
                |m: &mut IncrementalMerkleVoucher| { &mut m.output_point },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IncrementalMerkleVoucher>(
                "IncrementalMerkleVoucher",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IncrementalMerkleVoucher {
        static instance: ::protobuf::rt::LazyV2<IncrementalMerkleVoucher> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IncrementalMerkleVoucher::new)
    }
}

impl ::protobuf::Clear for IncrementalMerkleVoucher {
    fn clear(&mut self) {
        self.tree.clear();
        self.filled.clear();
        self.cursor.clear();
        self.cursor_depth = 0;
        self.rt.clear();
        self.output_point.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IncrementalMerkleVoucher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IncrementalMerkleVoucher {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IncrementalMerkleVoucherInfo {
    // message fields
    pub vouchers: ::protobuf::RepeatedField<IncrementalMerkleVoucher>,
    pub paths: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IncrementalMerkleVoucherInfo {
    fn default() -> &'a IncrementalMerkleVoucherInfo {
        <IncrementalMerkleVoucherInfo as ::protobuf::Message>::default_instance()
    }
}

impl IncrementalMerkleVoucherInfo {
    pub fn new() -> IncrementalMerkleVoucherInfo {
        ::std::default::Default::default()
    }

    // repeated .protocol.IncrementalMerkleVoucher vouchers = 1;


    pub fn get_vouchers(&self) -> &[IncrementalMerkleVoucher] {
        &self.vouchers
    }
    pub fn clear_vouchers(&mut self) {
        self.vouchers.clear();
    }

    // Param is passed by value, moved
    pub fn set_vouchers(&mut self, v: ::protobuf::RepeatedField<IncrementalMerkleVoucher>) {
        self.vouchers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vouchers(&mut self) -> &mut ::protobuf::RepeatedField<IncrementalMerkleVoucher> {
        &mut self.vouchers
    }

    // Take field
    pub fn take_vouchers(&mut self) -> ::protobuf::RepeatedField<IncrementalMerkleVoucher> {
        ::std::mem::replace(&mut self.vouchers, ::protobuf::RepeatedField::new())
    }

    // repeated bytes paths = 2;


    pub fn get_paths(&self) -> &[::std::vec::Vec<u8>] {
        &self.paths
    }
    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.paths, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IncrementalMerkleVoucherInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.vouchers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vouchers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.paths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vouchers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.paths {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vouchers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.paths {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IncrementalMerkleVoucherInfo {
        IncrementalMerkleVoucherInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IncrementalMerkleVoucher>>(
                "vouchers",
                |m: &IncrementalMerkleVoucherInfo| { &m.vouchers },
                |m: &mut IncrementalMerkleVoucherInfo| { &mut m.vouchers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "paths",
                |m: &IncrementalMerkleVoucherInfo| { &m.paths },
                |m: &mut IncrementalMerkleVoucherInfo| { &mut m.paths },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IncrementalMerkleVoucherInfo>(
                "IncrementalMerkleVoucherInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IncrementalMerkleVoucherInfo {
        static instance: ::protobuf::rt::LazyV2<IncrementalMerkleVoucherInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IncrementalMerkleVoucherInfo::new)
    }
}

impl ::protobuf::Clear for IncrementalMerkleVoucherInfo {
    fn clear(&mut self) {
        self.vouchers.clear();
        self.paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IncrementalMerkleVoucherInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IncrementalMerkleVoucherInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SpendDescription {
    // message fields
    pub value_commitment: ::std::vec::Vec<u8>,
    pub anchor: ::std::vec::Vec<u8>,
    pub nullifier: ::std::vec::Vec<u8>,
    pub rk: ::std::vec::Vec<u8>,
    pub zkproof: ::std::vec::Vec<u8>,
    pub spend_authority_signature: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpendDescription {
    fn default() -> &'a SpendDescription {
        <SpendDescription as ::protobuf::Message>::default_instance()
    }
}

impl SpendDescription {
    pub fn new() -> SpendDescription {
        ::std::default::Default::default()
    }

    // bytes value_commitment = 1;


    pub fn get_value_commitment(&self) -> &[u8] {
        &self.value_commitment
    }
    pub fn clear_value_commitment(&mut self) {
        self.value_commitment.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_commitment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value_commitment
    }

    // Take field
    pub fn take_value_commitment(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value_commitment, ::std::vec::Vec::new())
    }

    // bytes anchor = 2;


    pub fn get_anchor(&self) -> &[u8] {
        &self.anchor
    }
    pub fn clear_anchor(&mut self) {
        self.anchor.clear();
    }

    // Param is passed by value, moved
    pub fn set_anchor(&mut self, v: ::std::vec::Vec<u8>) {
        self.anchor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_anchor(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.anchor
    }

    // Take field
    pub fn take_anchor(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.anchor, ::std::vec::Vec::new())
    }

    // bytes nullifier = 3;


    pub fn get_nullifier(&self) -> &[u8] {
        &self.nullifier
    }
    pub fn clear_nullifier(&mut self) {
        self.nullifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_nullifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.nullifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nullifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nullifier
    }

    // Take field
    pub fn take_nullifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nullifier, ::std::vec::Vec::new())
    }

    // bytes rk = 4;


    pub fn get_rk(&self) -> &[u8] {
        &self.rk
    }
    pub fn clear_rk(&mut self) {
        self.rk.clear();
    }

    // Param is passed by value, moved
    pub fn set_rk(&mut self, v: ::std::vec::Vec<u8>) {
        self.rk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.rk
    }

    // Take field
    pub fn take_rk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.rk, ::std::vec::Vec::new())
    }

    // bytes zkproof = 5;


    pub fn get_zkproof(&self) -> &[u8] {
        &self.zkproof
    }
    pub fn clear_zkproof(&mut self) {
        self.zkproof.clear();
    }

    // Param is passed by value, moved
    pub fn set_zkproof(&mut self, v: ::std::vec::Vec<u8>) {
        self.zkproof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zkproof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.zkproof
    }

    // Take field
    pub fn take_zkproof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.zkproof, ::std::vec::Vec::new())
    }

    // bytes spend_authority_signature = 6;


    pub fn get_spend_authority_signature(&self) -> &[u8] {
        &self.spend_authority_signature
    }
    pub fn clear_spend_authority_signature(&mut self) {
        self.spend_authority_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_spend_authority_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_authority_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_authority_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.spend_authority_signature
    }

    // Take field
    pub fn take_spend_authority_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.spend_authority_signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SpendDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value_commitment)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.anchor)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nullifier)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.rk)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.zkproof)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.spend_authority_signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value_commitment.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value_commitment);
        }
        if !self.anchor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.anchor);
        }
        if !self.nullifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.nullifier);
        }
        if !self.rk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.rk);
        }
        if !self.zkproof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.zkproof);
        }
        if !self.spend_authority_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.spend_authority_signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value_commitment.is_empty() {
            os.write_bytes(1, &self.value_commitment)?;
        }
        if !self.anchor.is_empty() {
            os.write_bytes(2, &self.anchor)?;
        }
        if !self.nullifier.is_empty() {
            os.write_bytes(3, &self.nullifier)?;
        }
        if !self.rk.is_empty() {
            os.write_bytes(4, &self.rk)?;
        }
        if !self.zkproof.is_empty() {
            os.write_bytes(5, &self.zkproof)?;
        }
        if !self.spend_authority_signature.is_empty() {
            os.write_bytes(6, &self.spend_authority_signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpendDescription {
        SpendDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value_commitment",
                |m: &SpendDescription| { &m.value_commitment },
                |m: &mut SpendDescription| { &mut m.value_commitment },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "anchor",
                |m: &SpendDescription| { &m.anchor },
                |m: &mut SpendDescription| { &mut m.anchor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nullifier",
                |m: &SpendDescription| { &m.nullifier },
                |m: &mut SpendDescription| { &mut m.nullifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rk",
                |m: &SpendDescription| { &m.rk },
                |m: &mut SpendDescription| { &mut m.rk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "zkproof",
                |m: &SpendDescription| { &m.zkproof },
                |m: &mut SpendDescription| { &mut m.zkproof },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "spend_authority_signature",
                |m: &SpendDescription| { &m.spend_authority_signature },
                |m: &mut SpendDescription| { &mut m.spend_authority_signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SpendDescription>(
                "SpendDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SpendDescription {
        static instance: ::protobuf::rt::LazyV2<SpendDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SpendDescription::new)
    }
}

impl ::protobuf::Clear for SpendDescription {
    fn clear(&mut self) {
        self.value_commitment.clear();
        self.anchor.clear();
        self.nullifier.clear();
        self.rk.clear();
        self.zkproof.clear();
        self.spend_authority_signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpendDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpendDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ReceiveDescription {
    // message fields
    pub value_commitment: ::std::vec::Vec<u8>,
    pub note_commitment: ::std::vec::Vec<u8>,
    pub epk: ::std::vec::Vec<u8>,
    pub c_enc: ::std::vec::Vec<u8>,
    pub c_out: ::std::vec::Vec<u8>,
    pub zkproof: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReceiveDescription {
    fn default() -> &'a ReceiveDescription {
        <ReceiveDescription as ::protobuf::Message>::default_instance()
    }
}

impl ReceiveDescription {
    pub fn new() -> ReceiveDescription {
        ::std::default::Default::default()
    }

    // bytes value_commitment = 1;


    pub fn get_value_commitment(&self) -> &[u8] {
        &self.value_commitment
    }
    pub fn clear_value_commitment(&mut self) {
        self.value_commitment.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_commitment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value_commitment
    }

    // Take field
    pub fn take_value_commitment(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value_commitment, ::std::vec::Vec::new())
    }

    // bytes note_commitment = 2;


    pub fn get_note_commitment(&self) -> &[u8] {
        &self.note_commitment
    }
    pub fn clear_note_commitment(&mut self) {
        self.note_commitment.clear();
    }

    // Param is passed by value, moved
    pub fn set_note_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.note_commitment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.note_commitment
    }

    // Take field
    pub fn take_note_commitment(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.note_commitment, ::std::vec::Vec::new())
    }

    // bytes epk = 3;


    pub fn get_epk(&self) -> &[u8] {
        &self.epk
    }
    pub fn clear_epk(&mut self) {
        self.epk.clear();
    }

    // Param is passed by value, moved
    pub fn set_epk(&mut self, v: ::std::vec::Vec<u8>) {
        self.epk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epk(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.epk
    }

    // Take field
    pub fn take_epk(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.epk, ::std::vec::Vec::new())
    }

    // bytes c_enc = 4;


    pub fn get_c_enc(&self) -> &[u8] {
        &self.c_enc
    }
    pub fn clear_c_enc(&mut self) {
        self.c_enc.clear();
    }

    // Param is passed by value, moved
    pub fn set_c_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.c_enc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_c_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.c_enc
    }

    // Take field
    pub fn take_c_enc(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.c_enc, ::std::vec::Vec::new())
    }

    // bytes c_out = 5;


    pub fn get_c_out(&self) -> &[u8] {
        &self.c_out
    }
    pub fn clear_c_out(&mut self) {
        self.c_out.clear();
    }

    // Param is passed by value, moved
    pub fn set_c_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.c_out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_c_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.c_out
    }

    // Take field
    pub fn take_c_out(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.c_out, ::std::vec::Vec::new())
    }

    // bytes zkproof = 6;


    pub fn get_zkproof(&self) -> &[u8] {
        &self.zkproof
    }
    pub fn clear_zkproof(&mut self) {
        self.zkproof.clear();
    }

    // Param is passed by value, moved
    pub fn set_zkproof(&mut self, v: ::std::vec::Vec<u8>) {
        self.zkproof = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zkproof(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.zkproof
    }

    // Take field
    pub fn take_zkproof(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.zkproof, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReceiveDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value_commitment)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.note_commitment)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.epk)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.c_enc)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.c_out)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.zkproof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value_commitment.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value_commitment);
        }
        if !self.note_commitment.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.note_commitment);
        }
        if !self.epk.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.epk);
        }
        if !self.c_enc.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.c_enc);
        }
        if !self.c_out.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.c_out);
        }
        if !self.zkproof.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.zkproof);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value_commitment.is_empty() {
            os.write_bytes(1, &self.value_commitment)?;
        }
        if !self.note_commitment.is_empty() {
            os.write_bytes(2, &self.note_commitment)?;
        }
        if !self.epk.is_empty() {
            os.write_bytes(3, &self.epk)?;
        }
        if !self.c_enc.is_empty() {
            os.write_bytes(4, &self.c_enc)?;
        }
        if !self.c_out.is_empty() {
            os.write_bytes(5, &self.c_out)?;
        }
        if !self.zkproof.is_empty() {
            os.write_bytes(6, &self.zkproof)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReceiveDescription {
        ReceiveDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value_commitment",
                |m: &ReceiveDescription| { &m.value_commitment },
                |m: &mut ReceiveDescription| { &mut m.value_commitment },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "note_commitment",
                |m: &ReceiveDescription| { &m.note_commitment },
                |m: &mut ReceiveDescription| { &mut m.note_commitment },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "epk",
                |m: &ReceiveDescription| { &m.epk },
                |m: &mut ReceiveDescription| { &mut m.epk },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "c_enc",
                |m: &ReceiveDescription| { &m.c_enc },
                |m: &mut ReceiveDescription| { &mut m.c_enc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "c_out",
                |m: &ReceiveDescription| { &m.c_out },
                |m: &mut ReceiveDescription| { &mut m.c_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "zkproof",
                |m: &ReceiveDescription| { &m.zkproof },
                |m: &mut ReceiveDescription| { &mut m.zkproof },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReceiveDescription>(
                "ReceiveDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReceiveDescription {
        static instance: ::protobuf::rt::LazyV2<ReceiveDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReceiveDescription::new)
    }
}

impl ::protobuf::Clear for ReceiveDescription {
    fn clear(&mut self) {
        self.value_commitment.clear();
        self.note_commitment.clear();
        self.epk.clear();
        self.c_enc.clear();
        self.c_out.clear();
        self.zkproof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReceiveDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReceiveDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ShieldedTransferContract {
    // message fields
    pub transparent_from_address: ::std::vec::Vec<u8>,
    pub from_amount: i64,
    pub spend_description: ::protobuf::RepeatedField<SpendDescription>,
    pub receive_description: ::protobuf::RepeatedField<ReceiveDescription>,
    pub binding_signature: ::std::vec::Vec<u8>,
    pub transparent_to_address: ::std::vec::Vec<u8>,
    pub to_amount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShieldedTransferContract {
    fn default() -> &'a ShieldedTransferContract {
        <ShieldedTransferContract as ::protobuf::Message>::default_instance()
    }
}

impl ShieldedTransferContract {
    pub fn new() -> ShieldedTransferContract {
        ::std::default::Default::default()
    }

    // bytes transparent_from_address = 1;


    pub fn get_transparent_from_address(&self) -> &[u8] {
        &self.transparent_from_address
    }
    pub fn clear_transparent_from_address(&mut self) {
        self.transparent_from_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_transparent_from_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.transparent_from_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transparent_from_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transparent_from_address
    }

    // Take field
    pub fn take_transparent_from_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transparent_from_address, ::std::vec::Vec::new())
    }

    // int64 from_amount = 2;


    pub fn get_from_amount(&self) -> i64 {
        self.from_amount
    }
    pub fn clear_from_amount(&mut self) {
        self.from_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_amount(&mut self, v: i64) {
        self.from_amount = v;
    }

    // repeated .protocol.SpendDescription spend_description = 3;


    pub fn get_spend_description(&self) -> &[SpendDescription] {
        &self.spend_description
    }
    pub fn clear_spend_description(&mut self) {
        self.spend_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_spend_description(&mut self, v: ::protobuf::RepeatedField<SpendDescription>) {
        self.spend_description = v;
    }

    // Mutable pointer to the field.
    pub fn mut_spend_description(&mut self) -> &mut ::protobuf::RepeatedField<SpendDescription> {
        &mut self.spend_description
    }

    // Take field
    pub fn take_spend_description(&mut self) -> ::protobuf::RepeatedField<SpendDescription> {
        ::std::mem::replace(&mut self.spend_description, ::protobuf::RepeatedField::new())
    }

    // repeated .protocol.ReceiveDescription receive_description = 4;


    pub fn get_receive_description(&self) -> &[ReceiveDescription] {
        &self.receive_description
    }
    pub fn clear_receive_description(&mut self) {
        self.receive_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_receive_description(&mut self, v: ::protobuf::RepeatedField<ReceiveDescription>) {
        self.receive_description = v;
    }

    // Mutable pointer to the field.
    pub fn mut_receive_description(&mut self) -> &mut ::protobuf::RepeatedField<ReceiveDescription> {
        &mut self.receive_description
    }

    // Take field
    pub fn take_receive_description(&mut self) -> ::protobuf::RepeatedField<ReceiveDescription> {
        ::std::mem::replace(&mut self.receive_description, ::protobuf::RepeatedField::new())
    }

    // bytes binding_signature = 5;


    pub fn get_binding_signature(&self) -> &[u8] {
        &self.binding_signature
    }
    pub fn clear_binding_signature(&mut self) {
        self.binding_signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_binding_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.binding_signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binding_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.binding_signature
    }

    // Take field
    pub fn take_binding_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.binding_signature, ::std::vec::Vec::new())
    }

    // bytes transparent_to_address = 6;


    pub fn get_transparent_to_address(&self) -> &[u8] {
        &self.transparent_to_address
    }
    pub fn clear_transparent_to_address(&mut self) {
        self.transparent_to_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_transparent_to_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.transparent_to_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transparent_to_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transparent_to_address
    }

    // Take field
    pub fn take_transparent_to_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transparent_to_address, ::std::vec::Vec::new())
    }

    // int64 to_amount = 7;


    pub fn get_to_amount(&self) -> i64 {
        self.to_amount
    }
    pub fn clear_to_amount(&mut self) {
        self.to_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_amount(&mut self, v: i64) {
        self.to_amount = v;
    }
}

impl ::protobuf::Message for ShieldedTransferContract {
    fn is_initialized(&self) -> bool {
        for v in &self.spend_description {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.receive_description {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transparent_from_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.from_amount = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.spend_description)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.receive_description)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.binding_signature)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transparent_to_address)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.to_amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transparent_from_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transparent_from_address);
        }
        if self.from_amount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.from_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.spend_description {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.receive_description {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.binding_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.binding_signature);
        }
        if !self.transparent_to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.transparent_to_address);
        }
        if self.to_amount != 0 {
            my_size += ::protobuf::rt::value_size(7, self.to_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.transparent_from_address.is_empty() {
            os.write_bytes(1, &self.transparent_from_address)?;
        }
        if self.from_amount != 0 {
            os.write_int64(2, self.from_amount)?;
        }
        for v in &self.spend_description {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.receive_description {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.binding_signature.is_empty() {
            os.write_bytes(5, &self.binding_signature)?;
        }
        if !self.transparent_to_address.is_empty() {
            os.write_bytes(6, &self.transparent_to_address)?;
        }
        if self.to_amount != 0 {
            os.write_int64(7, self.to_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShieldedTransferContract {
        ShieldedTransferContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transparent_from_address",
                |m: &ShieldedTransferContract| { &m.transparent_from_address },
                |m: &mut ShieldedTransferContract| { &mut m.transparent_from_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "from_amount",
                |m: &ShieldedTransferContract| { &m.from_amount },
                |m: &mut ShieldedTransferContract| { &mut m.from_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpendDescription>>(
                "spend_description",
                |m: &ShieldedTransferContract| { &m.spend_description },
                |m: &mut ShieldedTransferContract| { &mut m.spend_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReceiveDescription>>(
                "receive_description",
                |m: &ShieldedTransferContract| { &m.receive_description },
                |m: &mut ShieldedTransferContract| { &mut m.receive_description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "binding_signature",
                |m: &ShieldedTransferContract| { &m.binding_signature },
                |m: &mut ShieldedTransferContract| { &mut m.binding_signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "transparent_to_address",
                |m: &ShieldedTransferContract| { &m.transparent_to_address },
                |m: &mut ShieldedTransferContract| { &mut m.transparent_to_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "to_amount",
                |m: &ShieldedTransferContract| { &m.to_amount },
                |m: &mut ShieldedTransferContract| { &mut m.to_amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShieldedTransferContract>(
                "ShieldedTransferContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShieldedTransferContract {
        static instance: ::protobuf::rt::LazyV2<ShieldedTransferContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShieldedTransferContract::new)
    }
}

impl ::protobuf::Clear for ShieldedTransferContract {
    fn clear(&mut self) {
        self.transparent_from_address.clear();
        self.from_amount = 0;
        self.spend_description.clear();
        self.receive_description.clear();
        self.binding_signature.clear();
        self.transparent_to_address.clear();
        self.to_amount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShieldedTransferContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShieldedTransferContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UpdateBrokerageContract {
    // message fields
    pub owner_address: ::std::vec::Vec<u8>,
    pub brokerage: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBrokerageContract {
    fn default() -> &'a UpdateBrokerageContract {
        <UpdateBrokerageContract as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBrokerageContract {
    pub fn new() -> UpdateBrokerageContract {
        ::std::default::Default::default()
    }

    // bytes owner_address = 1;


    pub fn get_owner_address(&self) -> &[u8] {
        &self.owner_address
    }
    pub fn clear_owner_address(&mut self) {
        self.owner_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.owner_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.owner_address
    }

    // Take field
    pub fn take_owner_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.owner_address, ::std::vec::Vec::new())
    }

    // int32 brokerage = 2;


    pub fn get_brokerage(&self) -> i32 {
        self.brokerage
    }
    pub fn clear_brokerage(&mut self) {
        self.brokerage = 0;
    }

    // Param is passed by value, moved
    pub fn set_brokerage(&mut self, v: i32) {
        self.brokerage = v;
    }
}

impl ::protobuf::Message for UpdateBrokerageContract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.owner_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.brokerage = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.owner_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.owner_address);
        }
        if self.brokerage != 0 {
            my_size += ::protobuf::rt::value_size(2, self.brokerage, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.owner_address.is_empty() {
            os.write_bytes(1, &self.owner_address)?;
        }
        if self.brokerage != 0 {
            os.write_int32(2, self.brokerage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBrokerageContract {
        UpdateBrokerageContract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "owner_address",
                |m: &UpdateBrokerageContract| { &m.owner_address },
                |m: &mut UpdateBrokerageContract| { &mut m.owner_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "brokerage",
                |m: &UpdateBrokerageContract| { &m.brokerage },
                |m: &mut UpdateBrokerageContract| { &mut m.brokerage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateBrokerageContract>(
                "UpdateBrokerageContract",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateBrokerageContract {
        static instance: ::protobuf::rt::LazyV2<UpdateBrokerageContract> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateBrokerageContract::new)
    }
}

impl ::protobuf::Clear for UpdateBrokerageContract {
    fn clear(&mut self) {
        self.owner_address.clear();
        self.brokerage = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBrokerageContract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBrokerageContract {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum ResourceCode {
    BANDWIDTH = 0,
    ENERGY = 1,
}

impl ::protobuf::ProtobufEnum for ResourceCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResourceCode> {
        match value {
            0 => ::std::option::Option::Some(ResourceCode::BANDWIDTH),
            1 => ::std::option::Option::Some(ResourceCode::ENERGY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResourceCode] = &[
            ResourceCode::BANDWIDTH,
            ResourceCode::ENERGY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResourceCode>("ResourceCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResourceCode {
}

impl ::std::default::Default for ResourceCode {
    fn default() -> Self {
        ResourceCode::BANDWIDTH
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13core/Contract.proto\x12\x08protocol\x1a\x0fcore/Tron.proto\"\x90\
    \x01\n\x15AccountCreateContract\x12#\n\rowner_address\x18\x01\x20\x01(\
    \x0cR\x0cownerAddress\x12'\n\x0faccount_address\x18\x02\x20\x01(\x0cR\
    \x0eaccountAddress\x12)\n\x04type\x18\x03\x20\x01(\x0e2\x15.protocol.Acc\
    ountTypeR\x04type\"_\n\x15AccountUpdateContract\x12!\n\x0caccount_name\
    \x18\x01\x20\x01(\x0cR\x0baccountName\x12#\n\rowner_address\x18\x02\x20\
    \x01(\x0cR\x0cownerAddress\"Z\n\x14SetAccountIdContract\x12\x1d\n\naccou\
    nt_id\x18\x01\x20\x01(\x0cR\taccountId\x12#\n\rowner_address\x18\x02\x20\
    \x01(\x0cR\x0cownerAddress\"n\n\x10TransferContract\x12#\n\rowner_addres\
    s\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1d\n\nto_address\x18\x02\
    \x20\x01(\x0cR\ttoAddress\x12\x16\n\x06amount\x18\x03\x20\x01(\x03R\x06a\
    mount\"_\n\rShieldAddress\x12'\n\x0fprivate_address\x18\x01\x20\x01(\x0c\
    R\x0eprivateAddress\x12%\n\x0epublic_address\x18\x02\x20\x01(\x0cR\rpubl\
    icAddress\"\x92\x01\n\x15TransferAssetContract\x12\x1d\n\nasset_name\x18\
    \x01\x20\x01(\x0cR\tassetName\x12#\n\rowner_address\x18\x02\x20\x01(\x0c\
    R\x0cownerAddress\x12\x1d\n\nto_address\x18\x03\x20\x01(\x0cR\ttoAddress\
    \x12\x16\n\x06amount\x18\x04\x20\x01(\x03R\x06amount\"\x8b\x01\n\x11Vote\
    AssetContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddres\
    s\x12!\n\x0cvote_address\x18\x02\x20\x03(\x0cR\x0bvoteAddress\x12\x18\n\
    \x07support\x18\x03\x20\x01(\x08R\x07support\x12\x14\n\x05count\x18\x05\
    \x20\x01(\x05R\x05count\"\xd8\x01\n\x13VoteWitnessContract\x12#\n\rowner\
    _address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x128\n\x05votes\x18\x02\
    \x20\x03(\x0b2\".protocol.VoteWitnessContract.VoteR\x05votes\x12\x18\n\
    \x07support\x18\x03\x20\x01(\x08R\x07support\x1aH\n\x04Vote\x12!\n\x0cvo\
    te_address\x18\x01\x20\x01(\x0cR\x0bvoteAddress\x12\x1d\n\nvote_count\
    \x18\x02\x20\x01(\x03R\tvoteCount\"\xaa\x01\n\x15UpdateSettingContract\
    \x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12)\n\x10c\
    ontract_address\x18\x02\x20\x01(\x0cR\x0fcontractAddress\x12A\n\x1dconsu\
    me_user_resource_percent\x18\x03\x20\x01(\x03R\x1aconsumeUserResourcePer\
    cent\"\x9b\x01\n\x19UpdateEnergyLimitContract\x12#\n\rowner_address\x18\
    \x01\x20\x01(\x0cR\x0cownerAddress\x12)\n\x10contract_address\x18\x02\
    \x20\x01(\x0cR\x0fcontractAddress\x12.\n\x13origin_energy_limit\x18\x03\
    \x20\x01(\x03R\x11originEnergyLimit\"b\n\x10ClearABIContract\x12#\n\rown\
    er_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12)\n\x10contract_addr\
    ess\x18\x02\x20\x01(\x0cR\x0fcontractAddress\"N\n\x15WitnessCreateContra\
    ct\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x10\n\
    \x03url\x18\x02\x20\x01(\x0cR\x03url\"[\n\x15WitnessUpdateContract\x12#\
    \n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1d\n\nupdat\
    e_url\x18\x0c\x20\x01(\x0cR\tupdateUrl\"\x91\x06\n\x12AssetIssueContract\
    \x12\x0e\n\x02id\x18)\x20\x01(\tR\x02id\x12#\n\rowner_address\x18\x01\
    \x20\x01(\x0cR\x0cownerAddress\x12\x12\n\x04name\x18\x02\x20\x01(\x0cR\
    \x04name\x12\x12\n\x04abbr\x18\x03\x20\x01(\x0cR\x04abbr\x12!\n\x0ctotal\
    _supply\x18\x04\x20\x01(\x03R\x0btotalSupply\x12N\n\rfrozen_supply\x18\
    \x05\x20\x03(\x0b2).protocol.AssetIssueContract.FrozenSupplyR\x0cfrozenS\
    upply\x12\x17\n\x07trx_num\x18\x06\x20\x01(\x05R\x06trxNum\x12\x1c\n\tpr\
    ecision\x18\x07\x20\x01(\x05R\tprecision\x12\x10\n\x03num\x18\x08\x20\
    \x01(\x05R\x03num\x12\x1d\n\nstart_time\x18\t\x20\x01(\x03R\tstartTime\
    \x12\x19\n\x08end_time\x18\n\x20\x01(\x03R\x07endTime\x12\x14\n\x05order\
    \x18\x0b\x20\x01(\x03R\x05order\x12\x1d\n\nvote_score\x18\x10\x20\x01(\
    \x05R\tvoteScore\x12\x20\n\x0bdescription\x18\x14\x20\x01(\x0cR\x0bdescr\
    iption\x12\x10\n\x03url\x18\x15\x20\x01(\x0cR\x03url\x12/\n\x14free_asse\
    t_net_limit\x18\x16\x20\x01(\x03R\x11freeAssetNetLimit\x12<\n\x1bpublic_\
    free_asset_net_limit\x18\x17\x20\x01(\x03R\x17publicFreeAssetNetLimit\
    \x12<\n\x1bpublic_free_asset_net_usage\x18\x18\x20\x01(\x03R\x17publicFr\
    eeAssetNetUsage\x12<\n\x1bpublic_latest_free_net_time\x18\x19\x20\x01(\
    \x03R\x17publicLatestFreeNetTime\x1aT\n\x0cFrozenSupply\x12#\n\rfrozen_a\
    mount\x18\x01\x20\x01(\x03R\x0cfrozenAmount\x12\x1f\n\x0bfrozen_days\x18\
    \x02\x20\x01(\x03R\nfrozenDays\"\x9a\x01\n\x1dParticipateAssetIssueContr\
    act\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1d\
    \n\nto_address\x18\x02\x20\x01(\x0cR\ttoAddress\x12\x1d\n\nasset_name\
    \x18\x03\x20\x01(\x0cR\tassetName\x12\x16\n\x06amount\x18\x04\x20\x01(\
    \x03R\x06amount\"\xeb\x01\n\x15FreezeBalanceContract\x12#\n\rowner_addre\
    ss\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12%\n\x0efrozen_balance\x18\
    \x02\x20\x01(\x03R\rfrozenBalance\x12'\n\x0ffrozen_duration\x18\x03\x20\
    \x01(\x03R\x0efrozenDuration\x122\n\x08resource\x18\n\x20\x01(\x0e2\x16.\
    protocol.ResourceCodeR\x08resource\x12)\n\x10receiver_address\x18\x0f\
    \x20\x01(\x0cR\x0freceiverAddress\"\x9d\x01\n\x17UnfreezeBalanceContract\
    \x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x122\n\x08r\
    esource\x18\n\x20\x01(\x0e2\x16.protocol.ResourceCodeR\x08resource\x12)\
    \n\x10receiver_address\x18\x0f\x20\x01(\x0cR\x0freceiverAddress\"<\n\x15\
    UnfreezeAssetContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cown\
    erAddress\">\n\x17WithdrawBalanceContract\x12#\n\rowner_address\x18\x01\
    \x20\x01(\x0cR\x0cownerAddress\"\xb5\x01\n\x13UpdateAssetContract\x12#\n\
    \rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x20\n\x0bdescr\
    iption\x18\x02\x20\x01(\x0cR\x0bdescription\x12\x10\n\x03url\x18\x03\x20\
    \x01(\x0cR\x03url\x12\x1b\n\tnew_limit\x18\x04\x20\x01(\x03R\x08newLimit\
    \x12(\n\x10new_public_limit\x18\x05\x20\x01(\x03R\x0enewPublicLimit\"\
    \xce\x01\n\x16ProposalCreateContract\x12#\n\rowner_address\x18\x01\x20\
    \x01(\x0cR\x0cownerAddress\x12P\n\nparameters\x18\x02\x20\x03(\x0b20.pro\
    tocol.ProposalCreateContract.ParametersEntryR\nparameters\x1a=\n\x0fPara\
    metersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\x03R\x05value:\x028\x01\"\x87\x01\n\x17ProposalApp\
    roveContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\
    \x12\x1f\n\x0bproposal_id\x18\x02\x20\x01(\x03R\nproposalId\x12&\n\x0fis\
    _add_approval\x18\x03\x20\x01(\x08R\risAddApproval\"^\n\x16ProposalDelet\
    eContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\
    \x12\x1f\n\x0bproposal_id\x18\x02\x20\x01(\x03R\nproposalId\"\xbb\x01\n\
    \x13CreateSmartContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0co\
    wnerAddress\x12:\n\x0cnew_contract\x18\x02\x20\x01(\x0b2\x17.protocol.Sm\
    artContractR\x0bnewContract\x12(\n\x10call_token_value\x18\x03\x20\x01(\
    \x03R\x0ecallTokenValue\x12\x19\n\x08token_id\x18\x04\x20\x01(\x03R\x07t\
    okenId\"\xde\x01\n\x14TriggerSmartContract\x12#\n\rowner_address\x18\x01\
    \x20\x01(\x0cR\x0cownerAddress\x12)\n\x10contract_address\x18\x02\x20\
    \x01(\x0cR\x0fcontractAddress\x12\x1d\n\ncall_value\x18\x03\x20\x01(\x03\
    R\tcallValue\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\x12(\n\x10c\
    all_token_value\x18\x05\x20\x01(\x03R\x0ecallTokenValue\x12\x19\n\x08tok\
    en_id\x18\x06\x20\x01(\x03R\x07tokenId\"O\n\x12BuyStorageContract\x12#\n\
    \rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x14\n\x05quant\
    \x18\x02\x20\x01(\x03R\x05quant\"T\n\x17BuyStorageBytesContract\x12#\n\r\
    owner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x14\n\x05bytes\
    \x18\x02\x20\x01(\x03R\x05bytes\"_\n\x13SellStorageContract\x12#\n\rowne\
    r_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12#\n\rstorage_bytes\
    \x18\x02\x20\x01(\x03R\x0cstorageBytes\"\xed\x01\n\x16ExchangeCreateCont\
    ract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12$\n\
    \x0efirst_token_id\x18\x02\x20\x01(\x0cR\x0cfirstTokenId\x12.\n\x13first\
    _token_balance\x18\x03\x20\x01(\x03R\x11firstTokenBalance\x12&\n\x0fseco\
    nd_token_id\x18\x04\x20\x01(\x0cR\rsecondTokenId\x120\n\x14second_token_\
    balance\x18\x05\x20\x01(\x03R\x12secondTokenBalance\"\x8f\x01\n\x16Excha\
    ngeInjectContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAd\
    dress\x12\x1f\n\x0bexchange_id\x18\x02\x20\x01(\x03R\nexchangeId\x12\x19\
    \n\x08token_id\x18\x03\x20\x01(\x0cR\x07tokenId\x12\x14\n\x05quant\x18\
    \x04\x20\x01(\x03R\x05quant\"\x91\x01\n\x18ExchangeWithdrawContract\x12#\
    \n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1f\n\x0bexc\
    hange_id\x18\x02\x20\x01(\x03R\nexchangeId\x12\x19\n\x08token_id\x18\x03\
    \x20\x01(\x0cR\x07tokenId\x12\x14\n\x05quant\x18\x04\x20\x01(\x03R\x05qu\
    ant\"\xb0\x01\n\x1bExchangeTransactionContract\x12#\n\rowner_address\x18\
    \x01\x20\x01(\x0cR\x0cownerAddress\x12\x1f\n\x0bexchange_id\x18\x02\x20\
    \x01(\x03R\nexchangeId\x12\x19\n\x08token_id\x18\x03\x20\x01(\x0cR\x07to\
    kenId\x12\x14\n\x05quant\x18\x04\x20\x01(\x03R\x05quant\x12\x1a\n\x08exp\
    ected\x18\x05\x20\x01(\x03R\x08expected\"\xd2\x01\n\x1fAccountPermission\
    UpdateContract\x12#\n\rowner_address\x18\x01\x20\x01(\x0cR\x0cownerAddre\
    ss\x12*\n\x05owner\x18\x02\x20\x01(\x0b2\x14.protocol.PermissionR\x05own\
    er\x12.\n\x07witness\x18\x03\x20\x01(\x0b2\x14.protocol.PermissionR\x07w\
    itness\x12.\n\x07actives\x18\x04\x20\x03(\x0b2\x14.protocol.PermissionR\
    \x07actives\"*\n\x12AuthenticationPath\x12\x14\n\x05value\x18\x01\x20\
    \x03(\x08R\x05value\"\x83\x01\n\nMerklePath\x12O\n\x14authentication_pat\
    hs\x18\x01\x20\x03(\x0b2\x1c.protocol.AuthenticationPathR\x13authenticat\
    ionPaths\x12\x14\n\x05index\x18\x02\x20\x03(\x08R\x05index\x12\x0e\n\x02\
    rt\x18\x03\x20\x01(\x0cR\x02rt\"7\n\x0bOutputPoint\x12\x12\n\x04hash\x18\
    \x01\x20\x01(\x0cR\x04hash\x12\x14\n\x05index\x18\x02\x20\x01(\x05R\x05i\
    ndex\"d\n\x0fOutputPointInfo\x124\n\nout_points\x18\x01\x20\x03(\x0b2\
    \x15.protocol.OutputPointR\toutPoints\x12\x1b\n\tblock_num\x18\x02\x20\
    \x01(\x05R\x08blockNum\"(\n\x0cPedersenHash\x12\x18\n\x07content\x18\x01\
    \x20\x01(\x0cR\x07content\"\xa3\x01\n\x15IncrementalMerkleTree\x12*\n\
    \x04left\x18\x01\x20\x01(\x0b2\x16.protocol.PedersenHashR\x04left\x12,\n\
    \x05right\x18\x02\x20\x01(\x0b2\x16.protocol.PedersenHashR\x05right\x120\
    \n\x07parents\x18\x03\x20\x03(\x0b2\x16.protocol.PedersenHashR\x07parent\
    s\"\xa5\x02\n\x18IncrementalMerkleVoucher\x123\n\x04tree\x18\x01\x20\x01\
    (\x0b2\x1f.protocol.IncrementalMerkleTreeR\x04tree\x12.\n\x06filled\x18\
    \x02\x20\x03(\x0b2\x16.protocol.PedersenHashR\x06filled\x127\n\x06cursor\
    \x18\x03\x20\x01(\x0b2\x1f.protocol.IncrementalMerkleTreeR\x06cursor\x12\
    !\n\x0ccursor_depth\x18\x04\x20\x01(\x03R\x0bcursorDepth\x12\x0e\n\x02rt\
    \x18\x05\x20\x01(\x0cR\x02rt\x128\n\x0coutput_point\x18\n\x20\x01(\x0b2\
    \x15.protocol.OutputPointR\x0boutputPoint\"t\n\x1cIncrementalMerkleVouch\
    erInfo\x12>\n\x08vouchers\x18\x01\x20\x03(\x0b2\".protocol.IncrementalMe\
    rkleVoucherR\x08vouchers\x12\x14\n\x05paths\x18\x02\x20\x03(\x0cR\x05pat\
    hs\"\xd9\x01\n\x10SpendDescription\x12)\n\x10value_commitment\x18\x01\
    \x20\x01(\x0cR\x0fvalueCommitment\x12\x16\n\x06anchor\x18\x02\x20\x01(\
    \x0cR\x06anchor\x12\x1c\n\tnullifier\x18\x03\x20\x01(\x0cR\tnullifier\
    \x12\x0e\n\x02rk\x18\x04\x20\x01(\x0cR\x02rk\x12\x18\n\x07zkproof\x18\
    \x05\x20\x01(\x0cR\x07zkproof\x12:\n\x19spend_authority_signature\x18\
    \x06\x20\x01(\x0cR\x17spendAuthoritySignature\"\xbe\x01\n\x12ReceiveDesc\
    ription\x12)\n\x10value_commitment\x18\x01\x20\x01(\x0cR\x0fvalueCommitm\
    ent\x12'\n\x0fnote_commitment\x18\x02\x20\x01(\x0cR\x0enoteCommitment\
    \x12\x10\n\x03epk\x18\x03\x20\x01(\x0cR\x03epk\x12\x13\n\x05c_enc\x18\
    \x04\x20\x01(\x0cR\x04cEnc\x12\x13\n\x05c_out\x18\x05\x20\x01(\x0cR\x04c\
    Out\x12\x18\n\x07zkproof\x18\x06\x20\x01(\x0cR\x07zkproof\"\x8d\x03\n\
    \x18ShieldedTransferContract\x128\n\x18transparent_from_address\x18\x01\
    \x20\x01(\x0cR\x16transparentFromAddress\x12\x1f\n\x0bfrom_amount\x18\
    \x02\x20\x01(\x03R\nfromAmount\x12G\n\x11spend_description\x18\x03\x20\
    \x03(\x0b2\x1a.protocol.SpendDescriptionR\x10spendDescription\x12M\n\x13\
    receive_description\x18\x04\x20\x03(\x0b2\x1c.protocol.ReceiveDescriptio\
    nR\x12receiveDescription\x12+\n\x11binding_signature\x18\x05\x20\x01(\
    \x0cR\x10bindingSignature\x124\n\x16transparent_to_address\x18\x06\x20\
    \x01(\x0cR\x14transparentToAddress\x12\x1b\n\tto_amount\x18\x07\x20\x01(\
    \x03R\x08toAmount\"\\\n\x17UpdateBrokerageContract\x12#\n\rowner_address\
    \x18\x01\x20\x01(\x0cR\x0cownerAddress\x12\x1c\n\tbrokerage\x18\x02\x20\
    \x01(\x05R\tbrokerage*)\n\x0cResourceCode\x12\r\n\tBANDWIDTH\x10\0\x12\n\
    \n\x06ENERGY\x10\x01BF\n\x0forg.tron.protosB\x08ContractZ)github.com/tro\
    nprotocol/grpc-gateway/coreb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
